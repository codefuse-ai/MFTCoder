{"name": "HumanEval_0_has_close_elements", "language": "ml", "prompt": "(**Check if in given list of numbers, are any two numbers closer to each other than\n * given threshold.\n*)\nlet has_close_elements (numbers : float list) (threshold : float) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_0_has_close_elements.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = has_close_elements in\n  (assert ((candidate [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.3) = true));\n  (assert ((candidate [1.0; 2.0; 3.9; 4.0; 5.0; 2.2] 0.05) = false));\n  (assert ((candidate [1.0; 2.0; 5.9; 4.0; 5.0] 0.95) = true));\n  (assert ((candidate [1.0; 2.0; 5.9; 4.0; 5.0] 0.8) = false));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0; 2.0] 0.1) = true));\n  (assert ((candidate [1.1; 2.2; 3.1; 4.1; 5.1] 1.0) = true));\n  (assert ((candidate [1.1; 2.2; 3.1; 4.1; 5.1] 0.5) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_100_make_a_pile", "language": "ml", "prompt": "(**Given a positive integer n, you have to make a pile of n levels of stones.\n * The first level has n stones.\n * The number of stones in the next level is:\n * - the next odd number if n is odd.\n * - the next even number if n is even.\n * Return the number of stones in each level in a list, where element at index\n * i represents the number of stones in the level (i+1).\n * Examples:\n*)\nlet make_a_pile (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_100_make_a_pile.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = make_a_pile in\n  (assert ((candidate 3) = [3; 5; 7]));\n  (assert ((candidate 4) = [4; 6; 8; 10]));\n  (assert ((candidate 5) = [5; 7; 9; 11; 13]));\n  (assert ((candidate 6) = [6; 8; 10; 12; 14; 16]));\n  (assert ((candidate 8) = [8; 10; 12; 14; 16; 18; 20; 22]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_101_words_string", "language": "ml", "prompt": "(**You will be given a string of words separated by commas or spaces. Your task is\n * to split the string into words and return an array of the words.\n * For example:\n*)\nlet words_string (s : string) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_101_words_string.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = words_string in\n  (assert ((candidate \"Hi, my name is John\") = [\"Hi\"; \"my\"; \"name\"; \"is\"; \"John\"]));\n  (assert ((candidate \"One, two, three, four, five, six\") = [\"One\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"]));\n  (assert ((candidate \"Hi, my name\") = [\"Hi\"; \"my\"; \"name\"]));\n  (assert ((candidate \"One,, two, three, four, five, six,\") = [\"One\"; \"two\"; \"three\"; \"four\"; \"five\"; \"six\"]));\n  (assert ((candidate \"\") = []));\n  (assert ((candidate \"ahmed     , gamal\") = [\"ahmed\"; \"gamal\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_102_choose_num", "language": "ml", "prompt": "(**This function takes two positive numbers x and y and returns the\n * biggest even integer number that is in the range [x, y] inclusive. If \n * there's no such number, then the function should return -1.\n * For example:\n*)\nlet choose_num (x : int) (y : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_102_choose_num.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = choose_num in\n  (assert ((candidate 12 15) = 14));\n  (assert ((candidate 13 12) = (~1)));\n  (assert ((candidate 33 12354) = 12354));\n  (assert ((candidate 5234 5233) = (~1)));\n  (assert ((candidate 6 29) = 28));\n  (assert ((candidate 27 10) = (~1)));\n  (assert ((candidate 7 7) = (~1)));\n  (assert ((candidate 546 546) = 546));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_104_unique_digits", "language": "ml", "prompt": "(**Given a list of positive integers x. return a sorted list of all \n * elements that hasn't any even digit.\n * Note: Returned list should be sorted in increasing order.\n * For example:\n*)\nlet unique_digits (x : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_104_unique_digits.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = unique_digits in\n  (assert ((candidate [15; 33; 1422; 1]) = [1; 15; 33]));\n  (assert ((candidate [152; 323; 1422; 10]) = []));\n  (assert ((candidate [12345; 2033; 111; 151]) = [111; 151]));\n  (assert ((candidate [135; 103; 31]) = [31; 135]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_105_by_length", "language": "ml", "prompt": "(**Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n * reverse the resulting array, and then replace each digit by its corresponding name from\n * \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n * For example:\n * If the array is empty, return an empty array:\n * If the array has any strange number ignore it:\n*)\nlet by_length (arr : int list) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_105_by_length.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = by_length in\n  (assert ((candidate [2; 1; 1; 4; 5; 8; 2; 3]) = [\"Eight\"; \"Five\"; \"Four\"; \"Three\"; \"Two\"; \"Two\"; \"One\"; \"One\"]));\n  (assert ((candidate []) = []));\n  (assert ((candidate [1; (~1); 55]) = [\"One\"]));\n  (assert ((candidate [1; (~1); 3; 2]) = [\"Three\"; \"Two\"; \"One\"]));\n  (assert ((candidate [9; 4; 8]) = [\"Nine\"; \"Eight\"; \"Four\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_106_f", "language": "ml", "prompt": "(**Implement the function f that takes n as a parameter,\n * and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n * or the sum of numbers from 1 to i otherwise.\n * i starts from 1.\n * the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n * Example:\n*)\nlet f (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_106_f.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = f in\n  (assert ((candidate 5) = [1; 2; 6; 24; 15]));\n  (assert ((candidate 7) = [1; 2; 6; 24; 15; 720; 28]));\n  (assert ((candidate 1) = [1]));\n  (assert ((candidate 3) = [1; 2; 6]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_107_even_odd_palindrome", "language": "ml", "prompt": "(**Given a positive integer n, return a tuple that has the number of even and odd\n * integer palindromes that fall within the range(1, n), inclusive.\n * Example 1:\n * Explanation:\n * Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n * Example 2:\n * Explanation:\n * Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n * Note:\n * 1. 1 <= n <= 10^3\n * 2. returned tuple has the number of even and odd integer palindromes respectively.\n*)\nlet even_odd_palindrome (n : int) :  int * int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_107_even_odd_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = even_odd_palindrome in\n  (assert ((candidate 123) = (8, 13)));\n  (assert ((candidate 12) = (4, 6)));\n  (assert ((candidate 3) = (1, 2)));\n  (assert ((candidate 63) = (6, 8)));\n  (assert ((candidate 25) = (5, 6)));\n  (assert ((candidate 19) = (4, 6)));\n  (assert ((candidate 9) = (4, 5)));\n  (assert ((candidate 1) = (0, 1)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_108_count_nums", "language": "ml", "prompt": "(**Write a function count_nums which takes an array of integers and returns\n * the number of elements which has a sum of digits > 0.\n * If a number is negative, then its first signed digit will be negative:\n * e.g. -123 has signed digits -1, 2, and 3.\n*)\nlet count_nums (arr : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_108_count_nums.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = count_nums in\n  (assert ((candidate []) = 0));\n  (assert ((candidate [(~1); (~2); 0]) = 0));\n  (assert ((candidate [1; 1; 2; (~2); 3; 4; 5]) = 6));\n  (assert ((candidate [1; 6; 9; (~6); 0; 1; 5]) = 5));\n  (assert ((candidate [1; 100; 98; (~7); 1; (~1)]) = 4));\n  (assert ((candidate [12; 23; 34; (~45); (~56); 0]) = 5));\n  (assert ((candidate [0; 1]) = 1));\n  (assert ((candidate [1]) = 1));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_109_move_one_ball", "language": "ml", "prompt": "(**We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n * numbers in the array will be randomly ordered. Your task is to determine if\n * it is possible to get an array sorted in non-decreasing order by performing \n * the following operation on the given array:\n * You are allowed to perform right shift operation any number of times.\n * One right shift operation means shifting all elements of the array by one\n * position in the right direction. The last element of the array will be moved to\n * the starting position in the array i.e. 0th index. \n * If it is possible to obtain the sorted array by performing the above operation\n * then return True else return False.\n * If the given array is empty then return True.\n * Note: The given list is guaranteed to have unique elements.\n * For Example:\n * Explanation: By performin 2 right shift operations, non-decreasing order can\n * be achieved for the given array.\n * Explanation:It is not possible to get non-decreasing order for the given\n * array by performing any number of right shift operations.\n*)\nlet move_one_ball (arr : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_109_move_one_ball.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = move_one_ball in\n  (assert ((candidate [3; 4; 5; 1; 2]) = true));\n  (assert ((candidate [3; 5; 10; 1; 2]) = true));\n  (assert ((candidate [4; 3; 1; 2]) = false));\n  (assert ((candidate [3; 5; 4; 1; 2]) = false));\n  (assert ((candidate []) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_10_make_palindrome", "language": "ml", "prompt": "(**Find the shortest palindrome that begins with a supplied string.\n * Algorithm idea is simple:\n * - Find the longest postfix of supplied string that is a palindrome.\n * - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n*)\nlet make_palindrome (string : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_10_make_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = make_palindrome in\n  (assert ((candidate \"\") = \"\"));\n  (assert ((candidate \"x\") = \"x\"));\n  (assert ((candidate \"xyz\") = \"xyzyx\"));\n  (assert ((candidate \"xyx\") = \"xyx\"));\n  (assert ((candidate \"jerry\") = \"jerryrrej\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_110_exchange", "language": "ml", "prompt": "(**In this problem, you will implement a function that takes two lists of numbers,\n * and determines whether it is possible to perform an exchange of elements\n * between them to make lst1 a list of only even numbers.\n * There is no limit on the number of exchanged elements between lst1 and lst2.\n * If it is possible to exchange elements between the lst1 and lst2 to make\n * all the elements of lst1 to be even, return \"YES\".\n * Otherwise, return \"NO\".\n * For example:\n * It is assumed that the input lists will be non-empty.\n*)\nlet exchange (lst1 : int list) (lst2 : int list) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_110_exchange.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = exchange in\n  (assert ((candidate [1; 2; 3; 4] [1; 2; 3; 4]) = \"YES\"));\n  (assert ((candidate [1; 2; 3; 4] [1; 5; 3; 4]) = \"NO\"));\n  (assert ((candidate [1; 2; 3; 4] [2; 1; 4; 3]) = \"YES\"));\n  (assert ((candidate [5; 7; 3] [2; 6; 4]) = \"YES\"));\n  (assert ((candidate [5; 7; 3] [2; 6; 3]) = \"NO\"));\n  (assert ((candidate [3; 2; 6; 1; 8; 9] [3; 5; 5; 1; 1; 1]) = \"NO\"));\n  (assert ((candidate [100; 200] [200; 200]) = \"YES\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_111_histogram", "language": "ml", "prompt": "(**Given a string representing a space separated lowercase letters, return a dictionary\n * of the letter with the most repetition and containing the corresponding count.\n * If several letters have the same occurrence, return all of them.\n * Example:\n*)\nlet histogram (test : string) : (string, int) list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_111_histogram.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = histogram in\n  (assert ((candidate \"a b b a\") = [(\"a\", 2); (\"b\", 2)]));\n  (assert ((candidate \"a b c a b\") = [(\"a\", 2); (\"b\", 2)]));\n  (assert ((candidate \"a b c d g\") = [(\"a\", 1); (\"b\", 1); (\"c\", 1); (\"d\", 1); (\"g\", 1)]));\n  (assert ((candidate \"r t g\") = [(\"r\", 1); (\"t\", 1); (\"g\", 1)]));\n  (assert ((candidate \"b b b b a\") = [(\"b\", 4)]));\n  (assert ((candidate \"r t g\") = [(\"r\", 1); (\"t\", 1); (\"g\", 1)]));\n  (assert ((candidate \"\") = []));\n  (assert ((candidate \"a\") = [(\"a\", 1)]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_112_reverse_delete", "language": "ml", "prompt": "(**Task\n * We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n * then check if the result string is palindrome.\n * A string is called palindrome if it reads the same backward as forward.\n * You should return a tuple containing the result string and True/False for the check.\n * Example\n*)\nlet reverse_delete (s : string) (c : string) :  string * bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_112_reverse_delete.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = reverse_delete in\n  (assert ((candidate \"abcde\" \"ae\") = (\"bcd\", false)));\n  (assert ((candidate \"abcdef\" \"b\") = (\"acdef\", false)));\n  (assert ((candidate \"abcdedcba\" \"ab\") = (\"cdedc\", true)));\n  (assert ((candidate \"dwik\" \"w\") = (\"dik\", false)));\n  (assert ((candidate \"a\" \"a\") = (\"\", true)));\n  (assert ((candidate \"abcdedcba\" \"\") = (\"abcdedcba\", true)));\n  (assert ((candidate \"abcdedcba\" \"v\") = (\"abcdedcba\", true)));\n  (assert ((candidate \"vabba\" \"v\") = (\"abba\", true)));\n  (assert ((candidate \"mamma\" \"mia\") = (\"\", true)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_113_odd_count", "language": "ml", "prompt": "(**Given a list of strings, where each string consists of only digits, return a list.\n * Each element i of the output should be \"the number of odd elements in the\n * string i of the input.\" where all the i's should be replaced by the number\n * of odd digits in the i'th string of the input.\n*)\nlet odd_count (lst : string list) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_113_odd_count.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = odd_count in\n  (assert ((candidate [\"1234567\"]) = [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]));\n  (assert ((candidate [\"3\"; \"11111111\"]) = [\"the number of odd elements 1n the str1ng 1 of the 1nput.\"; \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]));\n  (assert ((candidate [\"271\"; \"137\"; \"314\"]) = [\"the number of odd elements 2n the str2ng 2 of the 2nput.\"; \"the number of odd elements 3n the str3ng 3 of the 3nput.\"; \"the number of odd elements 2n the str2ng 2 of the 2nput.\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_114_minSubArraySum", "language": "ml", "prompt": "(**Given an array of integers nums, find the minimum sum of any non-empty sub-array\n * of nums.\n * Example\n*)\nlet minSubArraySum (nums : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_114_minSubArraySum.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = minSubArraySum in\n  (assert ((candidate [2; 3; 4; 1; 2; 4]) = 1));\n  (assert ((candidate [(~1); (~2); (~3)]) = (~6)));\n  (assert ((candidate [(~1); (~2); (~3); 2; (~10)]) = (~14)));\n  (assert ((candidate [(~9999999999999999)]) = (~9999999999999999)));\n  (assert ((candidate [0; 10; 20; 1000000]) = 0));\n  (assert ((candidate [(~1); (~2); (~3); 10; (~5)]) = (~6)));\n  (assert ((candidate [100; (~1); (~2); (~3); 10; (~5)]) = (~6)));\n  (assert ((candidate [10; 11; 13; 8; 3; 4]) = 3));\n  (assert ((candidate [100; (~33); 32; (~1); 0; (~2)]) = (~33)));\n  (assert ((candidate [(~10)]) = (~10)));\n  (assert ((candidate [7]) = 7));\n  (assert ((candidate [1; (~1)]) = (~1)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_115_max_fill", "language": "ml", "prompt": "(**You are given a rectangular grid of wells. Each row represents a single well,\n * and each 1 in a row represents a single unit of water.\n * Each well has a corresponding bucket that can be used to extract water from it, \n * and all buckets have the same capacity.\n * Your task is to use the buckets to empty the wells.\n * Output the number of times you need to lower the buckets.\n * Example 1:\n * Example 2:\n * Example 3:\n * Constraints:\n * * all wells have the same length\n * * 1 <= grid.length <= 10^2\n * * 1 <= grid[:,1].length <= 10^2\n * * grid[i][j] -> 0 | 1\n * * 1 <= capacity <= 10\n*)\nlet max_fill (grid : int list list) (capacity : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_115_max_fill.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = max_fill in\n  (assert ((candidate [[0; 0; 1; 0]; [0; 1; 0; 0]; [1; 1; 1; 1]] 1) = 6));\n  (assert ((candidate [[0; 0; 1; 1]; [0; 0; 0; 0]; [1; 1; 1; 1]; [0; 1; 1; 1]] 2) = 5));\n  (assert ((candidate [[0; 0; 0]; [0; 0; 0]] 5) = 0));\n  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 2) = 4));\n  (assert ((candidate [[1; 1; 1; 1]; [1; 1; 1; 1]] 9) = 2));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_116_sort_array", "language": "ml", "prompt": "(**In this Kata, you have to sort an array of non-negative integers according to\n * number of ones in their binary representation in ascending order.\n * For similar number of ones, sort based on decimal value.\n * It must be implemented like this:\n*)\nlet sort_array (arr : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_116_sort_array.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sort_array in\n  (assert ((candidate [1; 5; 2; 3; 4]) = [1; 2; 4; 3; 5]));\n  (assert ((candidate [(~2); (~3); (~4); (~5); (~6)]) = [(~4); (~2); (~6); (~5); (~3)]));\n  (assert ((candidate [1; 0; 2; 3; 4]) = [0; 1; 2; 4; 3]));\n  (assert ((candidate []) = []));\n  (assert ((candidate [2; 5; 77; 4; 5; 3; 5; 7; 2; 3; 4]) = [2; 2; 4; 4; 3; 3; 5; 5; 5; 7; 77]));\n  (assert ((candidate [3; 6; 44; 12; 32; 5]) = [32; 3; 5; 6; 12; 44]));\n  (assert ((candidate [2; 4; 8; 16; 32]) = [2; 4; 8; 16; 32]));\n  (assert ((candidate [2; 4; 8; 16; 32]) = [2; 4; 8; 16; 32]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_117_select_words", "language": "ml", "prompt": "(**Given a string s and a natural number n, you have been tasked to implement \n * a function that returns a list of all words from string s that contain exactly \n * n consonants, in order these words appear in the string s.\n * If the string s is empty then the function should return an empty list.\n * Note: you may assume the input string contains only letters and spaces.\n * Examples:\n*)\nlet select_words (s : string) (n : int) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_117_select_words.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = select_words in\n  (assert ((candidate \"Mary had a little lamb\" 4) = [\"little\"]));\n  (assert ((candidate \"Mary had a little lamb\" 3) = [\"Mary\"; \"lamb\"]));\n  (assert ((candidate \"simple white space\" 2) = []));\n  (assert ((candidate \"Hello world\" 4) = [\"world\"]));\n  (assert ((candidate \"Uncle sam\" 3) = [\"Uncle\"]));\n  (assert ((candidate \"\" 4) = []));\n  (assert ((candidate \"a b c d e f\" 1) = [\"b\"; \"c\"; \"d\"; \"f\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_118_get_closest_vowel", "language": "ml", "prompt": "(**You are given a word. Your task is to find the closest vowel that stands between \n * two consonants from the right side of the word (case sensitive).\n * Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n * find any vowel met the above condition. \n * You may assume that the given string contains English letter only.\n * Example:\n*)\nlet get_closest_vowel (word : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_118_get_closest_vowel.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = get_closest_vowel in\n  (assert ((candidate \"yogurt\") = \"u\"));\n  (assert ((candidate \"full\") = \"u\"));\n  (assert ((candidate \"easy\") = \"\"));\n  (assert ((candidate \"eAsy\") = \"\"));\n  (assert ((candidate \"ali\") = \"\"));\n  (assert ((candidate \"bad\") = \"a\"));\n  (assert ((candidate \"most\") = \"o\"));\n  (assert ((candidate \"ab\") = \"\"));\n  (assert ((candidate \"ba\") = \"\"));\n  (assert ((candidate \"quick\") = \"\"));\n  (assert ((candidate \"anime\") = \"i\"));\n  (assert ((candidate \"Asia\") = \"\"));\n  (assert ((candidate \"Above\") = \"o\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_119_match_parens", "language": "ml", "prompt": "(**You are given a list of two strings, both strings consist of open\n * parentheses '(' or close parentheses ')' only.\n * Your job is to check if it is possible to concatenate the two strings in\n * some order, that the resulting string will be good.\n * A string S is considered to be good if and only if all parentheses in S\n * are balanced. For example: the string '(())()' is good, while the string\n * '())' is not.\n * Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n * Examples:\n*)\nlet match_parens (lst : string list) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_119_match_parens.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = match_parens in\n  (assert ((candidate [\"()(\"; \")\"]) = \"Yes\"));\n  (assert ((candidate [\")\"; \")\"]) = \"No\"));\n  (assert ((candidate [\"(()(())\"; \"())())\"]) = \"No\"));\n  (assert ((candidate [\")())\"; \"(()()(\"]) = \"Yes\"));\n  (assert ((candidate [\"(())))\"; \"(()())((\"]) = \"Yes\"));\n  (assert ((candidate [\"()\"; \"())\"]) = \"No\"));\n  (assert ((candidate [\"(()(\"; \"()))()\"]) = \"Yes\"));\n  (assert ((candidate [\"((((\"; \"((())\"]) = \"No\"));\n  (assert ((candidate [\")(()\"; \"(()(\"]) = \"No\"));\n  (assert ((candidate [\")(\"; \")(\"]) = \"No\"));\n  (assert ((candidate [\"(\"; \")\"]) = \"Yes\"));\n  (assert ((candidate [\")\"; \"(\"]) = \"Yes\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_11_string_xor", "language": "ml", "prompt": "(**Input are two strings a and b consisting only of 1s and 0s.\n * Perform binary XOR on these inputs and return result also as a string.\n*)\nlet string_xor (a : string) (b : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_11_string_xor.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = string_xor in\n  (assert ((candidate \"111000\" \"101010\") = \"010010\"));\n  (assert ((candidate \"1\" \"1\") = \"0\"));\n  (assert ((candidate \"0101\" \"0000\") = \"0101\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_120_maximum", "language": "ml", "prompt": "(**Given an array arr of integers and a positive integer k, return a sorted list \n * of length k with the maximum k numbers in arr.\n * Example 1:\n * Example 2:\n * Example 3:\n * Note:\n * 1. The length of the array will be in the range of [1, 1000].\n * 2. The elements in the array will be in the range of [-1000, 1000].\n * 3. 0 <= k <= len(arr)\n*)\nlet maximum (arr : int list) (k : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_120_maximum.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = maximum in\n  (assert ((candidate [(~3); (~4); 5] 3) = [(~4); (~3); 5]));\n  (assert ((candidate [4; (~4); 4] 2) = [4; 4]));\n  (assert ((candidate [(~3); 2; 1; 2; (~1); (~2); 1] 1) = [2]));\n  (assert ((candidate [123; (~123); 20; 0; 1; 2; (~3)] 3) = [2; 20; 123]));\n  (assert ((candidate [(~123); 20; 0; 1; 2; (~3)] 4) = [0; 1; 2; 20]));\n  (assert ((candidate [5; 15; 0; 3; (~13); (~8); 0] 7) = [(~13); (~8); 0; 0; 3; 5; 15]));\n  (assert ((candidate [(~1); 0; 2; 5; 3; (~10)] 2) = [3; 5]));\n  (assert ((candidate [1; 0; 5; (~7)] 1) = [5]));\n  (assert ((candidate [4; (~4)] 2) = [(~4); 4]));\n  (assert ((candidate [(~10); 10] 2) = [(~10); 10]));\n  (assert ((candidate [1; 2; 3; (~23); 243; (~400); 0] 0) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_121_solution", "language": "ml", "prompt": "(**Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n * Examples\n*)\nlet solution (lst : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_121_solution.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = solution in\n  (assert ((candidate [5; 8; 7; 1]) = 12));\n  (assert ((candidate [3; 3; 3; 3; 3]) = 9));\n  (assert ((candidate [30; 13; 24; 321]) = 0));\n  (assert ((candidate [5; 9]) = 5));\n  (assert ((candidate [2; 4; 8]) = 0));\n  (assert ((candidate [30; 13; 23; 32]) = 23));\n  (assert ((candidate [3; 13; 2; 9]) = 3));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_122_add_elements", "language": "ml", "prompt": "(**Given a non-empty array of integers arr and an integer k, return\n * the sum of the elements with at most two digits from the first k elements of arr.\n * Example:\n * Constraints:\n * 1. 1 <= len(arr) <= 100\n * 2. 1 <= k <= len(arr)\n*)\nlet add_elements (arr : int list) (k : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_122_add_elements.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = add_elements in\n  (assert ((candidate [1; (~2); (~3); 41; 57; 76; 87; 88; 99] 3) = (~4)));\n  (assert ((candidate [111; 121; 3; 4000; 5; 6] 2) = 0));\n  (assert ((candidate [11; 21; 3; 90; 5; 6; 7; 8; 9] 4) = 125));\n  (assert ((candidate [111; 21; 3; 4000; 5; 6; 7; 8; 9] 4) = 24));\n  (assert ((candidate [1] 1) = 1));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_123_get_odd_collatz", "language": "ml", "prompt": "(**Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n * The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n * as follows: start with any positive integer n. Then each term is obtained from the \n * previous term as follows: if the previous term is even, the next term is one half of \n * the previous term. If the previous term is odd, the next term is 3 times the previous\n * term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n * Note: \n * 1. Collatz(1) is [1].\n * 2. returned list sorted in increasing order.\n * For example:\n * get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n*)\nlet get_odd_collatz (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_123_get_odd_collatz.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = get_odd_collatz in\n  (assert ((candidate 14) = [1; 5; 7; 11; 13; 17]));\n  (assert ((candidate 5) = [1; 5]));\n  (assert ((candidate 12) = [1; 3; 5]));\n  (assert ((candidate 1) = [1]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_124_valid_date", "language": "ml", "prompt": "(**You have to write a function which validates a given date string and\n * returns True if the date is valid otherwise False.\n * The date is valid if all of the following rules are satisfied:\n * 1. The date string is not empty.\n * 2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n * 3. The months should not be less than 1 or higher than 12.\n * 4. The date should be in the format: mm-dd-yyyy\n*)\nlet valid_date (date : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_124_valid_date.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = valid_date in\n  (assert ((candidate \"03-11-2000\") = true));\n  (assert ((candidate \"15-01-2012\") = false));\n  (assert ((candidate \"04-0-2040\") = false));\n  (assert ((candidate \"06-04-2020\") = true));\n  (assert ((candidate \"01-01-2007\") = true));\n  (assert ((candidate \"03-32-2011\") = false));\n  (assert ((candidate \"\") = false));\n  (assert ((candidate \"04-31-3000\") = false));\n  (assert ((candidate \"06-06-2005\") = true));\n  (assert ((candidate \"21-31-2000\") = false));\n  (assert ((candidate \"04-12-2003\") = true));\n  (assert ((candidate \"04122003\") = false));\n  (assert ((candidate \"20030412\") = false));\n  (assert ((candidate \"2003-04\") = false));\n  (assert ((candidate \"2003-04-12\") = false));\n  (assert ((candidate \"04-2003\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_126_is_sorted", "language": "ml", "prompt": "(**Given a list of numbers, return whether or not they are sorted\n * in ascending order. If list has more than 1 duplicate of the same\n * number, return False. Assume no negative numbers and only integers.\n * Examples\n*)\nlet is_sorted (lst : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_126_is_sorted.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_sorted in\n  (assert ((candidate [5]) = true));\n  (assert ((candidate [1; 2; 3; 4; 5]) = true));\n  (assert ((candidate [1; 3; 2; 4; 5]) = false));\n  (assert ((candidate [1; 2; 3; 4; 5; 6]) = true));\n  (assert ((candidate [1; 2; 3; 4; 5; 6; 7]) = true));\n  (assert ((candidate [1; 3; 2; 4; 5; 6; 7]) = false));\n  (assert ((candidate []) = true));\n  (assert ((candidate [1]) = true));\n  (assert ((candidate [3; 2; 1]) = false));\n  (assert ((candidate [1; 2; 2; 2; 3; 4]) = false));\n  (assert ((candidate [1; 2; 3; 3; 3; 4]) = false));\n  (assert ((candidate [1; 2; 2; 3; 3; 4]) = true));\n  (assert ((candidate [1; 2; 3; 4]) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_127_intersection", "language": "ml", "prompt": "(**You are given two intervals,\n * where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n * The given intervals are closed which means that the interval (start, end)\n * includes both start and end.\n * For each given interval, it is assumed that its start is less or equal its end.\n * Your task is to determine whether the length of intersection of these two \n * intervals is a prime number.\n * Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n * which its length is 1, which not a prime number.\n * If the length of the intersection is a prime number, return \"YES\",\n * otherwise, return \"NO\".\n * If the two intervals don't intersect, return \"NO\".\n * [input/output] samples:\n*)\nlet intersection (interval1 :  int * int) (interval2 :  int * int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_127_intersection.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = intersection in\n  (assert ((candidate (1, 2) (2, 3)) = \"NO\"));\n  (assert ((candidate ((~1), 1) (0, 4)) = \"NO\"));\n  (assert ((candidate ((~3), (~1)) ((~5), 5)) = \"YES\"));\n  (assert ((candidate ((~2), 2) ((~4), 0)) = \"YES\"));\n  (assert ((candidate ((~11), 2) ((~1), (~1))) = \"NO\"));\n  (assert ((candidate (1, 2) (3, 5)) = \"NO\"));\n  (assert ((candidate (1, 2) (1, 2)) = \"NO\"));\n  (assert ((candidate ((~2), (~2)) ((~3), (~2))) = \"NO\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_128_prod_signs", "language": "ml", "prompt": "(**You are given an array arr of integers and you need to return\n * sum of magnitudes of integers multiplied by product of all signs\n * of each number in the array, represented by 1, -1 or 0.\n * Note: return None for empty arr.\n * Example:\n*)\nlet prod_signs (arr : int list) : int option =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_128_prod_signs.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = prod_signs in\n  (assert ((candidate [1; 2; 2; (~4)]) = Some((~9))));\n  (assert ((candidate [0; 1]) = Some(0)));\n  (assert ((candidate [1; 1; 1; 2; 3; (~1); 1]) = Some((~10))));\n  (assert ((candidate []) = Some(None)));\n  (assert ((candidate [2; 4; 1; 2; (~1); (~1); 9]) = Some(20)));\n  (assert ((candidate [(~1); 1; (~1); 1]) = Some(4)));\n  (assert ((candidate [(~1); 1; 1; 1]) = Some((~4))));\n  (assert ((candidate [(~1); 1; 1; 0]) = Some(0)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_129_minPath", "language": "ml", "prompt": "(**Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n * each cell of the grid contains a value. Every integer in the range [1, N * N]\n * inclusive appears exactly once on the cells of the grid.\n * You have to find the minimum path of length k in the grid. You can start\n * from any cell, and in each step you can move to any of the neighbor cells,\n * in other words, you can go to cells which share an edge with you current\n * cell.\n * Please note that a path of length k means visiting exactly k cells (not\n * necessarily distinct).\n * You CANNOT go off the grid.\n * A path A (of length k) is considered less than a path B (of length k) if\n * after making the ordered lists of the values on the cells that A and B go\n * through (let's call them lst_A and lst_B), lst_A is lexicographically less\n * than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n * such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n * lst_A[j] = lst_B[j].\n * It is guaranteed that the answer is unique.\n * Return an ordered list of the values on the cells that the minimum path go through.\n * Examples:\n*)\nlet minPath (grid : int list list) (k : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_129_minPath.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = minPath in\n  (assert ((candidate [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3) = [1; 2; 1]));\n  (assert ((candidate [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1) = [1]));\n  (assert ((candidate [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]; [13; 14; 15; 16]] 4) = [1; 2; 1; 2]));\n  (assert ((candidate [[6; 4; 13; 10]; [5; 7; 12; 1]; [3; 16; 11; 15]; [8; 14; 9; 2]] 7) = [1; 10; 1; 10; 1; 10; 1]));\n  (assert ((candidate [[8; 14; 9; 2]; [6; 4; 13; 15]; [5; 7; 1; 12]; [3; 10; 11; 16]] 5) = [1; 7; 1; 7; 1]));\n  (assert ((candidate [[11; 8; 7; 2]; [5; 16; 14; 4]; [9; 3; 15; 6]; [12; 13; 10; 1]] 9) = [1; 6; 1; 6; 1; 6; 1; 6; 1]));\n  (assert ((candidate [[12; 13; 10; 1]; [9; 3; 15; 6]; [5; 16; 14; 4]; [11; 8; 7; 2]] 12) = [1; 6; 1; 6; 1; 6; 1; 6; 1; 6; 1; 6]));\n  (assert ((candidate [[2; 7; 4]; [3; 1; 5]; [6; 8; 9]] 8) = [1; 3; 1; 3; 1; 3; 1; 3]));\n  (assert ((candidate [[6; 1; 5]; [3; 8; 9]; [2; 7; 4]] 8) = [1; 5; 1; 5; 1; 5; 1; 5]));\n  (assert ((candidate [[1; 2]; [3; 4]] 10) = [1; 2; 1; 2; 1; 2; 1; 2; 1; 2]));\n  (assert ((candidate [[1; 3]; [3; 2]] 10) = [1; 3; 1; 3; 1; 3; 1; 3; 1; 3]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_12_longest", "language": "ml", "prompt": "(**Out of list of strings, return the longest one. Return the first one in case of multiple\n * strings of the same length. Return None in case the input list is empty.\n*)\nlet longest (strings : string list) : string option =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_12_longest.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = longest in\n  (assert ((candidate []) = Some(None)));\n  (assert ((candidate [\"x\"; \"y\"; \"z\"]) = Some(\"x\")));\n  (assert ((candidate [\"x\"; \"yyy\"; \"zzzz\"; \"www\"; \"kkkk\"; \"abc\"]) = Some(\"zzzz\")));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_130_tri", "language": "ml", "prompt": "(**Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n * the last couple centuries. However, what people don't know is Tribonacci sequence.\n * Tribonacci sequence is defined by the recurrence:\n * tri(1) = 3\n * tri(n) = 1 + n / 2, if n is even.\n * tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n * For example:\n * tri(2) = 1 + (2 / 2) = 2\n * tri(4) = 3\n * tri(3) = tri(2) + tri(1) + tri(4)\n * = 2 + 3 + 3 = 8 \n * You are given a non-negative integer number n, you have to a return a list of the \n * first n + 1 numbers of the Tribonacci sequence.\n * Examples:\n*)\nlet tri (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_130_tri.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = tri in\n  (assert ((candidate 3) = [1; 3; 2; 8]));\n  (assert ((candidate 4) = [1; 3; 2; 8; 3]));\n  (assert ((candidate 5) = [1; 3; 2; 8; 3; 15]));\n  (assert ((candidate 6) = [1; 3; 2; 8; 3; 15; 4]));\n  (assert ((candidate 7) = [1; 3; 2; 8; 3; 15; 4; 24]));\n  (assert ((candidate 8) = [1; 3; 2; 8; 3; 15; 4; 24; 5]));\n  (assert ((candidate 9) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35]));\n  (assert ((candidate 20) = [1; 3; 2; 8; 3; 15; 4; 24; 5; 35; 6; 48; 7; 63; 8; 80; 9; 99; 10; 120; 11]));\n  (assert ((candidate 0) = [1]));\n  (assert ((candidate 1) = [1; 3]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_131_digits", "language": "ml", "prompt": "(**Given a positive integer n, return the product of the odd digits.\n * Return 0 if all digits are even.\n * For example:\n*)\nlet digits (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_131_digits.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = digits in\n  (assert ((candidate 5) = 5));\n  (assert ((candidate 54) = 5));\n  (assert ((candidate 120) = 1));\n  (assert ((candidate 5014) = 5));\n  (assert ((candidate 98765) = 315));\n  (assert ((candidate 5576543) = 2625));\n  (assert ((candidate 2468) = 0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_132_is_nested", "language": "ml", "prompt": "(**Create a function that takes a string as input which contains only square brackets.\n * The function should return True if and only if there is a valid subsequence of brackets \n * where at least one bracket in the subsequence is nested.\n*)\nlet is_nested (string : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_132_is_nested.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_nested in\n  (assert ((candidate \"[[]]\") = true));\n  (assert ((candidate \"[]]]]]]][[[[[]\") = false));\n  (assert ((candidate \"[][]\") = false));\n  (assert ((candidate \"[]\") = false));\n  (assert ((candidate \"[[[[]]]]\") = true));\n  (assert ((candidate \"[]]]]]]]]]]\") = false));\n  (assert ((candidate \"[][][[]]\") = true));\n  (assert ((candidate \"[[]\") = false));\n  (assert ((candidate \"[]]\") = false));\n  (assert ((candidate \"[[]][[\") = true));\n  (assert ((candidate \"[[][]]\") = true));\n  (assert ((candidate \"\") = false));\n  (assert ((candidate \"[[[[[[[[\") = false));\n  (assert ((candidate \"]]]]]]]]\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_133_sum_squares", "language": "ml", "prompt": "(**You are given a list of numbers.\n * You need to return the sum of squared numbers in the given list,\n * round each element in the list to the upper int(Ceiling) first.\n * Examples:\n*)\nlet sum_squares (lst : float list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_133_sum_squares.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sum_squares in\n  (assert ((candidate [1.0; 2.0; 3.0]) = 14));\n  (assert ((candidate [1.0; 2.0; 3.0]) = 14));\n  (assert ((candidate [1.0; 3.0; 5.0; 7.0]) = 84));\n  (assert ((candidate [1.4; 4.2; 0.0]) = 29));\n  (assert ((candidate [-2.4; 1.0; 1.0]) = 6));\n  (assert ((candidate [100.0; 1.0; 15.0; 2.0]) = 10230));\n  (assert ((candidate [10000.0; 10000.0]) = 200000000));\n  (assert ((candidate [-1.4; 4.6; 6.3]) = 75));\n  (assert ((candidate [-1.4; 17.9; 18.9; 19.9]) = 1086));\n  (assert ((candidate [0.0]) = 0));\n  (assert ((candidate [-1.0]) = 1));\n  (assert ((candidate [-1.0; 1.0; 0.0]) = 2));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_134_check_if_last_char_is_a_letter", "language": "ml", "prompt": "(**Create a function that returns True if the last character\n * of a given string is an alphabetical character and is not\n * a part of a word, and False otherwise.\n * Note: \"word\" is a group of characters separated by space.\n * Examples:\n*)\nlet check_if_last_char_is_a_letter (txt : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_134_check_if_last_char_is_a_letter.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = check_if_last_char_is_a_letter in\n  (assert ((candidate \"apple\") = false));\n  (assert ((candidate \"apple pi e\") = true));\n  (assert ((candidate \"eeeee\") = false));\n  (assert ((candidate \"A\") = true));\n  (assert ((candidate \"Pumpkin pie \") = false));\n  (assert ((candidate \"Pumpkin pie 1\") = false));\n  (assert ((candidate \"\") = false));\n  (assert ((candidate \"eeeee e \") = false));\n  (assert ((candidate \"apple pie\") = false));\n  (assert ((candidate \"apple pi e \") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_135_can_arrange", "language": "ml", "prompt": "(**Create a function which returns the largest index of an element which\n * is not greater than or equal to the element immediately preceding it. If\n * no such element exists then return -1. The given array will not contain\n * duplicate values.\n * Examples:\n*)\nlet can_arrange (arr : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_135_can_arrange.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = can_arrange in\n  (assert ((candidate [1; 2; 4; 3; 5]) = 3));\n  (assert ((candidate [1; 2; 4; 5]) = (~1)));\n  (assert ((candidate [1; 4; 2; 5; 6; 7; 8; 9; 10]) = 2));\n  (assert ((candidate [4; 8; 5; 7; 3]) = 4));\n  (assert ((candidate []) = (~1)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_138_is_equal_to_sum_even", "language": "ml", "prompt": "(**Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n * Example\n*)\nlet is_equal_to_sum_even (n : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_138_is_equal_to_sum_even.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_equal_to_sum_even in\n  (assert ((candidate 4) = false));\n  (assert ((candidate 6) = false));\n  (assert ((candidate 8) = true));\n  (assert ((candidate 10) = true));\n  (assert ((candidate 11) = false));\n  (assert ((candidate 12) = true));\n  (assert ((candidate 13) = false));\n  (assert ((candidate 16) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_139_special_factorial", "language": "ml", "prompt": "(**The Brazilian factorial is defined as:\n * brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n * where n > 0\n * For example:\n * The function will receive an integer as input and should return the special\n * factorial of this integer.\n*)\nlet special_factorial (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_139_special_factorial.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = special_factorial in\n  (assert ((candidate 4) = 288));\n  (assert ((candidate 5) = 34560));\n  (assert ((candidate 7) = 125411328000));\n  (assert ((candidate 1) = 1));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_13_greatest_common_divisor", "language": "ml", "prompt": "(**Return a greatest common divisor of two integers a and b\n*)\nlet greatest_common_divisor (a : int) (b : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = greatest_common_divisor in\n  (assert ((candidate 3 7) = 1));\n  (assert ((candidate 10 15) = 5));\n  (assert ((candidate 49 14) = 7));\n  (assert ((candidate 144 60) = 12));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_140_fix_spaces", "language": "ml", "prompt": "(**Given a string text, replace all spaces in it with underscores, \n * and if a string has more than 2 consecutive spaces, \n * then replace all consecutive spaces with -\n*)\nlet fix_spaces (text : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_140_fix_spaces.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fix_spaces in\n  (assert ((candidate \"Example\") = \"Example\"));\n  (assert ((candidate \"Mudasir Hanif \") = \"Mudasir_Hanif_\"));\n  (assert ((candidate \"Yellow Yellow  Dirty  Fellow\") = \"Yellow_Yellow__Dirty__Fellow\"));\n  (assert ((candidate \"Exa   mple\") = \"Exa-mple\"));\n  (assert ((candidate \"   Exa 1 2 2 mple\") = \"-Exa_1_2_2_mple\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_141_file_name_check", "language": "ml", "prompt": "(**Create a function which takes a string representing a file's name, and returns\n * 'Yes' if the the file's name is valid, and returns 'No' otherwise.\n * A file's name is considered to be valid if and only if all the following conditions \n * are met:\n * - There should not be more than three digits ('0'-'9') in the file's name.\n * - The file's name contains exactly one dot '.'\n * - The substring before the dot should not be empty, and it starts with a letter from \n * the latin alphapet ('a'-'z' and 'A'-'Z').\n * - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n * Examples:\n*)\nlet file_name_check (file_name : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_141_file_name_check.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = file_name_check in\n  (assert ((candidate \"example.txt\") = \"Yes\"));\n  (assert ((candidate \"1example.dll\") = \"No\"));\n  (assert ((candidate \"s1sdf3.asd\") = \"No\"));\n  (assert ((candidate \"K.dll\") = \"Yes\"));\n  (assert ((candidate \"MY16FILE3.exe\") = \"Yes\"));\n  (assert ((candidate \"His12FILE94.exe\") = \"No\"));\n  (assert ((candidate \"_Y.txt\") = \"No\"));\n  (assert ((candidate \"?aREYA.exe\") = \"No\"));\n  (assert ((candidate \"/this_is_valid.dll\") = \"No\"));\n  (assert ((candidate \"this_is_valid.wow\") = \"No\"));\n  (assert ((candidate \"this_is_valid.txt\") = \"Yes\"));\n  (assert ((candidate \"this_is_valid.txtexe\") = \"No\"));\n  (assert ((candidate \"#this2_i4s_5valid.ten\") = \"No\"));\n  (assert ((candidate \"@this1_is6_valid.exe\") = \"No\"));\n  (assert ((candidate \"this_is_12valid.6exe4.txt\") = \"No\"));\n  (assert ((candidate \"all.exe.txt\") = \"No\"));\n  (assert ((candidate \"I563_No.exe\") = \"Yes\"));\n  (assert ((candidate \"Is3youfault.txt\") = \"Yes\"));\n  (assert ((candidate \"no_one#knows.dll\") = \"Yes\"));\n  (assert ((candidate \"1I563_Yes3.exe\") = \"No\"));\n  (assert ((candidate \"I563_Yes3.txtt\") = \"No\"));\n  (assert ((candidate \"final..txt\") = \"No\"));\n  (assert ((candidate \"final132\") = \"No\"));\n  (assert ((candidate \"_f4indsartal132.\") = \"No\"));\n  (assert ((candidate \".txt\") = \"No\"));\n  (assert ((candidate \"s.\") = \"No\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_142_sum_squares", "language": "ml", "prompt": "(**\"\n * This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n * multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n * change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n * Examples:\n*)\nlet sum_squares (lst : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_142_sum_squares.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sum_squares in\n  (assert ((candidate [1; 2; 3]) = 6));\n  (assert ((candidate [1; 4; 9]) = 14));\n  (assert ((candidate []) = 0));\n  (assert ((candidate [1; 1; 1; 1; 1; 1; 1; 1; 1]) = 9));\n  (assert ((candidate [(~1); (~1); (~1); (~1); (~1); (~1); (~1); (~1); (~1)]) = (~3)));\n  (assert ((candidate [0]) = 0));\n  (assert ((candidate [(~1); (~5); 2; (~1); (~5)]) = (~126)));\n  (assert ((candidate [(~56); (~99); 1; 0; (~2)]) = 3030));\n  (assert ((candidate [(~1); 0; 0; 0; 0; 0; 0; 0; (~1)]) = 0));\n  (assert ((candidate [(~16); (~9); (~2); 36; 36; 26; (~20); 25; (~40); 20; (~4); 12; (~26); 35; 37]) = (~14196)));\n  (assert ((candidate [(~1); (~3); 17; (~1); (~15); 13; (~1); 14; (~14); (~12); (~5); 14; (~14); 6; 13; 11; 16; 16; 4; 10]) = (~1448)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_143_words_in_sentence", "language": "ml", "prompt": "(**You are given a string representing a sentence,\n * the sentence contains some words separated by a space,\n * and you have to return a string that contains the words from the original sentence,\n * whose lengths are prime numbers,\n * the order of the words in the new string should be the same as the original one.\n * Example 1:\n * Example 2:\n * Constraints:\n * * 1 <= len(sentence) <= 100\n * * sentence contains only letters\n*)\nlet words_in_sentence (sentence : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_143_words_in_sentence.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = words_in_sentence in\n  (assert ((candidate \"This is a test\") = \"is\"));\n  (assert ((candidate \"lets go for swimming\") = \"go for\"));\n  (assert ((candidate \"there is no place available here\") = \"there is no place\"));\n  (assert ((candidate \"Hi I am Hussein\") = \"Hi am Hussein\"));\n  (assert ((candidate \"go for it\") = \"go for it\"));\n  (assert ((candidate \"here\") = \"\"));\n  (assert ((candidate \"here is\") = \"is\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_144_simplify", "language": "ml", "prompt": "(**Your task is to implement a function that will simplify the expression\n * x * n. The function returns True if x * n evaluates to a whole number and False\n * otherwise. Both x and n, are string representation of a fraction, and have the following format,\n * <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n * You can assume that x, and n are valid fractions, and do not have zero as denominator.\n*)\nlet simplify (x : string) (n : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_144_simplify.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = simplify in\n  (assert ((candidate \"1/5\" \"5/1\") = true));\n  (assert ((candidate \"1/6\" \"2/1\") = false));\n  (assert ((candidate \"5/1\" \"3/1\") = true));\n  (assert ((candidate \"7/10\" \"10/2\") = false));\n  (assert ((candidate \"2/10\" \"50/10\") = true));\n  (assert ((candidate \"7/2\" \"4/2\") = true));\n  (assert ((candidate \"11/6\" \"6/1\") = true));\n  (assert ((candidate \"2/3\" \"5/2\") = false));\n  (assert ((candidate \"5/2\" \"3/5\") = false));\n  (assert ((candidate \"2/4\" \"8/4\") = true));\n  (assert ((candidate \"2/4\" \"4/2\") = true));\n  (assert ((candidate \"1/5\" \"5/1\") = true));\n  (assert ((candidate \"1/5\" \"1/5\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_145_order_by_points", "language": "ml", "prompt": "(**Write a function which sorts the given list of integers\n * in ascending order according to the sum of their digits.\n * Note: if there are several items with similar sum of their digits,\n * order them based on their index in original list.\n * For example:\n*)\nlet order_by_points (nums : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_145_order_by_points.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = order_by_points in\n  (assert ((candidate [1; 11; (~1); (~11); (~12)]) = [(~1); (~11); 1; (~12); 11]));\n  (assert ((candidate [1234; 423; 463; 145; 2; 423; 423; 53; 6; 37; 3457; 3; 56; 0; 46]) = [0; 2; 3; 6; 53; 423; 423; 423; 1234; 145; 37; 46; 56; 463; 3457]));\n  (assert ((candidate []) = []));\n  (assert ((candidate [1; (~11); (~32); 43; 54; (~98); 2; (~3)]) = [(~3); (~32); (~98); (~11); 1; 2; 43; 54]));\n  (assert ((candidate [1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11]) = [1; 10; 2; 11; 3; 4; 5; 6; 7; 8; 9]));\n  (assert ((candidate [0; 6; 6; (~76); (~21); 23; 4]) = [(~76); (~21); 0; 4; 23; 6; 6]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_146_specialFilter", "language": "ml", "prompt": "(**Write a function that takes an array of numbers as input and returns \n * the number of elements in the array that are greater than 10 and both \n * first and last digits of a number are odd (1, 3, 5, 7, 9).\n * For example:\n*)\nlet specialFilter (nums : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_146_specialFilter.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = specialFilter in\n  (assert ((candidate [5; (~2); 1; (~5)]) = 0));\n  (assert ((candidate [15; (~73); 14; (~15)]) = 1));\n  (assert ((candidate [33; (~2); (~3); 45; 21; 109]) = 2));\n  (assert ((candidate [43; (~12); 93; 125; 121; 109]) = 4));\n  (assert ((candidate [71; (~2); (~33); 75; 21; 19]) = 3));\n  (assert ((candidate [1]) = 0));\n  (assert ((candidate []) = 0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_147_get_max_triples", "language": "ml", "prompt": "(**You are given a positive integer n. You have to create an integer array a of length n.\n * For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n * Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n * and a[i] + a[j] + a[k] is a multiple of 3.\n * Example :\n * Explanation: \n * a = [1, 3, 7, 13, 21]\n * The only valid triple is (1, 7, 13).\n*)\nlet get_max_triples (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_147_get_max_triples.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = get_max_triples in\n  (assert ((candidate 5) = 1));\n  (assert ((candidate 6) = 4));\n  (assert ((candidate 10) = 36));\n  (assert ((candidate 100) = 53361));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_149_sorted_list_sum", "language": "ml", "prompt": "(**Write a function that accepts a list of strings as a parameter,\n * deletes the strings that have odd lengths from it,\n * and returns the resulted list with a sorted order,\n * The list is always a list of strings and never an array of numbers,\n * and it may contain duplicates.\n * The order of the list should be ascending by length of each word, and you\n * should return the list sorted by that rule.\n * If two words have the same length, sort the list alphabetically.\n * The function should return a list of strings in sorted order.\n * You may assume that all words will have the same length.\n * For example:\n*)\nlet sorted_list_sum (lst : string list) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_149_sorted_list_sum.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sorted_list_sum in\n  (assert ((candidate [\"aa\"; \"a\"; \"aaa\"]) = [\"aa\"]));\n  (assert ((candidate [\"school\"; \"AI\"; \"asdf\"; \"b\"]) = [\"AI\"; \"asdf\"; \"school\"]));\n  (assert ((candidate [\"d\"; \"b\"; \"c\"; \"a\"]) = []));\n  (assert ((candidate [\"d\"; \"dcba\"; \"abcd\"; \"a\"]) = [\"abcd\"; \"dcba\"]));\n  (assert ((candidate [\"AI\"; \"ai\"; \"au\"]) = [\"AI\"; \"ai\"; \"au\"]));\n  (assert ((candidate [\"a\"; \"b\"; \"b\"; \"c\"; \"c\"; \"a\"]) = []));\n  (assert ((candidate [\"aaaa\"; \"bbbb\"; \"dd\"; \"cc\"]) = [\"cc\"; \"dd\"; \"aaaa\"; \"bbbb\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_14_all_prefixes", "language": "ml", "prompt": "(**Return list of all prefixes from shortest to longest of the input string\n*)\nlet all_prefixes (string : string) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_14_all_prefixes.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = all_prefixes in\n  (assert ((candidate \"\") = []));\n  (assert ((candidate \"asdfgh\") = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"]));\n  (assert ((candidate \"WWW\") = [\"W\"; \"WW\"; \"WWW\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_150_x_or_y", "language": "ml", "prompt": "(**A simple program which should return the value of x if n is \n * a prime number and should return the value of y otherwise.\n * Examples:\n*)\nlet x_or_y (n : int) (x : int) (y : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_150_x_or_y.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = x_or_y in\n  (assert ((candidate 7 34 12) = 34));\n  (assert ((candidate 15 8 5) = 5));\n  (assert ((candidate 3 33 5212) = 33));\n  (assert ((candidate 1259 3 52) = 3));\n  (assert ((candidate 7919 (~1) 12) = (~1)));\n  (assert ((candidate 3609 1245 583) = 583));\n  (assert ((candidate 91 56 129) = 129));\n  (assert ((candidate 6 34 1234) = 1234));\n  (assert ((candidate 1 2 0) = 0));\n  (assert ((candidate 2 2 0) = 2));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_151_double_the_difference", "language": "ml", "prompt": "(**Given a list of numbers, return the sum of squares of the numbers\n * in the list that are odd. Ignore numbers that are negative or not integers.\n * If the input list is empty, return 0.\n*)\nlet double_the_difference (lst : float list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_151_double_the_difference.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = double_the_difference in\n  (assert ((candidate [.0]) = 0));\n  (assert ((candidate [5.0; 4.0]) = 25));\n  (assert ((candidate [0.1; 0.2; 0.3]) = 0));\n  (assert ((candidate [-10.0; -20.0; -30.0]) = 0));\n  (assert ((candidate [-1.0; -2.0; 8.0]) = 0));\n  (assert ((candidate [0.2; 3.0; 5.0]) = 34));\n  (assert ((candidate [-9.0; -7.0; -5.0; -3.0; -1.0; 1.0; 3.0; 5.0; 7.0; 9.0]) = 165));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_152_compare", "language": "ml", "prompt": "(**I think we all remember that feeling when the result of some long-awaited\n * event is finally known. The feelings and thoughts you have at that moment are\n * definitely worth noting down and comparing.\n * Your task is to determine if a person correctly guessed the results of a number of matches.\n * You are given two arrays of scores and guesses of equal length, where each index shows a match. \n * Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n * the value is 0, and if not, the value is the absolute difference between the guess and the score.\n * example:\n*)\nlet compare (game : int list) (guess : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_152_compare.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = compare in\n  (assert ((candidate [1; 2; 3; 4; 5; 1] [1; 2; 3; 4; 2; (~2)]) = [0; 0; 0; 0; 3; 3]));\n  (assert ((candidate [0; 0; 0; 0; 0; 0] [0; 0; 0; 0; 0; 0]) = [0; 0; 0; 0; 0; 0]));\n  (assert ((candidate [1; 2; 3] [(~1); (~2); (~3)]) = [2; 4; 6]));\n  (assert ((candidate [1; 2; 3; 5] [(~1); 2; 3; 4]) = [2; 0; 0; 1]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_153_Strongest_Extension", "language": "ml", "prompt": "(**You will be given the name of a class (a string) and a list of extensions.\n * The extensions are to be used to load additional classes to the class. The\n * strength of the extension is as follows: Let CAP be the number of the uppercase\n * letters in the extension's name, and let SM be the number of lowercase letters \n * in the extension's name, the strength is given by the fraction CAP - SM. \n * You should find the strongest extension and return a string in this \n * format: ClassName.StrongestExtensionName.\n * If there are two or more extensions with the same strength, you should\n * choose the one that comes first in the list.\n * For example, if you are given \"Slices\" as the class and a list of the\n * extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n * return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n * (its strength is -1).\n * Example:\n*)\nlet Strongest_Extension (class_name : string) (extensions : string list) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_153_Strongest_Extension.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = Strongest_Extension in\n  (assert ((candidate \"Watashi\" [\"tEN\"; \"niNE\"; \"eIGHt8OKe\"]) = \"Watashi.eIGHt8OKe\"));\n  (assert ((candidate \"Boku123\" [\"nani\"; \"NazeDa\"; \"YEs.WeCaNe\"; \"32145tggg\"]) = \"Boku123.YEs.WeCaNe\"));\n  (assert ((candidate \"__YESIMHERE\" [\"t\"; \"eMptY\"; \"nothing\"; \"zeR00\"; \"NuLl__\"; \"123NoooneB321\"]) = \"__YESIMHERE.NuLl__\"));\n  (assert ((candidate \"K\" [\"Ta\"; \"TAR\"; \"t234An\"; \"cosSo\"]) = \"K.TAR\"));\n  (assert ((candidate \"__HAHA\" [\"Tab\"; \"123\"; \"781345\"; \"-_-\"]) = \"__HAHA.123\"));\n  (assert ((candidate \"YameRore\" [\"HhAas\"; \"okIWILL123\"; \"WorkOut\"; \"Fails\"; \"-_-\"]) = \"YameRore.okIWILL123\"));\n  (assert ((candidate \"finNNalLLly\" [\"Die\"; \"NowW\"; \"Wow\"; \"WoW\"]) = \"finNNalLLly.WoW\"));\n  (assert ((candidate \"_\" [\"Bb\"; \"91245\"]) = \"_.Bb\"));\n  (assert ((candidate \"Sp\" [\"671235\"; \"Bb\"]) = \"Sp.671235\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_154_cycpattern_check", "language": "ml", "prompt": "(**You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n*)\nlet cycpattern_check (a : string) (b : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_154_cycpattern_check.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = cycpattern_check in\n  (assert ((candidate \"xyzw\" \"xyw\") = false));\n  (assert ((candidate \"yello\" \"ell\") = true));\n  (assert ((candidate \"whattup\" \"ptut\") = false));\n  (assert ((candidate \"efef\" \"fee\") = true));\n  (assert ((candidate \"abab\" \"aabb\") = false));\n  (assert ((candidate \"winemtt\" \"tinem\") = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_155_even_odd_count", "language": "ml", "prompt": "(**Given an integer. return a tuple that has the number of even and odd digits respectively.\n * Example:\n*)\nlet even_odd_count (num : int) :  int * int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_155_even_odd_count.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = even_odd_count in\n  (assert ((candidate 7) = (0, 1)));\n  (assert ((candidate (~78)) = (1, 1)));\n  (assert ((candidate 3452) = (2, 2)));\n  (assert ((candidate 346211) = (3, 3)));\n  (assert ((candidate (~345821)) = (3, 3)));\n  (assert ((candidate (~2)) = (1, 0)));\n  (assert ((candidate (~45347)) = (2, 3)));\n  (assert ((candidate 0) = (1, 0)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_156_int_to_mini_roman", "language": "ml", "prompt": "(**Given a positive integer, obtain its roman numeral equivalent as a string,\n * and return it in lowercase.\n * Restrictions: 1 <= num <= 1000\n * Examples:\n*)\nlet int_to_mini_roman (number : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_156_int_to_mini_roman.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = int_to_mini_roman in\n  (assert ((candidate 19) = \"xix\"));\n  (assert ((candidate 152) = \"clii\"));\n  (assert ((candidate 251) = \"ccli\"));\n  (assert ((candidate 426) = \"cdxxvi\"));\n  (assert ((candidate 500) = \"d\"));\n  (assert ((candidate 1) = \"i\"));\n  (assert ((candidate 4) = \"iv\"));\n  (assert ((candidate 43) = \"xliii\"));\n  (assert ((candidate 90) = \"xc\"));\n  (assert ((candidate 94) = \"xciv\"));\n  (assert ((candidate 532) = \"dxxxii\"));\n  (assert ((candidate 900) = \"cm\"));\n  (assert ((candidate 994) = \"cmxciv\"));\n  (assert ((candidate 1000) = \"m\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_157_right_angle_triangle", "language": "ml", "prompt": "(**Given the lengths of the three sides of a triangle. Return True if the three\n * sides form a right-angled triangle, False otherwise.\n * A right-angled triangle is a triangle in which one angle is right angle or \n * 90 degree.\n * Example:\n*)\nlet right_angle_triangle (a : int) (b : int) (c : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_157_right_angle_triangle.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = right_angle_triangle in\n  (assert ((candidate 3 4 5) = true));\n  (assert ((candidate 1 2 3) = false));\n  (assert ((candidate 10 6 8) = true));\n  (assert ((candidate 2 2 2) = false));\n  (assert ((candidate 7 24 25) = true));\n  (assert ((candidate 10 5 7) = false));\n  (assert ((candidate 5 12 13) = true));\n  (assert ((candidate 15 8 17) = true));\n  (assert ((candidate 48 55 73) = true));\n  (assert ((candidate 1 1 1) = false));\n  (assert ((candidate 2 2 10) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_158_find_max", "language": "ml", "prompt": "(**Write a function that accepts a list of strings.\n * The list contains different words. Return the word with maximum number\n * of unique characters. If multiple strings have maximum number of unique\n * characters, return the one which comes first in lexicographical order.\n*)\nlet find_max (words : string list) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_158_find_max.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = find_max in\n  (assert ((candidate [\"name\"; \"of\"; \"string\"]) = \"string\"));\n  (assert ((candidate [\"name\"; \"enam\"; \"game\"]) = \"enam\"));\n  (assert ((candidate [\"aaaaaaa\"; \"bb\"; \"cc\"]) = \"aaaaaaa\"));\n  (assert ((candidate [\"abc\"; \"cba\"]) = \"abc\"));\n  (assert ((candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"]) = \"footbott\"));\n  (assert ((candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"]) = \"gonna\"));\n  (assert ((candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"]) = \"nation\"));\n  (assert ((candidate [\"this\"; \"is\"; \"a\"; \"prrk\"]) = \"this\"));\n  (assert ((candidate [\"b\"]) = \"b\"));\n  (assert ((candidate [\"play\"; \"play\"; \"play\"]) = \"play\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_159_eat", "language": "ml", "prompt": "(**You're a hungry rabbit, and you already have eaten a certain number of carrots,\n * but now you need to eat more carrots to complete the day's meals.\n * you should return an array of [ total number of eaten carrots after your meals,\n * the number of carrots left after your meals ]\n * if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n * Example:\n * Variables:\n * @number : integer\n * the number of carrots that you have eaten.\n * @need : integer\n * the number of carrots that you need to eat.\n * @remaining : integer\n * the number of remaining carrots thet exist in stock\n * Constrain:\n * * 0 <= number <= 1000\n * * 0 <= need <= 1000\n * * 0 <= remaining <= 1000\n * Have fun :)\n*)\nlet eat (number : int) (need : int) (remaining : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_159_eat.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = eat in\n  (assert ((candidate 5 6 10) = [11; 4]));\n  (assert ((candidate 4 8 9) = [12; 1]));\n  (assert ((candidate 1 10 10) = [11; 0]));\n  (assert ((candidate 2 11 5) = [7; 0]));\n  (assert ((candidate 4 5 7) = [9; 2]));\n  (assert ((candidate 4 5 1) = [5; 0]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_15_string_sequence", "language": "ml", "prompt": "(**Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n*)\nlet string_sequence (n : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_15_string_sequence.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = string_sequence in\n  (assert ((candidate 0) = \"0\"));\n  (assert ((candidate 3) = \"0 1 2 3\"));\n  (assert ((candidate 10) = \"0 1 2 3 4 5 6 7 8 9 10\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_161_solve", "language": "ml", "prompt": "(**You are given a string s.\n * if s[i] is a letter, reverse its case from lower to upper or vise versa, \n * otherwise keep it as it is.\n * If the string contains no letters, reverse the string.\n * The function should return the resulted string.\n * Examples\n*)\nlet solve (s : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_161_solve.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = solve in\n  (assert ((candidate \"AsDf\") = \"aSdF\"));\n  (assert ((candidate \"1234\") = \"4321\"));\n  (assert ((candidate \"ab\") = \"AB\"));\n  (assert ((candidate \"#a@C\") = \"#A@c\"));\n  (assert ((candidate \"#AsdfW^45\") = \"#aSDFw^45\"));\n  (assert ((candidate \"#6@2\") = \"2@6#\"));\n  (assert ((candidate \"#$a^D\") = \"#$A^d\"));\n  (assert ((candidate \"#ccc\") = \"#CCC\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_162_string_to_md5", "language": "ml", "prompt": "(**Given a string 'text', return its md5 hash equivalent string.\n * If 'text' is an empty string, return None.\n*)\nlet string_to_md5 (text : string) : string option =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_162_string_to_md5.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = string_to_md5 in\n  (assert ((candidate \"Hello world\") = Some(\"3e25960a79dbc69b674cd4ec67a72c62\")));\n  (assert ((candidate \"\") = Some(None)));\n  (assert ((candidate \"A B C\") = Some(\"0ef78513b0cb8cef12743f5aeb35f888\")));\n  (assert ((candidate \"password\") = Some(\"5f4dcc3b5aa765d61d8327deb882cf99\")));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_163_generate_integers", "language": "ml", "prompt": "(**Given two positive integers a and b, return the even digits between a\n * and b, in ascending order.\n * For example:\n*)\nlet generate_integers (a : int) (b : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_163_generate_integers.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = generate_integers in\n  (assert ((candidate 2 10) = [2; 4; 6; 8]));\n  (assert ((candidate 10 2) = [2; 4; 6; 8]));\n  (assert ((candidate 132 2) = [2; 4; 6; 8]));\n  (assert ((candidate 17 89) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_16_count_distinct_characters", "language": "ml", "prompt": "(**Given a string, find out how many distinct characters (regardless of case) does it consist of\n*)\nlet count_distinct_characters (string : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_16_count_distinct_characters.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = count_distinct_characters in\n  (assert ((candidate \"\") = 0));\n  (assert ((candidate \"abcde\") = 5));\n  (assert ((candidate \"abcdecadeCADE\") = 5));\n  (assert ((candidate \"aaaaAAAAaaaa\") = 1));\n  (assert ((candidate \"Jerry jERRY JeRRRY\") = 5));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_17_parse_music", "language": "ml", "prompt": "(**Input to this function is a string representing musical notes in a special ASCII format.\n * Your task is to parse this string and return list of integers corresponding to how many beats does each\n * not last.\n * Here is a legend:\n * 'o' - whole note, lasts four beats\n * 'o|' - half note, lasts two beats\n * '.|' - quater note, lasts one beat\n*)\nlet parse_music (music_string : string) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_17_parse_music.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = parse_music in\n  (assert ((candidate \"\") = []));\n  (assert ((candidate \"o o o o\") = [4; 4; 4; 4]));\n  (assert ((candidate \".| .| .| .|\") = [1; 1; 1; 1]));\n  (assert ((candidate \"o| o| .| .| o o o o\") = [2; 2; 1; 1; 4; 4; 4; 4]));\n  (assert ((candidate \"o| .| o| .| o o| o o|\") = [2; 1; 2; 1; 4; 2; 4; 2]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_18_how_many_times", "language": "ml", "prompt": "(**Find how many times a given substring can be found in the original string. Count overlaping cases.\n*)\nlet how_many_times (string : string) (substring : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_18_how_many_times.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = how_many_times in\n  (assert ((candidate \"\" \"x\") = 0));\n  (assert ((candidate \"xyxyxyx\" \"x\") = 4));\n  (assert ((candidate \"cacacacac\" \"cac\") = 4));\n  (assert ((candidate \"john doe\" \"john\") = 1));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_19_sort_numbers", "language": "ml", "prompt": "(**Input is a space-delimited string of numberals from 'zero' to 'nine'.\n * Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n * Return the string with numbers sorted from smallest to largest\n*)\nlet sort_numbers (numbers : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_19_sort_numbers.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sort_numbers in\n  (assert ((candidate \"\") = \"\"));\n  (assert ((candidate \"three\") = \"three\"));\n  (assert ((candidate \"three five nine\") = \"three five nine\"));\n  (assert ((candidate \"five zero four seven nine eight\") = \"zero four five seven eight nine\"));\n  (assert ((candidate \"six five four three two one zero\") = \"zero one two three four five six\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_1_separate_paren_groups", "language": "ml", "prompt": "(**Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n * separate those group into separate strings and return the list of those.\n * Separate groups are balanced (each open brace is properly closed) and not nested within each other\n * Ignore any spaces in the input string.\n*)\nlet separate_paren_groups (paren_string : string) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_1_separate_paren_groups.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = separate_paren_groups in\n  (assert ((candidate \"(()()) ((())) () ((())()())\") = [\"(()())\"; \"((()))\"; \"()\"; \"((())()())\"]));\n  (assert ((candidate \"() (()) ((())) (((())))\") = [\"()\"; \"(())\"; \"((()))\"; \"(((())))\"]));\n  (assert ((candidate \"(()(())((())))\") = [\"(()(())((())))\"]));\n  (assert ((candidate \"( ) (( )) (( )( ))\") = [\"()\"; \"(())\"; \"(()())\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_20_find_closest_elements", "language": "ml", "prompt": "(**From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n * other and return them in order (smaller number, larger number).\n*)\nlet find_closest_elements (numbers : float list) :  float * float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_20_find_closest_elements.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = find_closest_elements in\n  (assert ((candidate [1.0; 2.0; 3.9; 4.0; 5.0; 2.2]) = (3.9, 4.0)));\n  (assert ((candidate [1.0; 2.0; 5.9; 4.0; 5.0]) = (5.0, 5.9)));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0; 2.2]) = (2.0, 2.2)));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0; 2.0]) = (2.0, 2.0)));\n  (assert ((candidate [1.1; 2.2; 3.1; 4.1; 5.1]) = (2.2, 3.1)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_21_rescale_to_unit", "language": "ml", "prompt": "(**Given list of numbers (of at least two elements), apply a linear transform to that list,\n * such that the smallest number will become 0 and the largest will become 1\n*)\nlet rescale_to_unit (numbers : float list) : float list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_21_rescale_to_unit.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = rescale_to_unit in\n  (assert ((candidate [2.0; 49.9]) = [0.0; 1.0]));\n  (assert ((candidate [100.0; 49.9]) = [1.0; 0.0]));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = [0.0; 0.25; 0.5; 0.75; 1.0]));\n  (assert ((candidate [2.0; 1.0; 5.0; 3.0; 4.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));\n  (assert ((candidate [12.0; 11.0; 15.0; 13.0; 14.0]) = [0.25; 0.0; 1.0; 0.5; 0.75]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_23_strlen", "language": "ml", "prompt": "(**Return length of given string\n*)\nlet strlen (string : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_23_strlen.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = strlen in\n  (assert ((candidate \"\") = 0));\n  (assert ((candidate \"x\") = 1));\n  (assert ((candidate \"asdasnakj\") = 9));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_24_largest_divisor", "language": "ml", "prompt": "(**For a given number n, find the largest number that divides n evenly, smaller than n\n*)\nlet largest_divisor (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_24_largest_divisor.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = largest_divisor in\n  (assert ((candidate 3) = 1));\n  (assert ((candidate 7) = 1));\n  (assert ((candidate 10) = 5));\n  (assert ((candidate 100) = 50));\n  (assert ((candidate 49) = 7));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_25_factorize", "language": "ml", "prompt": "(**Return list of prime factors of given integer in the order from smallest to largest.\n * Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n * Input number should be equal to the product of all factors\n*)\nlet factorize (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_25_factorize.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = factorize in\n  (assert ((candidate 2) = [2]));\n  (assert ((candidate 4) = [2; 2]));\n  (assert ((candidate 8) = [2; 2; 2]));\n  (assert ((candidate 57) = [3; 19]));\n  (assert ((candidate 3249) = [3; 3; 19; 19]));\n  (assert ((candidate 185193) = [3; 3; 3; 19; 19; 19]));\n  (assert ((candidate 20577) = [3; 19; 19; 19]));\n  (assert ((candidate 18) = [2; 3; 3]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_26_remove_duplicates", "language": "ml", "prompt": "(**From a list of integers, remove all elements that occur more than once.\n * Keep order of elements left the same as in the input.\n*)\nlet remove_duplicates (numbers : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_26_remove_duplicates.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = remove_duplicates in\n  (assert ((candidate []) = []));\n  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));\n  (assert ((candidate [1; 2; 3; 2; 4; 3; 5]) = [1; 4; 5]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_27_flip_case", "language": "ml", "prompt": "(**For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n*)\nlet flip_case (string : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_27_flip_case.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = flip_case in\n  (assert ((candidate \"\") = \"\"));\n  (assert ((candidate \"Hello!\") = \"hELLO!\"));\n  (assert ((candidate \"These violent delights have violent ends\") = \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_28_concatenate", "language": "ml", "prompt": "(**Concatenate list of strings into a single string\n*)\nlet concatenate (strings : string list) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_28_concatenate.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = concatenate in\n  (assert ((candidate []) = \"\"));\n  (assert ((candidate [\"x\"; \"y\"; \"z\"]) = \"xyz\"));\n  (assert ((candidate [\"x\"; \"y\"; \"z\"; \"w\"; \"k\"]) = \"xyzwk\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_29_filter_by_prefix", "language": "ml", "prompt": "(**Filter an input list of strings only for ones that start with a given prefix.\n*)\nlet filter_by_prefix (strings : string list) (prefix : string) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_29_filter_by_prefix.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = filter_by_prefix in\n  (assert ((candidate [] \"john\") = []));\n  (assert ((candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\") = [\"xxx\"; \"xxxAAA\"; \"xxx\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_2_truncate_number", "language": "ml", "prompt": "(**Given a positive floating point number, it can be decomposed into\n * and integer part (largest integer smaller than given number) and decimals\n * (leftover part always smaller than 1).\n * Return the decimal part of the number.\n*)\nlet truncate_number (number : float) : float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_2_truncate_number.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = truncate_number in\n  (assert ((candidate 3.5) = 0.5));\n  (assert ((candidate 1.25) = 0.25));\n  (assert ((candidate 123.0) = 0.0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_30_get_positive", "language": "ml", "prompt": "(**Return only positive numbers in the list.\n*)\nlet get_positive (l : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_30_get_positive.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = get_positive in\n  (assert ((candidate [(~1); (~2); 4; 5; 6]) = [4; 5; 6]));\n  (assert ((candidate [5; 3; (~5); 2; 3; 3; 9; 0; 123; 1; (~10)]) = [5; 3; 2; 3; 3; 9; 123; 1]));\n  (assert ((candidate [(~1); (~2)]) = []));\n  (assert ((candidate []) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_31_is_prime", "language": "ml", "prompt": "(**Return true if a given number is prime, and false otherwise.\n*)\nlet is_prime (n : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_31_is_prime.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_prime in\n  (assert ((candidate 6) = false));\n  (assert ((candidate 101) = true));\n  (assert ((candidate 11) = true));\n  (assert ((candidate 13441) = true));\n  (assert ((candidate 61) = true));\n  (assert ((candidate 4) = false));\n  (assert ((candidate 1) = false));\n  (assert ((candidate 5) = true));\n  (assert ((candidate 11) = true));\n  (assert ((candidate 17) = true));\n  (assert ((candidate 85) = false));\n  (assert ((candidate 77) = false));\n  (assert ((candidate 255379) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_33_sort_third", "language": "ml", "prompt": "(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n * to the values of the corresponding indicies of l, but sorted.\n*)\nlet sort_third (l : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_33_sort_third.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sort_third in\n  (assert ((candidate [5; 6; 3; 4; 8; 9; 2]) = [2; 6; 3; 4; 8; 9; 5]));\n  (assert ((candidate [5; 8; 3; 4; 6; 9; 2]) = [2; 8; 3; 4; 6; 9; 5]));\n  (assert ((candidate [5; 6; 9; 4; 8; 3; 2]) = [2; 6; 9; 4; 8; 3; 5]));\n  (assert ((candidate [5; 6; 3; 4; 8; 9; 2; 1]) = [2; 6; 3; 4; 8; 9; 5; 1]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_34_unique", "language": "ml", "prompt": "(**Return sorted unique elements in a list\n*)\nlet unique (l : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_34_unique.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = unique in\n  (assert ((candidate [5; 3; 5; 2; 3; 3; 9; 0; 123]) = [0; 2; 3; 5; 9; 123]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_35_max_element", "language": "ml", "prompt": "(**Return maximum element in the list.\n*)\nlet max_element (l : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_35_max_element.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = max_element in\n  (assert ((candidate [1; 2; 3]) = 3));\n  (assert ((candidate [5; 3; (~5); 2; (~3); 3; 9; 0; 124; 1; (~10)]) = 124));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_36_fizz_buzz", "language": "ml", "prompt": "(**Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n*)\nlet fizz_buzz (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_36_fizz_buzz.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fizz_buzz in\n  (assert ((candidate 50) = 0));\n  (assert ((candidate 78) = 2));\n  (assert ((candidate 79) = 3));\n  (assert ((candidate 100) = 3));\n  (assert ((candidate 200) = 6));\n  (assert ((candidate 4000) = 192));\n  (assert ((candidate 10000) = 639));\n  (assert ((candidate 100000) = 8026));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_37_sort_even", "language": "ml", "prompt": "(**This function takes a list l and returns a list l' such that\n * l' is identical to l in the odd indicies, while its values at the even indicies are equal\n * to the values of the even indicies of l, but sorted.\n*)\nlet sort_even (l : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_37_sort_even.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sort_even in\n  (assert ((candidate [1; 2; 3]) = [1; 2; 3]));\n  (assert ((candidate [5; 3; (~5); 2; (~3); 3; 9; 0; 123; 1; (~10)]) = [(~10); 3; (~5); 2; (~3); 3; 5; 0; 9; 1; 123]));\n  (assert ((candidate [5; 8; (~12); 4; 23; 2; 3; 11; 12; (~10)]) = [(~12); 8; 3; 4; 5; 2; 12; 11; 23; (~10)]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_39_prime_fib", "language": "ml", "prompt": "(**prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n*)\nlet prime_fib (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_39_prime_fib.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = prime_fib in\n  (assert ((candidate 1) = 2));\n  (assert ((candidate 2) = 3));\n  (assert ((candidate 3) = 5));\n  (assert ((candidate 4) = 13));\n  (assert ((candidate 5) = 89));\n  (assert ((candidate 6) = 233));\n  (assert ((candidate 7) = 1597));\n  (assert ((candidate 8) = 28657));\n  (assert ((candidate 9) = 514229));\n  (assert ((candidate 10) = 433494437));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_3_below_zero", "language": "ml", "prompt": "(**You're given a list of deposit and withdrawal operations on a bank account that starts with\n * zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n * at that point function should return True. Otherwise it should return False.\n*)\nlet below_zero (operations : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_3_below_zero.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = below_zero in\n  (assert ((candidate []) = false));\n  (assert ((candidate [1; 2; (~3); 1; 2; (~3)]) = false));\n  (assert ((candidate [1; 2; (~4); 5; 6]) = true));\n  (assert ((candidate [1; (~1); 2; (~2); 5; (~5); 4; (~4)]) = false));\n  (assert ((candidate [1; (~1); 2; (~2); 5; (~5); 4; (~5)]) = true));\n  (assert ((candidate [1; (~2); 2; (~2); 5; (~5); 4; (~4)]) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_40_triples_sum_to_zero", "language": "ml", "prompt": "(**triples_sum_to_zero takes a list of integers as an input.\n * it returns True if there are three distinct elements in the list that\n * sum to zero, and False otherwise.\n*)\nlet triples_sum_to_zero (l : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_40_triples_sum_to_zero.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = triples_sum_to_zero in\n  (assert ((candidate [1; 3; 5; 0]) = false));\n  (assert ((candidate [1; 3; 5; (~1)]) = false));\n  (assert ((candidate [1; 3; (~2); 1]) = true));\n  (assert ((candidate [1; 2; 3; 7]) = false));\n  (assert ((candidate [1; 2; 5; 7]) = false));\n  (assert ((candidate [2; 4; (~5); 3; 9; 7]) = true));\n  (assert ((candidate [1]) = false));\n  (assert ((candidate [1; 3; 5; (~100)]) = false));\n  (assert ((candidate [100; 3; 5; (~100)]) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_42_incr_list", "language": "ml", "prompt": "(**Return list with elements incremented by 1.\n*)\nlet incr_list (l : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_42_incr_list.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = incr_list in\n  (assert ((candidate []) = []));\n  (assert ((candidate [3; 2; 1]) = [4; 3; 2]));\n  (assert ((candidate [5; 2; 5; 2; 3; 3; 9; 0; 123]) = [6; 3; 6; 3; 4; 4; 10; 1; 124]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_43_pairs_sum_to_zero", "language": "ml", "prompt": "(**pairs_sum_to_zero takes a list of integers as an input.\n * it returns True if there are two distinct elements in the list that\n * sum to zero, and False otherwise.\n*)\nlet pairs_sum_to_zero (l : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_43_pairs_sum_to_zero.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = pairs_sum_to_zero in\n  (assert ((candidate [1; 3; 5; 0]) = false));\n  (assert ((candidate [1; 3; (~2); 1]) = false));\n  (assert ((candidate [1; 2; 3; 7]) = false));\n  (assert ((candidate [2; 4; (~5); 3; 5; 7]) = true));\n  (assert ((candidate [1]) = false));\n  (assert ((candidate [(~3); 9; (~1); 3; 2; 30]) = true));\n  (assert ((candidate [(~3); 9; (~1); 3; 2; 31]) = true));\n  (assert ((candidate [(~3); 9; (~1); 4; 2; 30]) = false));\n  (assert ((candidate [(~3); 9; (~1); 4; 2; 31]) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_44_change_base", "language": "ml", "prompt": "(**Change numerical base of input number x to base.\n * return string representation after the conversion.\n * base numbers are less than 10.\n*)\nlet change_base (x : int) (base : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_44_change_base.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = change_base in\n  (assert ((candidate 8 3) = \"22\"));\n  (assert ((candidate 9 3) = \"100\"));\n  (assert ((candidate 234 2) = \"11101010\"));\n  (assert ((candidate 16 2) = \"10000\"));\n  (assert ((candidate 8 2) = \"1000\"));\n  (assert ((candidate 7 2) = \"111\"));\n  (assert ((candidate 2 3) = \"2\"));\n  (assert ((candidate 3 4) = \"3\"));\n  (assert ((candidate 4 5) = \"4\"));\n  (assert ((candidate 5 6) = \"5\"));\n  (assert ((candidate 6 7) = \"6\"));\n  (assert ((candidate 7 8) = \"7\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_45_triangle_area", "language": "ml", "prompt": "(**Given length of a side and high return area for a triangle.\n*)\nlet triangle_area (a : int) (h : int) : float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_45_triangle_area.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = triangle_area in\n  (assert ((candidate 5 3) = 7.5));\n  (assert ((candidate 2 2) = 2.0));\n  (assert ((candidate 10 8) = 40.0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_46_fib4", "language": "ml", "prompt": "(**The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fib4(0) -> 0\n * fib4(1) -> 0\n * fib4(2) -> 2\n * fib4(3) -> 0\n * fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n * Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n*)\nlet fib4 (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_46_fib4.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fib4 in\n  (assert ((candidate 5) = 4));\n  (assert ((candidate 8) = 28));\n  (assert ((candidate 10) = 104));\n  (assert ((candidate 12) = 386));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_47_median", "language": "ml", "prompt": "(**Return median of elements in the list l.\n*)\nlet median (l : int list) : float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_47_median.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = median in\n  (assert ((candidate [3; 1; 2; 4; 5]) = 3.0));\n  (assert ((candidate [(~10); 4; 6; 1000; 10; 20]) = 8.0));\n  (assert ((candidate [5]) = 5.0));\n  (assert ((candidate [6; 5]) = 5.5));\n  (assert ((candidate [8; 1; 3; 9; 9; 2; 7]) = 7.0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_48_is_palindrome", "language": "ml", "prompt": "(**Checks if given string is a palindrome\n*)\nlet is_palindrome (text : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_48_is_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_palindrome in\n  (assert ((candidate \"\") = true));\n  (assert ((candidate \"aba\") = true));\n  (assert ((candidate \"aaaaa\") = true));\n  (assert ((candidate \"zbcd\") = false));\n  (assert ((candidate \"xywyx\") = true));\n  (assert ((candidate \"xywyz\") = false));\n  (assert ((candidate \"xywzx\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_49_modp", "language": "ml", "prompt": "(**Return 2^n modulo p (be aware of numerics).\n*)\nlet modp (n : int) (p : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_49_modp.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = modp in\n  (assert ((candidate 3 5) = 3));\n  (assert ((candidate 1101 101) = 2));\n  (assert ((candidate 0 101) = 1));\n  (assert ((candidate 3 11) = 8));\n  (assert ((candidate 100 101) = 1));\n  (assert ((candidate 30 5) = 4));\n  (assert ((candidate 31 5) = 3));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_4_mean_absolute_deviation", "language": "ml", "prompt": "(**For a given list of input numbers, calculate Mean Absolute Deviation\n * around the mean of this dataset.\n * Mean Absolute Deviation is the average absolute difference between each\n * element and a centerpoint (mean in this case):\n * MAD = average | x - x_mean |\n*)\nlet mean_absolute_deviation (numbers : float list) : float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_4_mean_absolute_deviation.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = mean_absolute_deviation in\n  (assert ((candidate [1.0; 2.0]) = 0.5));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0]) = 1.0));\n  (assert ((candidate [1.0; 2.0; 3.0; 4.0; 5.0]) = 1.2));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_51_remove_vowels", "language": "ml", "prompt": "(**remove_vowels is a function that takes string and returns string without vowels.\n*)\nlet remove_vowels (text : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_51_remove_vowels.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = remove_vowels in\n  (assert ((candidate \"\") = \"\"));\n  (assert ((candidate \"abcdef\nghijklm\") = \"bcdf\nghjklm\"));\n  (assert ((candidate \"fedcba\") = \"fdcb\"));\n  (assert ((candidate \"eeeee\") = \"\"));\n  (assert ((candidate \"acBAA\") = \"cB\"));\n  (assert ((candidate \"EcBOO\") = \"cB\"));\n  (assert ((candidate \"ybcd\") = \"ybcd\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_52_below_threshold", "language": "ml", "prompt": "(**Return True if all numbers in the list l are below threshold t.\n*)\nlet below_threshold (l : int list) (t : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_52_below_threshold.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = below_threshold in\n  (assert ((candidate [1; 2; 4; 10] 100) = true));\n  (assert ((candidate [1; 20; 4; 10] 5) = false));\n  (assert ((candidate [1; 20; 4; 10] 21) = true));\n  (assert ((candidate [1; 20; 4; 10] 22) = true));\n  (assert ((candidate [1; 8; 4; 10] 11) = true));\n  (assert ((candidate [1; 8; 4; 10] 10) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_53_add", "language": "ml", "prompt": "(**Add two numbers x and y\n*)\nlet add (x : int) (y : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_53_add.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = add in\n  (assert ((candidate 0 1) = 1));\n  (assert ((candidate 1 0) = 1));\n  (assert ((candidate 2 3) = 5));\n  (assert ((candidate 5 7) = 12));\n  (assert ((candidate 7 5) = 12));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_54_same_chars", "language": "ml", "prompt": "(**Check if two words have the same characters.\n*)\nlet same_chars (s0 : string) (s1 : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_54_same_chars.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = same_chars in\n  (assert ((candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") = true));\n  (assert ((candidate \"abcd\" \"dddddddabc\") = true));\n  (assert ((candidate \"dddddddabc\" \"abcd\") = true));\n  (assert ((candidate \"eabcd\" \"dddddddabc\") = false));\n  (assert ((candidate \"abcd\" \"dddddddabcf\") = false));\n  (assert ((candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\") = false));\n  (assert ((candidate \"aabb\" \"aaccc\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_55_fib", "language": "ml", "prompt": "(**Return n-th Fibonacci number.\n*)\nlet fib (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_55_fib.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fib in\n  (assert ((candidate 10) = 55));\n  (assert ((candidate 1) = 1));\n  (assert ((candidate 8) = 21));\n  (assert ((candidate 11) = 89));\n  (assert ((candidate 12) = 144));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_56_correct_bracketing", "language": "ml", "prompt": "(**brackets is a string of \"<\" and \">\".\n * return True if every opening bracket has a corresponding closing bracket.\n*)\nlet correct_bracketing (brackets : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_56_correct_bracketing.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = correct_bracketing in\n  (assert ((candidate \"<>\") = true));\n  (assert ((candidate \"<<><>>\") = true));\n  (assert ((candidate \"<><><<><>><>\") = true));\n  (assert ((candidate \"<><><<<><><>><>><<><><<>>>\") = true));\n  (assert ((candidate \"<<<><>>>>\") = false));\n  (assert ((candidate \"><<>\") = false));\n  (assert ((candidate \"<\") = false));\n  (assert ((candidate \"<<<<\") = false));\n  (assert ((candidate \">\") = false));\n  (assert ((candidate \"<<>\") = false));\n  (assert ((candidate \"<><><<><>><>><<>\") = false));\n  (assert ((candidate \"<><><<><>><>>><>\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_57_monotonic", "language": "ml", "prompt": "(**Return True is list elements are monotonically increasing or decreasing.\n*)\nlet monotonic (l : int list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_57_monotonic.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = monotonic in\n  (assert ((candidate [1; 2; 4; 10]) = true));\n  (assert ((candidate [1; 2; 4; 20]) = true));\n  (assert ((candidate [1; 20; 4; 10]) = false));\n  (assert ((candidate [4; 1; 0; (~10)]) = true));\n  (assert ((candidate [4; 1; 1; 0]) = true));\n  (assert ((candidate [1; 2; 3; 2; 5; 60]) = false));\n  (assert ((candidate [1; 2; 3; 4; 5; 60]) = true));\n  (assert ((candidate [9; 9; 9; 9]) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_58_common", "language": "ml", "prompt": "(**Return sorted unique common elements for two lists.\n*)\nlet common (l1 : int list) (l2 : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_58_common.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = common in\n  (assert ((candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121]) = [1; 5; 653]));\n  (assert ((candidate [5; 3; 2; 8] [3; 2]) = [2; 3]));\n  (assert ((candidate [4; 3; 2; 8] [3; 2; 4]) = [2; 3; 4]));\n  (assert ((candidate [4; 3; 2; 8] []) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_59_largest_prime_factor", "language": "ml", "prompt": "(**Return the largest prime factor of n. Assume n > 1 and is not a prime.\n*)\nlet largest_prime_factor (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_59_largest_prime_factor.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = largest_prime_factor in\n  (assert ((candidate 15) = 5));\n  (assert ((candidate 27) = 3));\n  (assert ((candidate 63) = 7));\n  (assert ((candidate 330) = 11));\n  (assert ((candidate 13195) = 29));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_5_intersperse", "language": "ml", "prompt": "(**Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n*)\nlet intersperse (numbers : int list) (delimeter : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_5_intersperse.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = intersperse in\n  (assert ((candidate [] 7) = []));\n  (assert ((candidate [5; 6; 3; 2] 8) = [5; 8; 6; 8; 3; 8; 2]));\n  (assert ((candidate [2; 2; 2] 2) = [2; 2; 2; 2; 2]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_60_sum_to_n", "language": "ml", "prompt": "(**sum_to_n is a function that sums numbers from 1 to n.\n*)\nlet sum_to_n (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_60_sum_to_n.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sum_to_n in\n  (assert ((candidate 1) = 1));\n  (assert ((candidate 6) = 21));\n  (assert ((candidate 11) = 66));\n  (assert ((candidate 30) = 465));\n  (assert ((candidate 100) = 5050));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_61_correct_bracketing", "language": "ml", "prompt": "(**brackets is a string of \"(\" and \")\".\n * return True if every opening bracket has a corresponding closing bracket.\n*)\nlet correct_bracketing (brackets : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_61_correct_bracketing.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = correct_bracketing in\n  (assert ((candidate \"()\") = true));\n  (assert ((candidate \"(()())\") = true));\n  (assert ((candidate \"()()(()())()\") = true));\n  (assert ((candidate \"()()((()()())())(()()(()))\") = true));\n  (assert ((candidate \"((()())))\") = false));\n  (assert ((candidate \")(()\") = false));\n  (assert ((candidate \"(\") = false));\n  (assert ((candidate \"((((\") = false));\n  (assert ((candidate \")\") = false));\n  (assert ((candidate \"(()\") = false));\n  (assert ((candidate \"()()(()())())(()\") = false));\n  (assert ((candidate \"()()(()())()))()\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_62_derivative", "language": "ml", "prompt": "(**xs represent coefficients of a polynomial.\n * xs[0] + xs[1] * x + xs[2] * x^2 + ....\n * Return derivative of this polynomial in the same form.\n*)\nlet derivative (xs : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_62_derivative.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = derivative in\n  (assert ((candidate [3; 1; 2; 4; 5]) = [1; 4; 12; 20]));\n  (assert ((candidate [1; 2; 3]) = [2; 6]));\n  (assert ((candidate [3; 2; 1]) = [2; 2]));\n  (assert ((candidate [3; 2; 1; 0; 4]) = [2; 2; 0; 16]));\n  (assert ((candidate [1]) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_63_fibfib", "language": "ml", "prompt": "(**The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n * fibfib(0) == 0\n * fibfib(1) == 0\n * fibfib(2) == 1\n * fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n * Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n*)\nlet fibfib (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_63_fibfib.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fibfib in\n  (assert ((candidate 2) = 1));\n  (assert ((candidate 1) = 0));\n  (assert ((candidate 5) = 4));\n  (assert ((candidate 8) = 24));\n  (assert ((candidate 10) = 81));\n  (assert ((candidate 12) = 274));\n  (assert ((candidate 14) = 927));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_64_vowels_count", "language": "ml", "prompt": "(**Write a function vowels_count which takes a string representing\n * a word as input and returns the number of vowels in the string.\n * Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n * vowel, but only when it is at the end of the given word.\n * Example:\n*)\nlet vowels_count (s : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_64_vowels_count.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = vowels_count in\n  (assert ((candidate \"abcde\") = 2));\n  (assert ((candidate \"Alone\") = 3));\n  (assert ((candidate \"key\") = 2));\n  (assert ((candidate \"bye\") = 1));\n  (assert ((candidate \"keY\") = 2));\n  (assert ((candidate \"bYe\") = 1));\n  (assert ((candidate \"ACEDY\") = 3));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_65_circular_shift", "language": "ml", "prompt": "(**Circular shift the digits of the integer x, shift the digits right by shift\n * and return the result as a string.\n * If shift > number of digits, return digits reversed.\n*)\nlet circular_shift (x : int) (shift : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_65_circular_shift.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = circular_shift in\n  (assert ((candidate 100 2) = \"001\"));\n  (assert ((candidate 12 2) = \"12\"));\n  (assert ((candidate 97 8) = \"79\"));\n  (assert ((candidate 12 1) = \"21\"));\n  (assert ((candidate 11 101) = \"11\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_66_digitSum", "language": "ml", "prompt": "(**Task\n * Write a function that takes a string as input and returns the sum of the upper characters only'\n * ASCII codes.\n * Examples:\n*)\nlet digitSum (s : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_66_digitSum.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = digitSum in\n  (assert ((candidate \"\") = 0));\n  (assert ((candidate \"abAB\") = 131));\n  (assert ((candidate \"abcCd\") = 67));\n  (assert ((candidate \"helloE\") = 69));\n  (assert ((candidate \"woArBld\") = 131));\n  (assert ((candidate \"aAaaaXa\") = 153));\n  (assert ((candidate \" How are yOu?\") = 151));\n  (assert ((candidate \"You arE Very Smart\") = 327));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_67_fruit_distribution", "language": "ml", "prompt": "(**In this task, you will be given a string that represents a number of apples and oranges \n * that are distributed in a basket of fruit this basket contains \n * apples, oranges, and mango fruits. Given the string that represents the total number of \n * the oranges and apples and an integer that represent the total number of the fruits \n * in the basket return the number of the mango fruits in the basket.\n * for examble:\n*)\nlet fruit_distribution (s : string) (n : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_67_fruit_distribution.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = fruit_distribution in\n  (assert ((candidate \"5 apples and 6 oranges\" 19) = 8));\n  (assert ((candidate \"5 apples and 6 oranges\" 21) = 10));\n  (assert ((candidate \"0 apples and 1 oranges\" 3) = 2));\n  (assert ((candidate \"1 apples and 0 oranges\" 3) = 2));\n  (assert ((candidate \"2 apples and 3 oranges\" 100) = 95));\n  (assert ((candidate \"2 apples and 3 oranges\" 5) = 0));\n  (assert ((candidate \"1 apples and 100 oranges\" 120) = 19));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_68_pluck", "language": "ml", "prompt": "(**\"Given an array representing a branch of a tree that has non-negative integer nodes\n * your task is to pluck one of the nodes and return it.\n * The plucked node should be the node with the smallest even value.\n * If multiple nodes with the same smallest even value are found return the node that has smallest index.\n * The plucked node should be returned in a list, [ smalest_value, its index ],\n * If there are no even values or the given array is empty, return [].\n * Example 1:\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 2:\n * Explanation: 2 has the smallest even value, and 2 has the smallest index.\n * Example 3:\n * Example 4:\n * Explanation: 0 is the smallest value, but  there are two zeros,\n * so we will choose the first zero, which has the smallest index.\n * Constraints:\n * * 1 <= nodes.length <= 10000\n * * 0 <= node.value\n*)\nlet pluck (arr : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_68_pluck.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = pluck in\n  (assert ((candidate [4; 2; 3]) = [2; 1]));\n  (assert ((candidate [1; 2; 3]) = [2; 1]));\n  (assert ((candidate []) = []));\n  (assert ((candidate [5; 0; 3; 0; 4; 2]) = [0; 1]));\n  (assert ((candidate [1; 2; 3; 0; 5; 3]) = [0; 3]));\n  (assert ((candidate [5; 4; 8; 4; 8]) = [4; 1]));\n  (assert ((candidate [7; 6; 7; 1]) = [6; 1]));\n  (assert ((candidate [7; 9; 7; 1]) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_69_search", "language": "ml", "prompt": "(**You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n * zero, and has a frequency greater than or equal to the value of the integer itself. \n * The frequency of an integer is the number of times it appears in the list.\n * If no such a value exist, return -1.\n * Examples:\n*)\nlet search (lst : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_69_search.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = search in\n  (assert ((candidate [5; 5; 5; 5; 1]) = 1));\n  (assert ((candidate [4; 1; 4; 1; 4; 4]) = 4));\n  (assert ((candidate [3; 3]) = (~1)));\n  (assert ((candidate [8; 8; 8; 8; 8; 8; 8; 8]) = 8));\n  (assert ((candidate [2; 3; 3; 2; 2]) = 2));\n  (assert ((candidate [2; 7; 8; 8; 4; 8; 7; 3; 9; 6; 5; 10; 4; 3; 6; 7; 1; 7; 4; 10; 8; 1]) = 1));\n  (assert ((candidate [3; 2; 8; 2]) = 2));\n  (assert ((candidate [6; 7; 1; 8; 8; 10; 5; 8; 5; 3; 10]) = 1));\n  (assert ((candidate [8; 8; 3; 6; 5; 6; 4]) = (~1)));\n  (assert ((candidate [6; 9; 6; 7; 1; 4; 7; 1; 8; 8; 9; 8; 10; 10; 8; 4; 10; 4; 10; 1; 2; 9; 5; 7; 9]) = 1));\n  (assert ((candidate [1; 9; 10; 1; 3]) = 1));\n  (assert ((candidate [6; 9; 7; 5; 8; 7; 5; 3; 7; 5; 10; 10; 3; 6; 10; 2; 8; 6; 5; 4; 9; 5; 3; 10]) = 5));\n  (assert ((candidate [1]) = 1));\n  (assert ((candidate [8; 8; 10; 6; 4; 3; 5; 8; 2; 4; 2; 8; 4; 6; 10; 4; 2; 1; 10; 2; 1; 1; 5]) = 4));\n  (assert ((candidate [2; 10; 4; 8; 2; 10; 5; 1; 2; 9; 5; 5; 6; 3; 8; 6; 4; 10]) = 2));\n  (assert ((candidate [1; 6; 10; 1; 6; 9; 10; 8; 6; 8; 7; 3]) = 1));\n  (assert ((candidate [9; 2; 4; 1; 5; 1; 5; 2; 5; 7; 7; 7; 3; 10; 1; 5; 4; 2; 8; 4; 1; 9; 10; 7; 10; 2; 8; 10; 9; 4]) = 4));\n  (assert ((candidate [2; 6; 4; 2; 8; 7; 5; 6; 4; 10; 4; 6; 3; 7; 8; 8; 3; 1; 4; 2; 2; 10; 7]) = 4));\n  (assert ((candidate [9; 8; 6; 10; 2; 6; 10; 2; 7; 8; 10; 3; 8; 2; 6; 2; 3; 1]) = 2));\n  (assert ((candidate [5; 5; 3; 9; 5; 6; 3; 2; 8; 5; 6; 10; 10; 6; 8; 4; 10; 7; 7; 10; 8]) = (~1)));\n  (assert ((candidate [10]) = (~1)));\n  (assert ((candidate [9; 7; 7; 2; 4; 7; 2; 10; 9; 7; 5; 7; 2]) = 2));\n  (assert ((candidate [5; 4; 10; 2; 1; 1; 10; 3; 6; 1; 8]) = 1));\n  (assert ((candidate [7; 9; 9; 9; 3; 4; 1; 5; 9; 1; 2; 1; 1; 10; 7; 5; 6; 7; 6; 7; 7; 6]) = 1));\n  (assert ((candidate [3; 10; 10; 9; 2]) = (~1)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_6_parse_nested_parens", "language": "ml", "prompt": "(**Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n * For each of the group, output the deepest level of nesting of parentheses.\n * E.g. (()()) has maximum two levels of nesting while ((())) has three.\n*)\nlet parse_nested_parens (paren_string : string) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_6_parse_nested_parens.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = parse_nested_parens in\n  (assert ((candidate \"(()()) ((())) () ((())()())\") = [2; 3; 1; 3]));\n  (assert ((candidate \"() (()) ((())) (((())))\") = [1; 2; 3; 4]));\n  (assert ((candidate \"(()(())((())))\") = [4]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_70_strange_sort_list", "language": "ml", "prompt": "(**Given list of integers, return list in strange order.\n * Strange sorting, is when you start with the minimum value,\n * then maximum of the remaining integers, then minimum and so on.\n * Examples:\n*)\nlet strange_sort_list (lst : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_70_strange_sort_list.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = strange_sort_list in\n  (assert ((candidate [1; 2; 3; 4]) = [1; 4; 2; 3]));\n  (assert ((candidate [5; 6; 7; 8; 9]) = [5; 9; 6; 8; 7]));\n  (assert ((candidate [1; 2; 3; 4; 5]) = [1; 5; 2; 4; 3]));\n  (assert ((candidate [5; 6; 7; 8; 9; 1]) = [1; 9; 5; 8; 6; 7]));\n  (assert ((candidate [5; 5; 5; 5]) = [5; 5; 5; 5]));\n  (assert ((candidate []) = []));\n  (assert ((candidate [1; 2; 3; 4; 5; 6; 7; 8]) = [1; 8; 2; 7; 3; 6; 4; 5]));\n  (assert ((candidate [0; 2; 2; 2; 5; 5; (~5); (~5)]) = [(~5); 5; (~5); 5; 0; 2; 2; 2]));\n  (assert ((candidate [111111]) = [111111]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_71_triangle_area", "language": "ml", "prompt": "(**Given the lengths of the three sides of a triangle. Return the area of\n * the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n * Otherwise return -1\n * Three sides make a valid triangle when the sum of any two sides is greater \n * than the third side.\n * Example:\n*)\nlet triangle_area (a : int) (b : int) (c : int) : float =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_71_triangle_area.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = triangle_area in\n  (assert ((candidate 3 4 5) = 6.0));\n  (assert ((candidate 1 2 10) = (~1).0));\n  (assert ((candidate 4 8 5) = 8.18));\n  (assert ((candidate 2 2 2) = 1.73));\n  (assert ((candidate 1 2 3) = (~1).0));\n  (assert ((candidate 10 5 7) = 16.25));\n  (assert ((candidate 2 6 3) = (~1).0));\n  (assert ((candidate 1 1 1) = 0.43));\n  (assert ((candidate 2 2 10) = (~1).0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_72_will_it_fly", "language": "ml", "prompt": "(**Write a function that returns True if the object q will fly, and False otherwise.\n * The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n * Example:\n * # 1+2 is less than the maximum possible weight, but it's unbalanced.\n * # it's balanced, but 3+2+3 is more than the maximum possible weight.\n * # 3+2+3 is less than the maximum possible weight, and it's balanced.\n * # 3 is less than the maximum possible weight, and it's balanced.\n*)\nlet will_it_fly (q : int list) (w : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_72_will_it_fly.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = will_it_fly in\n  (assert ((candidate [3; 2; 3] 9) = true));\n  (assert ((candidate [1; 2] 5) = false));\n  (assert ((candidate [3] 5) = true));\n  (assert ((candidate [3; 2; 3] 1) = false));\n  (assert ((candidate [1; 2; 3] 6) = false));\n  (assert ((candidate [5] 5) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_73_smallest_change", "language": "ml", "prompt": "(**Given an array arr of integers, find the minimum number of elements that\n * need to be changed to make the array palindromic. A palindromic array is an array that\n * is read the same backwards and forwards. In one change, you can change one element to any other element.\n * For example:\n*)\nlet smallest_change (arr : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_73_smallest_change.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = smallest_change in\n  (assert ((candidate [1; 2; 3; 5; 4; 7; 9; 6]) = 4));\n  (assert ((candidate [1; 2; 3; 4; 3; 2; 2]) = 1));\n  (assert ((candidate [1; 4; 2]) = 1));\n  (assert ((candidate [1; 4; 4; 2]) = 1));\n  (assert ((candidate [1; 2; 3; 2; 1]) = 0));\n  (assert ((candidate [3; 1; 1; 3]) = 0));\n  (assert ((candidate [1]) = 0));\n  (assert ((candidate [0; 1]) = 1));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_74_total_match", "language": "ml", "prompt": "(**Write a function that accepts two lists of strings and returns the list that has \n * total number of chars in the all strings of the list less than the other list.\n * if the two lists have the same number of chars, return the first list.\n * Examples\n*)\nlet total_match (lst1 : string list) (lst2 : string list) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_74_total_match.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = total_match in\n  (assert ((candidate [] []) = []));\n  (assert ((candidate [\"hi\"; \"admin\"] [\"hi\"; \"hi\"]) = [\"hi\"; \"hi\"]));\n  (assert ((candidate [\"hi\"; \"admin\"] [\"hi\"; \"hi\"; \"admin\"; \"project\"]) = [\"hi\"; \"admin\"]));\n  (assert ((candidate [\"4\"] [\"1\"; \"2\"; \"3\"; \"4\"; \"5\"]) = [\"4\"]));\n  (assert ((candidate [\"hi\"; \"admin\"] [\"hI\"; \"Hi\"]) = [\"hI\"; \"Hi\"]));\n  (assert ((candidate [\"hi\"; \"admin\"] [\"hI\"; \"hi\"; \"hi\"]) = [\"hI\"; \"hi\"; \"hi\"]));\n  (assert ((candidate [\"hi\"; \"admin\"] [\"hI\"; \"hi\"; \"hii\"]) = [\"hi\"; \"admin\"]));\n  (assert ((candidate [] [\"this\"]) = []));\n  (assert ((candidate [\"this\"] []) = []));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_75_is_multiply_prime", "language": "ml", "prompt": "(**Write a function that returns true if the given number is the multiplication of 3 prime numbers\n * and false otherwise.\n * Knowing that (a) is less then 100. \n * Example:\n * 30 = 2 * 3 * 5\n*)\nlet is_multiply_prime (a : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_75_is_multiply_prime.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_multiply_prime in\n  (assert ((candidate 5) = false));\n  (assert ((candidate 30) = true));\n  (assert ((candidate 8) = true));\n  (assert ((candidate 10) = false));\n  (assert ((candidate 125) = true));\n  (assert ((candidate 105) = true));\n  (assert ((candidate 126) = false));\n  (assert ((candidate 729) = false));\n  (assert ((candidate 891) = false));\n  (assert ((candidate 1001) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_76_is_simple_power", "language": "ml", "prompt": "(**Your task is to write a function that returns true if a number x is a simple\n * power of n and false in other cases.\n * x is a simple power of n if n**int=x\n * For example:\n*)\nlet is_simple_power (x : int) (n : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_76_is_simple_power.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_simple_power in\n  (assert ((candidate 16 2) = true));\n  (assert ((candidate 143214 16) = false));\n  (assert ((candidate 4 2) = true));\n  (assert ((candidate 9 3) = true));\n  (assert ((candidate 16 4) = true));\n  (assert ((candidate 24 2) = false));\n  (assert ((candidate 128 4) = false));\n  (assert ((candidate 12 6) = false));\n  (assert ((candidate 1 1) = true));\n  (assert ((candidate 1 12) = true));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_77_iscube", "language": "ml", "prompt": "(**Write a function that takes an integer a and returns True \n * if this ingeger is a cube of some integer number.\n * Note: you may assume the input is always valid.\n * Examples:\n*)\nlet iscube (a : int) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_77_iscube.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = iscube in\n  (assert ((candidate 1) = true));\n  (assert ((candidate 2) = false));\n  (assert ((candidate (~1)) = true));\n  (assert ((candidate 64) = true));\n  (assert ((candidate 180) = false));\n  (assert ((candidate 1000) = true));\n  (assert ((candidate 0) = true));\n  (assert ((candidate 1729) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_78_hex_key", "language": "ml", "prompt": "(**You have been tasked to write a function that receives \n * a hexadecimal number as a string and counts the number of hexadecimal \n * digits that are primes (prime number, or a prime, is a natural number \n * greater than 1 that is not a product of two smaller natural numbers).\n * Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n * Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n * So you have to determine a number of the following digits: 2, 3, 5, 7, \n * B (=decimal 11), D (=decimal 13).\n * Note: you may assume the input is always correct or empty string, \n * and symbols A,B,C,D,E,F are always uppercase.\n * Examples:\n*)\nlet hex_key (num : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_78_hex_key.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = hex_key in\n  (assert ((candidate \"AB\") = 1));\n  (assert ((candidate \"1077E\") = 2));\n  (assert ((candidate \"ABED1A33\") = 4));\n  (assert ((candidate \"2020\") = 2));\n  (assert ((candidate \"123456789ABCDEF0\") = 6));\n  (assert ((candidate \"112233445566778899AABBCCDDEEFF00\") = 12));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_79_decimal_to_binary", "language": "ml", "prompt": "(**You will be given a number in decimal form and your task is to convert it to\n * binary format. The function should return a string, with each character representing a binary\n * number. Each character in the string will be '0' or '1'.\n * There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n * The extra characters are there to help with the format.\n * Examples:\n*)\nlet decimal_to_binary (decimal : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_79_decimal_to_binary.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = decimal_to_binary in\n  (assert ((candidate 0) = \"db0db\"));\n  (assert ((candidate 32) = \"db100000db\"));\n  (assert ((candidate 103) = \"db1100111db\"));\n  (assert ((candidate 15) = \"db1111db\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_7_filter_by_substring", "language": "ml", "prompt": "(**Filter an input list of strings only for ones that contain given substring\n*)\nlet filter_by_substring (strings : string list) (substring : string) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_7_filter_by_substring.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = filter_by_substring in\n  (assert ((candidate [] \"john\") = []));\n  (assert ((candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\") = [\"xxx\"; \"xxxAAA\"; \"xxx\"]));\n  (assert ((candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\") = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"]));\n  (assert ((candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\") = [\"grunt\"; \"prune\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_80_is_happy", "language": "ml", "prompt": "(**You are given a string s.\n * Your task is to check if the string is happy or not.\n * A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n * For example:\n*)\nlet is_happy (s : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_80_is_happy.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_happy in\n  (assert ((candidate \"a\") = false));\n  (assert ((candidate \"aa\") = false));\n  (assert ((candidate \"abcd\") = true));\n  (assert ((candidate \"aabb\") = false));\n  (assert ((candidate \"adb\") = true));\n  (assert ((candidate \"xyy\") = false));\n  (assert ((candidate \"iopaxpoi\") = true));\n  (assert ((candidate \"iopaxioi\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_81_numerical_letter_grade", "language": "ml", "prompt": "(**It is the last week of the semester and the teacher has to give the grades\n * to students. The teacher has been making her own algorithm for grading.\n * The only problem is, she has lost the code she used for grading.\n * She has given you a list of GPAs for some students and you have to write \n * a function that can output a list of letter grades using the following table:\n * GPA       |    Letter grade\n * 4.0                A+\n * > 3.7                A \n * > 3.3                A- \n * > 3.0                B+\n * > 2.7                B \n * > 2.3                B-\n * > 2.0                C+\n * > 1.7                C\n * > 1.3                C-\n * > 1.0                D+ \n * > 0.7                D \n * > 0.0                D-\n * 0.0                E\n * Example:\n*)\nlet numerical_letter_grade (grades : float list) : string list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = numerical_letter_grade in\n  (assert ((candidate [4.0; 3.0; 1.7; 2.0; 3.5]) = [\"A+\"; \"B\"; \"C-\"; \"C\"; \"A-\"]));\n  (assert ((candidate [1.2]) = [\"D+\"]));\n  (assert ((candidate [0.5]) = [\"D-\"]));\n  (assert ((candidate [0.0]) = [\"E\"]));\n  (assert ((candidate [1.0; 0.3; 1.5; 2.8; 3.3]) = [\"D\"; \"D-\"; \"C-\"; \"B\"; \"B+\"]));\n  (assert ((candidate [0.0; 0.7]) = [\"E\"; \"D-\"]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_82_prime_length", "language": "ml", "prompt": "(**Write a function that takes a string and returns True if the string\n * length is a prime number or False otherwise\n * Examples\n*)\nlet prime_length (string : string) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_82_prime_length.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = prime_length in\n  (assert ((candidate \"Hello\") = true));\n  (assert ((candidate \"abcdcba\") = true));\n  (assert ((candidate \"kittens\") = true));\n  (assert ((candidate \"orange\") = false));\n  (assert ((candidate \"wow\") = true));\n  (assert ((candidate \"world\") = true));\n  (assert ((candidate \"MadaM\") = true));\n  (assert ((candidate \"Wow\") = true));\n  (assert ((candidate \"\") = false));\n  (assert ((candidate \"HI\") = true));\n  (assert ((candidate \"go\") = true));\n  (assert ((candidate \"gogo\") = false));\n  (assert ((candidate \"aaaaaaaaaaaaaaa\") = false));\n  (assert ((candidate \"Madam\") = true));\n  (assert ((candidate \"M\") = false));\n  (assert ((candidate \"0\") = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_84_solve", "language": "ml", "prompt": "(**Given a positive integer N, return the total sum of its digits in binary.\n * Example\n * Variables:\n * @N integer\n * Constraints: 0 \u2264 N \u2264 10000.\n * Output:\n * a string of binary number\n*)\nlet solve (N : int) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_84_solve.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = solve in\n  (assert ((candidate 1000) = \"1\"));\n  (assert ((candidate 150) = \"110\"));\n  (assert ((candidate 147) = \"1100\"));\n  (assert ((candidate 333) = \"1001\"));\n  (assert ((candidate 963) = \"10010\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_85_add", "language": "ml", "prompt": "(**Given a non-empty list of integers lst. add the even elements that are at odd indices..\n * Examples:\n*)\nlet add (lst : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_85_add.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = add in\n  (assert ((candidate [4; 88]) = 88));\n  (assert ((candidate [4; 5; 6; 7; 2; 122]) = 122));\n  (assert ((candidate [4; 0; 6; 7]) = 0));\n  (assert ((candidate [4; 4; 6; 8]) = 12));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_86_anti_shuffle", "language": "ml", "prompt": "(**Write a function that takes a string and returns an ordered version of it.\n * Ordered version of string, is a string where all words (separated by space)\n * are replaced by a new word where all the characters arranged in\n * ascending order based on ascii value.\n * Note: You should keep the order of words and blank spaces in the sentence.\n * For example:\n*)\nlet anti_shuffle (s : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_86_anti_shuffle.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = anti_shuffle in\n  (assert ((candidate \"Hi\") = \"Hi\"));\n  (assert ((candidate \"hello\") = \"ehllo\"));\n  (assert ((candidate \"number\") = \"bemnru\"));\n  (assert ((candidate \"abcd\") = \"abcd\"));\n  (assert ((candidate \"Hello World!!!\") = \"Hello !!!Wdlor\"));\n  (assert ((candidate \"\") = \"\"));\n  (assert ((candidate \"Hi. My name is Mister Robot. How are you?\") = \".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_87_get_row", "language": "ml", "prompt": "(**You are given a 2 dimensional data, as a nested lists,\n * which is similar to matrix, however, unlike matrices,\n * each row may contain a different number of columns.\n * Given lst, and integer x, find integers x in the list,\n * and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n * each tuple is a coordinate - (row, columns), starting with 0.\n * Sort coordinates initially by rows in ascending order.\n * Also, sort coordinates of the row by columns in descending order.\n * Examples:\n*)\nlet get_row (lst : int list list) (x : int) :  int * int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_87_get_row.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = get_row in\n  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)]));\n  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2) = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)]));\n  (assert ((candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1) = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)]));\n  (assert ((candidate [] 1) = []));\n  (assert ((candidate [[1]] 2) = []));\n  (assert ((candidate [[]; [1]; [1; 2; 3]] 3) = [(2, 2)]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_88_sort_array", "language": "ml", "prompt": "(**Given an array of non-negative integers, return a copy of the given array after sorting,\n * you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n * or sort it in descending order if the sum( first index value, last index value) is even.\n * Note:\n * * don't change the given array.\n * Examples:\n*)\nlet sort_array (array : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_88_sort_array.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sort_array in\n  (assert ((candidate []) = []));\n  (assert ((candidate [5]) = [5]));\n  (assert ((candidate [2; 4; 3; 0; 1; 5]) = [0; 1; 2; 3; 4; 5]));\n  (assert ((candidate [2; 4; 3; 0; 1; 5; 6]) = [6; 5; 4; 3; 2; 1; 0]));\n  (assert ((candidate [2; 1]) = [1; 2]));\n  (assert ((candidate [15; 42; 87; 32; 11; 0]) = [0; 11; 15; 32; 42; 87]));\n  (assert ((candidate [21; 14; 23; 11]) = [23; 21; 14; 11]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_89_encrypt", "language": "ml", "prompt": "(**Create a function encrypt that takes a string as an argument and\n * returns a string encrypted with the alphabet being rotated. \n * The alphabet should be rotated in a manner such that the letters \n * shift down by two multiplied to two places.\n * For example:\n*)\nlet encrypt (s : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_89_encrypt.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = encrypt in\n  (assert ((candidate \"hi\") = \"lm\"));\n  (assert ((candidate \"asdfghjkl\") = \"ewhjklnop\"));\n  (assert ((candidate \"gf\") = \"kj\"));\n  (assert ((candidate \"et\") = \"ix\"));\n  (assert ((candidate \"faewfawefaewg\") = \"jeiajeaijeiak\"));\n  (assert ((candidate \"hellomyfriend\") = \"lippsqcjvmirh\"));\n  (assert ((candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\") = \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n  (assert ((candidate \"a\") = \"e\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_8_sum_product", "language": "ml", "prompt": "(**For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n * Empty sum should be equal to 0 and empty product should be equal to 1.\n*)\nlet sum_product (numbers : int list) :  int * int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_8_sum_product.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = sum_product in\n  (assert ((candidate []) = (0, 1)));\n  (assert ((candidate [1; 1; 1]) = (3, 1)));\n  (assert ((candidate [100; 0]) = (100, 0)));\n  (assert ((candidate [3; 5; 7]) = (15, 105)));\n  (assert ((candidate [10]) = (10, 10)));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_90_next_smallest", "language": "ml", "prompt": "(**You are given a list of integers.\n * Write a function next_smallest() that returns the 2nd smallest element of the list.\n * Return None if there is no such element.\n*)\nlet next_smallest (lst : int list) : int option =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_90_next_smallest.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = next_smallest in\n  (assert ((candidate [1; 2; 3; 4; 5]) = Some(2)));\n  (assert ((candidate [5; 1; 4; 3; 2]) = Some(2)));\n  (assert ((candidate []) = Some(None)));\n  (assert ((candidate [1; 1]) = Some(None)));\n  (assert ((candidate [1; 1; 1; 1; 0]) = Some(1)));\n  (assert ((candidate [1; 1]) = Some(None)));\n  (assert ((candidate [(~35); 34; 12; (~45)]) = Some((~35))));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_91_is_bored", "language": "ml", "prompt": "(**You'll be given a string of words, and your task is to count the number\n * of boredoms. A boredom is a sentence that starts with the word \"I\".\n * Sentences are delimited by '.', '?' or '!'.\n * For example:\n*)\nlet is_bored (S : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_91_is_bored.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = is_bored in\n  (assert ((candidate \"Hello world\") = 0));\n  (assert ((candidate \"Is the sky blue?\") = 0));\n  (assert ((candidate \"I love It !\") = 1));\n  (assert ((candidate \"bIt\") = 0));\n  (assert ((candidate \"I feel good today. I will be productive. will kill It\") = 2));\n  (assert ((candidate \"You and I are going for a walk\") = 0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_92_any_int", "language": "ml", "prompt": "(**Create a function that takes 3 numbers.\n * Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n * Returns false in any other cases.\n * Examples\n*)\nlet any_int (x : float) (y : float) (z : float) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_92_any_int.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = any_int in\n  (assert ((candidate 2.0 3.0 1.0) = true));\n  (assert ((candidate 2.5 2.0 3.0) = false));\n  (assert ((candidate 1.5 5.0 3.5) = false));\n  (assert ((candidate 2.0 6.0 2.0) = false));\n  (assert ((candidate 4.0 2.0 2.0) = true));\n  (assert ((candidate 2.2 2.2 2.2) = false));\n  (assert ((candidate (~4).0 6.0 2.0) = true));\n  (assert ((candidate 2.0 1.0 1.0) = true));\n  (assert ((candidate 3.0 4.0 7.0) = true));\n  (assert ((candidate 3.0 4.0 7.0) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_93_encode", "language": "ml", "prompt": "(**Write a function that takes a message, and encodes in such a \n * way that it swaps case of all letters, replaces all vowels in \n * the message with the letter that appears 2 places ahead of that \n * vowel in the english alphabet. \n * Assume only letters. \n * Examples:\n*)\nlet encode (message : string) : string =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_93_encode.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = encode in\n  (assert ((candidate \"TEST\") = \"tgst\"));\n  (assert ((candidate \"Mudasir\") = \"mWDCSKR\"));\n  (assert ((candidate \"YES\") = \"ygs\"));\n  (assert ((candidate \"This is a message\") = \"tHKS KS C MGSSCGG\"));\n  (assert ((candidate \"I DoNt KnOw WhAt tO WrItE\") = \"k dQnT kNqW wHcT Tq wRkTg\"));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_94_skjkasdkd", "language": "ml", "prompt": "(**You are given a list of integers.\n * You need to find the largest prime value and return the sum of its digits.\n * Examples:\n*)\nlet skjkasdkd (lst : int list) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_94_skjkasdkd.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = skjkasdkd in\n  (assert ((candidate [0; 3; 2; 1; 3; 5; 7; 4; 5; 5; 5; 2; 181; 32; 4; 32; 3; 2; 32; 324; 4; 3]) = 10));\n  (assert ((candidate [1; 0; 1; 8; 2; 4597; 2; 1; 3; 40; 1; 2; 1; 2; 4; 2; 5; 1]) = 25));\n  (assert ((candidate [1; 3; 1; 32; 5107; 34; 83278; 109; 163; 23; 2323; 32; 30; 1; 9; 3]) = 13));\n  (assert ((candidate [0; 724; 32; 71; 99; 32; 6; 0; 5; 91; 83; 0; 5; 6]) = 11));\n  (assert ((candidate [0; 81; 12; 3; 1; 21]) = 3));\n  (assert ((candidate [0; 8; 1; 2; 1; 7]) = 7));\n  (assert ((candidate [8191]) = 19));\n  (assert ((candidate [8191; 123456; 127; 7]) = 19));\n  (assert ((candidate [127; 97; 8192]) = 10));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_95_check_dict_case", "language": "ml", "prompt": "(**Given a dictionary, return True if all keys are strings in lower \n * case or all keys are strings in upper case, else return False.\n * The function should return False is the given dictionary is empty.\n * Examples:\n*)\nlet check_dict_case (dict : (string, string) list) : bool =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_95_check_dict_case.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = check_dict_case in\n  (assert ((candidate [(\"p\", \"pineapple\"); (\"b\", \"banana\")]) = true));\n  (assert ((candidate [(\"p\", \"pineapple\"); (\"A\", \"banana\"); (\"B\", \"banana\")]) = false));\n  (assert ((candidate [(\"p\", \"pineapple\"); (\"5\", \"banana\"); (\"a\", \"apple\")]) = false));\n  (assert ((candidate [(\"Name\", \"John\"); (\"Age\", \"36\"); (\"City\", \"Houston\")]) = false));\n  (assert ((candidate [(\"STATE\", \"NC\"); (\"ZIP\", \"12345\")]) = true));\n  (assert ((candidate [(\"fruit\", \"Orange\"); (\"taste\", \"Sweet\")]) = true));\n  (assert ((candidate []) = false));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_96_count_up_to", "language": "ml", "prompt": "(**Implement a function that takes an non-negative integer and returns an array of the first n\n * integers that are prime numbers and less than n.\n * for example:\n*)\nlet count_up_to (n : int) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_96_count_up_to.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = count_up_to in\n  (assert ((candidate 5) = [2; 3]));\n  (assert ((candidate 6) = [2; 3; 5]));\n  (assert ((candidate 7) = [2; 3; 5]));\n  (assert ((candidate 10) = [2; 3; 5; 7]));\n  (assert ((candidate 0) = []));\n  (assert ((candidate 22) = [2; 3; 5; 7; 11; 13; 17; 19]));\n  (assert ((candidate 1) = []));\n  (assert ((candidate 18) = [2; 3; 5; 7; 11; 13; 17]));\n  (assert ((candidate 47) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43]));\n  (assert ((candidate 101) = [2; 3; 5; 7; 11; 13; 17; 19; 23; 29; 31; 37; 41; 43; 47; 53; 59; 61; 67; 71; 73; 79; 83; 89; 97]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_97_multiply", "language": "ml", "prompt": "(**Complete the function that takes two integers and returns \n * the product of their unit digits.\n * Assume the input is always valid.\n * Examples:\n*)\nlet multiply (a : int) (b : int) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_97_multiply.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = multiply in\n  (assert ((candidate 148 412) = 16));\n  (assert ((candidate 19 28) = 72));\n  (assert ((candidate 2020 1851) = 0));\n  (assert ((candidate 14 (~15)) = 20));\n  (assert ((candidate 76 67) = 42));\n  (assert ((candidate 17 27) = 49));\n  (assert ((candidate 0 1) = 0));\n  (assert ((candidate 0 0) = 0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_98_count_upper", "language": "ml", "prompt": "(**Given a string s, count the number of uppercase vowels in even indices.\n * For example:\n*)\nlet count_upper (s : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_98_count_upper.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = count_upper in\n  (assert ((candidate \"aBCdEf\") = 1));\n  (assert ((candidate \"abcdefg\") = 0));\n  (assert ((candidate \"dBBE\") = 0));\n  (assert ((candidate \"B\") = 0));\n  (assert ((candidate \"U\") = 1));\n  (assert ((candidate \"\") = 0));\n  (assert ((candidate \"EEEE\") = 2));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_99_closest_integer", "language": "ml", "prompt": "(**Create a function that takes a value (string) representing a number\n * and returns the closest integer to it. If the number is equidistant\n * from two integers, round it away from zero.\n * Examples\n * Note:\n * Rounding away from zero means that if the given number is equidistant\n * from two integers, the one you should return is the one that is the\n * farthest from zero. For example closest_integer(\"14.5\") should\n * return 15 and closest_integer(\"-14.5\") should return -15.\n*)\nlet closest_integer (value : string) : int =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_99_closest_integer.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = closest_integer in\n  (assert ((candidate \"10\") = 10));\n  (assert ((candidate \"14.5\") = 15));\n  (assert ((candidate \"-15.5\") = (~16)));\n  (assert ((candidate \"15.3\") = 15));\n  (assert ((candidate \"0\") = 0));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
{"name": "HumanEval_9_rolling_max", "language": "ml", "prompt": "(**From a given list of integers, generate a list of rolling maximum element found until given moment\n * in the sequence.\n*)\nlet rolling_max (numbers : int list) : int list =", "doctests": "remove", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/originals-with-cleaned-doctests/HumanEval_9_rolling_max.py", "prompt_terminology": "verbatim", "tests": "\nlet assertions =\n let candidate = rolling_max in\n  (assert ((candidate []) = []));\n  (assert ((candidate [1; 2; 3; 4]) = [1; 2; 3; 4]));\n  (assert ((candidate [4; 3; 2; 1]) = [4; 4; 4; 4]));\n  (assert ((candidate [3; 2; 3; 100; 3]) = [3; 3; 3; 100; 100]));\n  ()\n", "stop_tokens": ["\n\n", "\n(*", "\ntype", "\nlet"]}
