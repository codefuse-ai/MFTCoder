{"name": "HumanEval_0_has_close_elements", "language": "hs", "prompt": "-- | Check if in given list of numbers, are any two numbers closer to each other than\n--  given threshold.\n--  >>> hasCloseElements [1.0,2.0,3.0] 0.5\n--  False\n--  >>> hasCloseElements [1.0,2.8,3.0,4.0,5.0,2.0] 0.3\n--  True\nhasCloseElements :: [Float] -> Float -> Bool\nhasCloseElements numbers threshold =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_0_has_close_elements.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = hasCloseElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.3 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] 0.05 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.95 == True then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] 0.8 == False then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] 0.1 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 1.0 == True then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] 0.5 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_100_make_a_pile", "language": "hs", "prompt": "-- | Given a positive integer n, you have to make a pile of n levels of stones.\n--  The first level has n stones.\n--  The number of stones in the next level is:\n--  - the next odd number if n is odd.\n--  - the next even number if n is even.\n--  Return the number of stones in each level in a list, where element at index\n--  i represents the number of stones in the level (i+1).\n--  Examples:\n--  >>> makeAPile 3\n--  [3,5,7]\nmakeAPile :: Int -> [Int]\nmakeAPile n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_100_make_a_pile.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = makeAPile\n  if candidate 3 == [3,5,7] then pure () else error \"assertion failed\"\n  if candidate 4 == [4,6,8,10] then pure () else error \"assertion failed\"\n  if candidate 5 == [5,7,9,11,13] then pure () else error \"assertion failed\"\n  if candidate 6 == [6,8,10,12,14,16] then pure () else error \"assertion failed\"\n  if candidate 8 == [8,10,12,14,16,18,20,22] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_101_words_string", "language": "hs", "prompt": "-- | You will be given a string of words separated by commas or spaces. Your task is\n--  to split the string into words and return an array of the words.\n--  For example:\n--  >>> wordsString \"Hi, my name is John\"\n--  [\"Hi\",\"my\",\"name\",\"is\",\"John\"]\n--  >>> wordsString \"One, two, three, four, five, six\"\n--  [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"]\nwordsString :: String -> [String]\nwordsString s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_101_words_string.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = wordsString\n  if candidate \"Hi, my name is John\" == [\"Hi\",\"my\",\"name\",\"is\",\"John\"] then pure () else error \"assertion failed\"\n  if candidate \"One, two, three, four, five, six\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"Hi, my name\" == [\"Hi\",\"my\",\"name\"] then pure () else error \"assertion failed\"\n  if candidate \"One,, two, three, four, five, six,\" == [\"One\",\"two\",\"three\",\"four\",\"five\",\"six\"] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"ahmed     , gamal\" == [\"ahmed\",\"gamal\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_102_choose_num", "language": "hs", "prompt": "-- | This function takes two positive numbers x and y and returns the\n--  biggest even integer number that is in the range [x, y] inclusive. If \n--  there's no such number, then the function should return -1.\n--  For example:\n--  >>> chooseNum 12 15\n--  14\n--  >>> chooseNum 13 12\n--  (-1)\nchooseNum :: Int -> Int -> Int\nchooseNum x y =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_102_choose_num.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = chooseNum\n  if candidate 12 15 == 14 then pure () else error \"assertion failed\"\n  if candidate 13 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 33 12354 == 12354 then pure () else error \"assertion failed\"\n  if candidate 5234 5233 == (-1) then pure () else error \"assertion failed\"\n  if candidate 6 29 == 28 then pure () else error \"assertion failed\"\n  if candidate 27 10 == (-1) then pure () else error \"assertion failed\"\n  if candidate 7 7 == (-1) then pure () else error \"assertion failed\"\n  if candidate 546 546 == 546 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_104_unique_digits", "language": "hs", "prompt": "-- | Given a list of positive integers x. return a sorted list of all \n--  elements that hasn't any even digit.\n--  Note: Returned list should be sorted in increasing order.\n--  For example:\n--  >>> uniqueDigits [15,33,1422,1]\n--  [1,15,33]\n--  >>> uniqueDigits [152,323,1422,10]\n--  []\nuniqueDigits :: [Int] -> [Int]\nuniqueDigits x =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_104_unique_digits.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = uniqueDigits\n  if candidate [15,33,1422,1] == [1,15,33] then pure () else error \"assertion failed\"\n  if candidate [152,323,1422,10] == [] then pure () else error \"assertion failed\"\n  if candidate [12345,2033,111,151] == [111,151] then pure () else error \"assertion failed\"\n  if candidate [135,103,31] == [31,135] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_105_by_length", "language": "hs", "prompt": "-- | Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n--  reverse the resulting array, and then replace each digit by its corresponding name from\n--  \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n--  For example:\n--  >>> byLength [2,1,1,4,5,8,2,3]\n--  [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"]\n--  If the array is empty, return an empty array:\n--  >>> byLength []\n--  []\n--  If the array has any strange number ignore it:\n--  >>> byLength [1,(-1),55]\n--  [\"One\"]\nbyLength :: [Int] -> [String]\nbyLength arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_105_by_length.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = byLength\n  if candidate [2,1,1,4,5,8,2,3] == [\"Eight\",\"Five\",\"Four\",\"Three\",\"Two\",\"Two\",\"One\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),55] == [\"One\"] then pure () else error \"assertion failed\"\n  if candidate [1,(-1),3,2] == [\"Three\",\"Two\",\"One\"] then pure () else error \"assertion failed\"\n  if candidate [9,4,8] == [\"Nine\",\"Eight\",\"Four\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_106_f", "language": "hs", "prompt": "-- | Implement the function f that takes n as a parameter,\n--  and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n--  or the sum of numbers from 1 to i otherwise.\n--  i starts from 1.\n--  the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n--  Example:\n--  >>> f 5\n--  [1,2,6,24,15]\nf :: Int -> [Int]\nf n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_106_f.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = f\n  if candidate 5 == [1,2,6,24,15] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,2,6,24,15,720,28] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  if candidate 3 == [1,2,6] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_107_even_odd_palindrome", "language": "hs", "prompt": "-- | Given a positive integer n, return a tuple that has the number of even and odd\n--  integer palindromes that fall within the range(1, n), inclusive.\n--  Example 1:\n--  >>> evenOddPalindrome 3\n--  (1, 2)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n--  Example 2:\n--  >>> evenOddPalindrome 12\n--  (4, 6)\n--  Explanation:\n--  Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n--  Note:\n--  1. 1 <= n <= 10^3\n--  2. returned tuple has the number of even and odd integer palindromes respectively.\nevenOddPalindrome :: Int -> (Int, Int)\nevenOddPalindrome n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_107_even_odd_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = evenOddPalindrome\n  if candidate 123 == (8, 13) then pure () else error \"assertion failed\"\n  if candidate 12 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 3 == (1, 2) then pure () else error \"assertion failed\"\n  if candidate 63 == (6, 8) then pure () else error \"assertion failed\"\n  if candidate 25 == (5, 6) then pure () else error \"assertion failed\"\n  if candidate 19 == (4, 6) then pure () else error \"assertion failed\"\n  if candidate 9 == (4, 5) then pure () else error \"assertion failed\"\n  if candidate 1 == (0, 1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_108_count_nums", "language": "hs", "prompt": "-- | Write a function count_nums which takes an array of integers and returns\n--  the number of elements which has a sum of digits > 0.\n--  If a number is negative, then its first signed digit will be negative:\n--  e.g. -123 has signed digits -1, 2, and 3.\n--  >>> countNums []\n--  0\n--  >>> countNums [(-1),11,(-11)]\n--  1\n--  >>> countNums [1,1,2]\n--  3\ncountNums :: [Int] -> Int\ncountNums arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_108_count_nums.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = countNums\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),0] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,2,(-2),3,4,5] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,6,9,(-6),0,1,5] == 5 then pure () else error \"assertion failed\"\n  if candidate [1,100,98,(-7),1,(-1)] == 4 then pure () else error \"assertion failed\"\n  if candidate [12,23,34,(-45),(-56),0] == 5 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_109_move_one_ball", "language": "hs", "prompt": "-- | We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n--  numbers in the array will be randomly ordered. Your task is to determine if\n--  it is possible to get an array sorted in non-decreasing order by performing \n--  the following operation on the given array:\n--  You are allowed to perform right shift operation any number of times.\n--  One right shift operation means shifting all elements of the array by one\n--  position in the right direction. The last element of the array will be moved to\n--  the starting position in the array i.e. 0th index. \n--  If it is possible to obtain the sorted array by performing the above operation\n--  then return True else return False.\n--  If the given array is empty then return True.\n--  Note: The given list is guaranteed to have unique elements.\n--  For Example:\n--  >>> moveOneBall [3,4,5,1,2]\n--  True\n--  Explanation: By performin 2 right shift operations, non-decreasing order can\n--  be achieved for the given array.\n--  >>> moveOneBall [3,5,4,1,2]\n--  False\n--  Explanation:It is not possible to get non-decreasing order for the given\n--  array by performing any number of right shift operations.\nmoveOneBall :: [Int] -> Bool\nmoveOneBall arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_109_move_one_ball.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = moveOneBall\n  if candidate [3,4,5,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [3,5,10,1,2] == True then pure () else error \"assertion failed\"\n  if candidate [4,3,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [3,5,4,1,2] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_10_make_palindrome", "language": "hs", "prompt": "-- | Find the shortest palindrome that begins with a supplied string.\n--  Algorithm idea is simple:\n--  - Find the longest postfix of supplied string that is a palindrome.\n--  - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n--  >>> makePalindrome \"\"\n--  \"\"\n--  >>> makePalindrome \"cat\"\n--  \"catac\"\n--  >>> makePalindrome \"cata\"\n--  \"catac\"\nmakePalindrome :: String -> String\nmakePalindrome string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_10_make_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = makePalindrome\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"x\" == \"x\" then pure () else error \"assertion failed\"\n  if candidate \"xyz\" == \"xyzyx\" then pure () else error \"assertion failed\"\n  if candidate \"xyx\" == \"xyx\" then pure () else error \"assertion failed\"\n  if candidate \"jerry\" == \"jerryrrej\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_110_exchange", "language": "hs", "prompt": "-- | In this problem, you will implement a function that takes two lists of numbers,\n--  and determines whether it is possible to perform an exchange of elements\n--  between them to make lst1 a list of only even numbers.\n--  There is no limit on the number of exchanged elements between lst1 and lst2.\n--  If it is possible to exchange elements between the lst1 and lst2 to make\n--  all the elements of lst1 to be even, return \"YES\".\n--  Otherwise, return \"NO\".\n--  For example:\n--  >>> exchange [1,2,3,4] [1,2,3,4]\n--  \"YES\"\n--  >>> exchange [1,2,3,4] [1,5,3,4]\n--  \"NO\"\n--  It is assumed that the input lists will be non-empty.\nexchange :: [Int] -> [Int] -> String\nexchange lst1 lst2 =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_110_exchange.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = exchange\n  if candidate [1,2,3,4] [1,2,3,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [1,5,3,4] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] [2,1,4,3] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,4] == \"YES\" then pure () else error \"assertion failed\"\n  if candidate [5,7,3] [2,6,3] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [3,2,6,1,8,9] [3,5,5,1,1,1] == \"NO\" then pure () else error \"assertion failed\"\n  if candidate [100,200] [200,200] == \"YES\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_111_histogram", "language": "hs", "prompt": "-- | Given a string representing a space separated lowercase letters, return a dictionary\n--  of the letter with the most repetition and containing the corresponding count.\n--  If several letters have the same occurrence, return all of them.\n--  Example:\n--  >>> histogram \"a b c\"\n--  [(\"a\", 1), (\"b\", 1), (\"c\", 1)]\n--  >>> histogram \"a b b a\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"a b c a b\"\n--  [(\"a\", 2), (\"b\", 2)]\n--  >>> histogram \"b b b b a\"\n--  [(\"b\", 4)]\n--  >>> histogram \"\"\n--  []\nhistogram :: String -> [(String, Int)]\nhistogram test =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_111_histogram.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = histogram\n  if candidate \"a b b a\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c a b\" == [(\"a\", 2), (\"b\", 2)] then pure () else error \"assertion failed\"\n  if candidate \"a b c d g\" == [(\"a\", 1), (\"b\", 1), (\"c\", 1), (\"d\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"b b b b a\" == [(\"b\", 4)] then pure () else error \"assertion failed\"\n  if candidate \"r t g\" == [(\"r\", 1), (\"t\", 1), (\"g\", 1)] then pure () else error \"assertion failed\"\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"a\" == [(\"a\", 1)] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_112_reverse_delete", "language": "hs", "prompt": "-- | Task\n--  We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n--  then check if the result string is palindrome.\n--  A string is called palindrome if it reads the same backward as forward.\n--  You should return a tuple containing the result string and True/False for the check.\n--  Example\n--  >>> reverseDelete \"abcde\" \"ae\"\n--  (\"bcd\", False)\n--  >>> reverseDelete \"abcdef\" \"b\"\n--  (\"acdef\", False)\n--  >>> reverseDelete \"abcdedcba\" \"ab\"\n--  (\"cdedc\", True)\nreverseDelete :: String -> String -> (String, Bool)\nreverseDelete s c =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_112_reverse_delete.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = reverseDelete\n  if candidate \"abcde\" \"ae\" == (\"bcd\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdef\" \"b\" == (\"acdef\", False) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"ab\" == (\"cdedc\", True) then pure () else error \"assertion failed\"\n  if candidate \"dwik\" \"w\" == (\"dik\", False) then pure () else error \"assertion failed\"\n  if candidate \"a\" \"a\" == (\"\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"abcdedcba\" \"v\" == (\"abcdedcba\", True) then pure () else error \"assertion failed\"\n  if candidate \"vabba\" \"v\" == (\"abba\", True) then pure () else error \"assertion failed\"\n  if candidate \"mamma\" \"mia\" == (\"\", True) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_113_odd_count", "language": "hs", "prompt": "-- | Given a list of strings, where each string consists of only digits, return a list.\n--  Each element i of the output should be \"the number of odd elements in the\n--  string i of the input.\" where all the i's should be replaced by the number\n--  of odd digits in the i'th string of the input.\n--  >>> oddCount [\"1234567\"]\n--  [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n--  >>> oddCount [\"3\",\"11111111\"]\n--  [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\noddCount :: [String] -> [String]\noddCount lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_113_odd_count.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = oddCount\n  if candidate [\"1234567\"] == [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"3\",\"11111111\"] == [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\"the number of odd elements 8n the str8ng 8 of the 8nput.\"] then pure () else error \"assertion failed\"\n  if candidate [\"271\",\"137\",\"314\"] == [\"the number of odd elements 2n the str2ng 2 of the 2nput.\",\"the number of odd elements 3n the str3ng 3 of the 3nput.\",\"the number of odd elements 2n the str2ng 2 of the 2nput.\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_114_minSubArraySum", "language": "hs", "prompt": "-- | Given an array of integers nums, find the minimum sum of any non-empty sub-array\n--  of nums.\n--  Example\n--  >>> minsubarraysum [2,3,4,1,2,4]\n--  1\n--  >>> minsubarraysum [(-1),(-2),(-3)]\n--  (-6)\nminsubarraysum :: [Int] -> Int\nminsubarraysum nums =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_114_minSubArraySum.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = minsubarraysum\n  if candidate [2,3,4,1,2,4] == 1 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),2,(-10)] == (-14) then pure () else error \"assertion failed\"\n  if candidate [(-9999999999999999)] == (-9999999999999999) then pure () else error \"assertion failed\"\n  if candidate [0,10,20,1000000] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [100,(-1),(-2),(-3),10,(-5)] == (-6) then pure () else error \"assertion failed\"\n  if candidate [10,11,13,8,3,4] == 3 then pure () else error \"assertion failed\"\n  if candidate [100,(-33),32,(-1),0,(-2)] == (-33) then pure () else error \"assertion failed\"\n  if candidate [(-10)] == (-10) then pure () else error \"assertion failed\"\n  if candidate [7] == 7 then pure () else error \"assertion failed\"\n  if candidate [1,(-1)] == (-1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_115_max_fill", "language": "hs", "prompt": "-- | You are given a rectangular grid of wells. Each row represents a single well,\n--  and each 1 in a row represents a single unit of water.\n--  Each well has a corresponding bucket that can be used to extract water from it, \n--  and all buckets have the same capacity.\n--  Your task is to use the buckets to empty the wells.\n--  Output the number of times you need to lower the buckets.\n--  Example 1:\n--  >>> maxFill [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1\n--  6\n--  Example 2:\n--  >>> maxFill [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2\n--  5\n--  Example 3:\n--  >>> maxFill [[0,0,0],[0,0,0]] 5\n--  0\n--  Constraints:\n--  * all wells have the same length\n--  * 1 <= grid.length <= 10^2\n--  * 1 <= grid[:,1].length <= 10^2\n--  * grid[i][j] -> 0 | 1\n--  * 1 <= capacity <= 10\nmaxFill :: [[Int]] -> Int -> Int\nmaxFill grid capacity =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_115_max_fill.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = maxFill\n  if candidate [[0,0,1,0],[0,1,0,0],[1,1,1,1]] 1 == 6 then pure () else error \"assertion failed\"\n  if candidate [[0,0,1,1],[0,0,0,0],[1,1,1,1],[0,1,1,1]] 2 == 5 then pure () else error \"assertion failed\"\n  if candidate [[0,0,0],[0,0,0]] 5 == 0 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 2 == 4 then pure () else error \"assertion failed\"\n  if candidate [[1,1,1,1],[1,1,1,1]] 9 == 2 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_116_sort_array", "language": "hs", "prompt": "-- | In this Kata, you have to sort an array of non-negative integers according to\n--  number of ones in their binary representation in ascending order.\n--  For similar number of ones, sort based on decimal value.\n--  It must be implemented like this:\n--  >>> sortArray [1,5,2,3,4]\n--  [1,2,3,4,5]\n--  >>> sortArray [(-2),(-3),(-4),(-5),(-6)]\n--  [(-6),(-5),(-4),(-3),(-2)]\n--  >>> sortArray [1,0,2,3,4]\n--  [0,1,2,3,4]\nsortArray :: [Int] -> [Int]\nsortArray arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_116_sort_array.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [1,5,2,3,4] == [1,2,4,3,5] then pure () else error \"assertion failed\"\n  if candidate [(-2),(-3),(-4),(-5),(-6)] == [(-4),(-2),(-6),(-5),(-3)] then pure () else error \"assertion failed\"\n  if candidate [1,0,2,3,4] == [0,1,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [2,5,77,4,5,3,5,7,2,3,4] == [2,2,4,4,3,3,5,5,5,7,77] then pure () else error \"assertion failed\"\n  if candidate [3,6,44,12,32,5] == [32,3,5,6,12,44] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  if candidate [2,4,8,16,32] == [2,4,8,16,32] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_117_select_words", "language": "hs", "prompt": "-- | Given a string s and a natural number n, you have been tasked to implement \n--  a function that returns a list of all words from string s that contain exactly \n--  n consonants, in order these words appear in the string s.\n--  If the string s is empty then the function should return an empty list.\n--  Note: you may assume the input string contains only letters and spaces.\n--  Examples:\n--  >>> selectWords \"Mary had a little lamb\" 4\n--  [\"little\"]\n--  >>> selectWords \"Mary had a little lamb\" 3\n--  [\"Mary\",\"lamb\"]\n--  >>> selectWords \"simple white space\" 2\n--  []\n--  >>> selectWords \"Hello world\" 4\n--  [\"world\"]\n--  >>> selectWords \"Uncle sam\" 3\n--  [\"Uncle\"]\nselectWords :: String -> Int -> [String]\nselectWords s n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_117_select_words.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = selectWords\n  if candidate \"Mary had a little lamb\" 4 == [\"little\"] then pure () else error \"assertion failed\"\n  if candidate \"Mary had a little lamb\" 3 == [\"Mary\",\"lamb\"] then pure () else error \"assertion failed\"\n  if candidate \"simple white space\" 2 == [] then pure () else error \"assertion failed\"\n  if candidate \"Hello world\" 4 == [\"world\"] then pure () else error \"assertion failed\"\n  if candidate \"Uncle sam\" 3 == [\"Uncle\"] then pure () else error \"assertion failed\"\n  if candidate \"\" 4 == [] then pure () else error \"assertion failed\"\n  if candidate \"a b c d e f\" 1 == [\"b\",\"c\",\"d\",\"f\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_118_get_closest_vowel", "language": "hs", "prompt": "-- | You are given a word. Your task is to find the closest vowel that stands between \n--  two consonants from the right side of the word (case sensitive).\n--  Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n--  find any vowel met the above condition. \n--  You may assume that the given string contains English letter only.\n--  Example:\n--  >>> getClosestVowel \"yogurt\"\n--  \"u\"\n--  >>> getClosestVowel \"FULL\"\n--  \"U\"\n--  >>> getClosestVowel \"quick\"\n--  \"\"\n--  >>> getClosestVowel \"ab\"\n--  \"\"\ngetClosestVowel :: String -> String\ngetClosestVowel word =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_118_get_closest_vowel.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = getClosestVowel\n  if candidate \"yogurt\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"full\" == \"u\" then pure () else error \"assertion failed\"\n  if candidate \"easy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"eAsy\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ali\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"bad\" == \"a\" then pure () else error \"assertion failed\"\n  if candidate \"most\" == \"o\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"ba\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"quick\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"anime\" == \"i\" then pure () else error \"assertion failed\"\n  if candidate \"Asia\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Above\" == \"o\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_119_match_parens", "language": "hs", "prompt": "-- | You are given a list of two strings, both strings consist of open\n--  parentheses '(' or close parentheses ')' only.\n--  Your job is to check if it is possible to concatenate the two strings in\n--  some order, that the resulting string will be good.\n--  A string S is considered to be good if and only if all parentheses in S\n--  are balanced. For example: the string '(())()' is good, while the string\n--  '())' is not.\n--  Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n--  Examples:\n--  >>> matchParens [\"()(\",\")\"]\n--  \"Yes\"\n--  >>> matchParens [\")\",\")\"]\n--  \"No\"\nmatchParens :: [String] -> String\nmatchParens lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_119_match_parens.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = matchParens\n  if candidate [\"()(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\")\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(())\",\"())())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")())\",\"(()()(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"(())))\",\"(()())((\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"()\",\"())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(()(\",\"()))()\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\"((((\",\"((())\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(()\",\"(()(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\")(\",\")(\"] == \"No\" then pure () else error \"assertion failed\"\n  if candidate [\"(\",\")\"] == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate [\")\",\"(\"] == \"Yes\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_11_string_xor", "language": "hs", "prompt": "-- | Input are two strings a and b consisting only of 1s and 0s.\n--  Perform binary XOR on these inputs and return result also as a string.\n--  >>> stringXor \"010\" \"110\"\n--  \"100\"\nstringXor :: String -> String -> String\nstringXor a b =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_11_string_xor.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = stringXor\n  if candidate \"111000\" \"101010\" == \"010010\" then pure () else error \"assertion failed\"\n  if candidate \"1\" \"1\" == \"0\" then pure () else error \"assertion failed\"\n  if candidate \"0101\" \"0000\" == \"0101\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_120_maximum", "language": "hs", "prompt": "-- | Given an array arr of integers and a positive integer k, return a sorted list \n--  of length k with the maximum k numbers in arr.\n--  Example 1:\n--  >>> maximum [(-3),(-4),5] 3\n--  [(-4),(-3),5]\n--  Example 2:\n--  >>> maximum [4,(-4),4] 2\n--  [4,4]\n--  Example 3:\n--  >>> maximum [(-3),2,1,2,(-1),(-2),1] 1\n--  [2]\n--  Note:\n--  1. The length of the array will be in the range of [1, 1000].\n--  2. The elements in the array will be in the range of [-1000, 1000].\n--  3. 0 <= k <= len(arr)\nmaximum :: [Int] -> Int -> [Int]\nmaximum arr k =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_120_maximum.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = maximum\n  if candidate [(-3),(-4),5] 3 == [(-4),(-3),5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4),4] 2 == [4,4] then pure () else error \"assertion failed\"\n  if candidate [(-3),2,1,2,(-1),(-2),1] 1 == [2] then pure () else error \"assertion failed\"\n  if candidate [123,(-123),20,0,1,2,(-3)] 3 == [2,20,123] then pure () else error \"assertion failed\"\n  if candidate [(-123),20,0,1,2,(-3)] 4 == [0,1,2,20] then pure () else error \"assertion failed\"\n  if candidate [5,15,0,3,(-13),(-8),0] 7 == [(-13),(-8),0,0,3,5,15] then pure () else error \"assertion failed\"\n  if candidate [(-1),0,2,5,3,(-10)] 2 == [3,5] then pure () else error \"assertion failed\"\n  if candidate [1,0,5,(-7)] 1 == [5] then pure () else error \"assertion failed\"\n  if candidate [4,(-4)] 2 == [(-4),4] then pure () else error \"assertion failed\"\n  if candidate [(-10),10] 2 == [(-10),10] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,(-23),243,(-400),0] 0 == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_121_solution", "language": "hs", "prompt": "-- | Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n--  Examples\n--  >>> solution [5,8,7,1]\n--  12\n--  >>> solution [3,3,3,3,3]\n--  9\n--  >>> solution [30,13,24,321]\n--  0\nsolution :: [Int] -> Int\nsolution lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_121_solution.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = solution\n  if candidate [5,8,7,1] == 12 then pure () else error \"assertion failed\"\n  if candidate [3,3,3,3,3] == 9 then pure () else error \"assertion failed\"\n  if candidate [30,13,24,321] == 0 then pure () else error \"assertion failed\"\n  if candidate [5,9] == 5 then pure () else error \"assertion failed\"\n  if candidate [2,4,8] == 0 then pure () else error \"assertion failed\"\n  if candidate [30,13,23,32] == 23 then pure () else error \"assertion failed\"\n  if candidate [3,13,2,9] == 3 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_122_add_elements", "language": "hs", "prompt": "-- | Given a non-empty array of integers arr and an integer k, return\n--  the sum of the elements with at most two digits from the first k elements of arr.\n--  Example:\n--  >>> addElements [111,21,3,4000,5,6,7,8,9] 4\n--  24\n--  Constraints:\n--  1. 1 <= len(arr) <= 100\n--  2. 1 <= k <= len(arr)\naddElements :: [Int] -> Int -> Int\naddElements arr k =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_122_add_elements.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = addElements\n  if candidate [1,(-2),(-3),41,57,76,87,88,99] 3 == (-4) then pure () else error \"assertion failed\"\n  if candidate [111,121,3,4000,5,6] 2 == 0 then pure () else error \"assertion failed\"\n  if candidate [11,21,3,90,5,6,7,8,9] 4 == 125 then pure () else error \"assertion failed\"\n  if candidate [111,21,3,4000,5,6,7,8,9] 4 == 24 then pure () else error \"assertion failed\"\n  if candidate [1] 1 == 1 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_123_get_odd_collatz", "language": "hs", "prompt": "-- | Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n--  The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n--  as follows: start with any positive integer n. Then each term is obtained from the \n--  previous term as follows: if the previous term is even, the next term is one half of \n--  the previous term. If the previous term is odd, the next term is 3 times the previous\n--  term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n--  Note: \n--  1. Collatz(1) is [1].\n--  2. returned list sorted in increasing order.\n--  For example:\n--  get_odd_collatz(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n--  >>> getOddCollatz 5\n--  [1,5]\ngetOddCollatz :: Int -> [Int]\ngetOddCollatz n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_123_get_odd_collatz.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = getOddCollatz\n  if candidate 14 == [1,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,5] then pure () else error \"assertion failed\"\n  if candidate 12 == [1,3,5] then pure () else error \"assertion failed\"\n  if candidate 1 == [1] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_124_valid_date", "language": "hs", "prompt": "-- | You have to write a function which validates a given date string and\n--  returns True if the date is valid otherwise False.\n--  The date is valid if all of the following rules are satisfied:\n--  1. The date string is not empty.\n--  2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n--  3. The months should not be less than 1 or higher than 12.\n--  4. The date should be in the format: mm-dd-yyyy\n--  >>> validDate \"03-11-2000\"\n--  True\n--  >>> validDate \"15-01-2012\"\n--  False\n--  >>> validDate \"04-0-2040\"\n--  False\n--  >>> validDate \"06-04-2020\"\n--  True\n--  >>> validDate \"06/04/2020\"\n--  False\nvalidDate :: String -> Bool\nvalidDate date =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_124_valid_date.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = validDate\n  if candidate \"03-11-2000\" == True then pure () else error \"assertion failed\"\n  if candidate \"15-01-2012\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-0-2040\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-04-2020\" == True then pure () else error \"assertion failed\"\n  if candidate \"01-01-2007\" == True then pure () else error \"assertion failed\"\n  if candidate \"03-32-2011\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-31-3000\" == False then pure () else error \"assertion failed\"\n  if candidate \"06-06-2005\" == True then pure () else error \"assertion failed\"\n  if candidate \"21-31-2000\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-12-2003\" == True then pure () else error \"assertion failed\"\n  if candidate \"04122003\" == False then pure () else error \"assertion failed\"\n  if candidate \"20030412\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04\" == False then pure () else error \"assertion failed\"\n  if candidate \"2003-04-12\" == False then pure () else error \"assertion failed\"\n  if candidate \"04-2003\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_126_is_sorted", "language": "hs", "prompt": "-- | Given a list of numbers, return whether or not they are sorted\n--  in ascending order. If list has more than 1 duplicate of the same\n--  number, return False. Assume no negative numbers and only integers.\n--  Examples\n--  >>> isSorted [5]\n--  True\n--  >>> isSorted [1,2,3,4,5]\n--  True\n--  >>> isSorted [1,3,2,4,5]\n--  False\n--  >>> isSorted [1,2,3,4,5,6]\n--  True\n--  >>> isSorted [1,2,3,4,5,6,7]\n--  True\n--  >>> isSorted [1,3,2,4,5,6,7]\n--  False\n--  >>> isSorted [1,2,2,3,3,4]\n--  True\n--  >>> isSorted [1,2,2,2,3,4]\n--  False\nisSorted :: [Int] -> Bool\nisSorted lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_126_is_sorted.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isSorted\n  if candidate [5] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7] == True then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,7] == False then pure () else error \"assertion failed\"\n  if candidate [] == True then pure () else error \"assertion failed\"\n  if candidate [1] == True then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,2,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,3,3,4] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,2,3,3,4] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_127_intersection", "language": "hs", "prompt": "-- | You are given two intervals,\n--  where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n--  The given intervals are closed which means that the interval (start, end)\n--  includes both start and end.\n--  For each given interval, it is assumed that its start is less or equal its end.\n--  Your task is to determine whether the length of intersection of these two \n--  intervals is a prime number.\n--  Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n--  which its length is 1, which not a prime number.\n--  If the length of the intersection is a prime number, return \"YES\",\n--  otherwise, return \"NO\".\n--  If the two intervals don't intersect, return \"NO\".\n--  [input/output] samples:\n--  >>> intersection (1, 2) (2, 3)\n--  \"NO\"\n--  >>> intersection ((-1), 1) (0, 4)\n--  \"NO\"\n--  >>> intersection ((-3), (-1)) ((-5), 5)\n--  \"YES\"\nintersection :: (Int, Int) -> (Int, Int) -> String\nintersection interval1 interval2 =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_127_intersection.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = intersection\n  if candidate (1, 2) (2, 3) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-1), 1) (0, 4) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-3), (-1)) ((-5), 5) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-2), 2) ((-4), 0) == \"YES\" then pure () else error \"assertion failed\"\n  if candidate ((-11), 2) ((-1), (-1)) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (3, 5) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate (1, 2) (1, 2) == \"NO\" then pure () else error \"assertion failed\"\n  if candidate ((-2), (-2)) ((-3), (-2)) == \"NO\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_128_prod_signs", "language": "hs", "prompt": "-- | You are given an array arr of integers and you need to return\n--  sum of magnitudes of integers multiplied by product of all signs\n--  of each number in the array, represented by 1, -1 or 0.\n--  Note: return None for empty arr.\n--  Example:\n--  >>> prodSigns [1,2,2,(-4)]\n--  Just (9)\n--  >>> prodSigns [0,1]\n--  Just (0)\n--  >>> prodSigns []\n--  Just (Nothing)\nprodSigns :: [Int] -> Maybe Int\nprodSigns arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_128_prod_signs.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = prodSigns\n  if candidate [1,2,2,(-4)] == Just ((-9)) then pure () else error \"assertion failed\"\n  if candidate [0,1] == Just (0) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,2,3,(-1),1] == Just ((-10)) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,2,(-1),(-1),9] == Just (20) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,(-1),1] == Just (4) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,1] == Just ((-4)) then pure () else error \"assertion failed\"\n  if candidate [(-1),1,1,0] == Just (0) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_129_minPath", "language": "hs", "prompt": "-- | Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n--  each cell of the grid contains a value. Every integer in the range [1, N * N]\n--  inclusive appears exactly once on the cells of the grid.\n--  You have to find the minimum path of length k in the grid. You can start\n--  from any cell, and in each step you can move to any of the neighbor cells,\n--  in other words, you can go to cells which share an edge with you current\n--  cell.\n--  Please note that a path of length k means visiting exactly k cells (not\n--  necessarily distinct).\n--  You CANNOT go off the grid.\n--  A path A (of length k) is considered less than a path B (of length k) if\n--  after making the ordered lists of the values on the cells that A and B go\n--  through (let's call them lst_A and lst_B), lst_A is lexicographically less\n--  than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n--  such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n--  lst_A[j] = lst_B[j].\n--  It is guaranteed that the answer is unique.\n--  Return an ordered list of the values on the cells that the minimum path go through.\n--  Examples:    \n--  >>> minpath [[1,2,3],[4,5,6],[7,8,9]] 3\n--  [1,2,1]\n--  >>> minpath [[5,9,3],[4,1,6],[7,8,2]] 1\n--  [1]\nminpath :: [[Int]] -> Int -> [Int]\nminpath grid k =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_129_minPath.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = minpath\n  if candidate [[1,2,3],[4,5,6],[7,8,9]] 3 == [1,2,1] then pure () else error \"assertion failed\"\n  if candidate [[5,9,3],[4,1,6],[7,8,2]] 1 == [1] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]] 4 == [1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[6,4,13,10],[5,7,12,1],[3,16,11,15],[8,14,9,2]] 7 == [1,10,1,10,1,10,1] then pure () else error \"assertion failed\"\n  if candidate [[8,14,9,2],[6,4,13,15],[5,7,1,12],[3,10,11,16]] 5 == [1,7,1,7,1] then pure () else error \"assertion failed\"\n  if candidate [[11,8,7,2],[5,16,14,4],[9,3,15,6],[12,13,10,1]] 9 == [1,6,1,6,1,6,1,6,1] then pure () else error \"assertion failed\"\n  if candidate [[12,13,10,1],[9,3,15,6],[5,16,14,4],[11,8,7,2]] 12 == [1,6,1,6,1,6,1,6,1,6,1,6] then pure () else error \"assertion failed\"\n  if candidate [[2,7,4],[3,1,5],[6,8,9]] 8 == [1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  if candidate [[6,1,5],[3,8,9],[2,7,4]] 8 == [1,5,1,5,1,5,1,5] then pure () else error \"assertion failed\"\n  if candidate [[1,2],[3,4]] 10 == [1,2,1,2,1,2,1,2,1,2] then pure () else error \"assertion failed\"\n  if candidate [[1,3],[3,2]] 10 == [1,3,1,3,1,3,1,3,1,3] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_12_longest", "language": "hs", "prompt": "-- | Out of list of strings, return the longest one. Return the first one in case of multiple\n--  strings of the same length. Return None in case the input list is empty.\n--  >>> longest []\n--  Just (Nothing)\n--  >>> longest [\"a\",\"b\",\"c\"]\n--  Just (\"a\")\n--  >>> longest [\"a\",\"bb\",\"ccc\"]\n--  Just (\"ccc\")\nlongest :: [String] -> Maybe String\nlongest strings =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_12_longest.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = longest\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == Just (\"x\") then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"yyy\",\"zzzz\",\"www\",\"kkkk\",\"abc\"] == Just (\"zzzz\") then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_130_tri", "language": "hs", "prompt": "-- | Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n--  the last couple centuries. However, what people don't know is Tribonacci sequence.\n--  Tribonacci sequence is defined by the recurrence:\n--  tri(1) = 3\n--  tri(n) = 1 + n / 2, if n is even.\n--  tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n--  For example:\n--  tri(2) = 1 + (2 / 2) = 2\n--  tri(4) = 3\n--  tri(3) = tri(2) + tri(1) + tri(4)\n--  = 2 + 3 + 3 = 8 \n--  You are given a non-negative integer number n, you have to a return a list of the \n--  first n + 1 numbers of the Tribonacci sequence.\n--  Examples:\n--  >>> tri 3\n--  [1,3,2,8]\ntri :: Int -> [Int]\ntri n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_130_tri.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = tri\n  if candidate 3 == [1,3,2,8] then pure () else error \"assertion failed\"\n  if candidate 4 == [1,3,2,8,3] then pure () else error \"assertion failed\"\n  if candidate 5 == [1,3,2,8,3,15] then pure () else error \"assertion failed\"\n  if candidate 6 == [1,3,2,8,3,15,4] then pure () else error \"assertion failed\"\n  if candidate 7 == [1,3,2,8,3,15,4,24] then pure () else error \"assertion failed\"\n  if candidate 8 == [1,3,2,8,3,15,4,24,5] then pure () else error \"assertion failed\"\n  if candidate 9 == [1,3,2,8,3,15,4,24,5,35] then pure () else error \"assertion failed\"\n  if candidate 20 == [1,3,2,8,3,15,4,24,5,35,6,48,7,63,8,80,9,99,10,120,11] then pure () else error \"assertion failed\"\n  if candidate 0 == [1] then pure () else error \"assertion failed\"\n  if candidate 1 == [1,3] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_131_digits", "language": "hs", "prompt": "-- | Given a positive integer n, return the product of the odd digits.\n--  Return 0 if all digits are even.\n--  For example:\n--  >>> digits 1\n--  1\n--  >>> digits 4\n--  0\n--  >>> digits 235\n--  15\ndigits :: Int -> Int\ndigits n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_131_digits.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = digits\n  if candidate 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 54 == 5 then pure () else error \"assertion failed\"\n  if candidate 120 == 1 then pure () else error \"assertion failed\"\n  if candidate 5014 == 5 then pure () else error \"assertion failed\"\n  if candidate 98765 == 315 then pure () else error \"assertion failed\"\n  if candidate 5576543 == 2625 then pure () else error \"assertion failed\"\n  if candidate 2468 == 0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_132_is_nested", "language": "hs", "prompt": "-- | Create a function that takes a string as input which contains only square brackets.\n--  The function should return True if and only if there is a valid subsequence of brackets \n--  where at least one bracket in the subsequence is nested.\n--  >>> isNested \"[[]]\"\n--  True\n--  >>> isNested \"[]]]]]]][[[[[]\"\n--  False\n--  >>> isNested \"[][]\"\n--  False\n--  >>> isNested \"[]\"\n--  False\n--  >>> isNested \"[[][]]\"\n--  True\n--  >>> isNested \"[[]][[\"\n--  True\nisNested :: String -> Bool\nisNested string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_132_is_nested.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isNested\n  if candidate \"[[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]][[[[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[]]]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[]]]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[][][[]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[]]\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[]][[\" == True then pure () else error \"assertion failed\"\n  if candidate \"[[][]]\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"[[[[[[[[\" == False then pure () else error \"assertion failed\"\n  if candidate \"]]]]]]]]\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_133_sum_squares", "language": "hs", "prompt": "-- | You are given a list of numbers.\n--  You need to return the sum of squared numbers in the given list,\n--  round each element in the list to the upper int(Ceiling) first.\n--  Examples:\n--  >>> lst [1.0,2.0,3.0]\n--  14\n--  >>> lst [1.0,4.0,9.0]\n--  98\n--  >>> lst [1.0,3.0,5.0,7.0]\n--  84\n--  >>> lst [1.4,4.2,0.0]\n--  29\n--  >>> lst [-2.4,1.0,1.0]\n--  6\nsumSquares :: [Float] -> Int\nsumSquares lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_133_sum_squares.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0] == 14 then pure () else error \"assertion failed\"\n  if candidate [1.0,3.0,5.0,7.0] == 84 then pure () else error \"assertion failed\"\n  if candidate [1.4,4.2,0.0] == 29 then pure () else error \"assertion failed\"\n  if candidate [-2.4,1.0,1.0] == 6 then pure () else error \"assertion failed\"\n  if candidate [100.0,1.0,15.0,2.0] == 10230 then pure () else error \"assertion failed\"\n  if candidate [10000.0,10000.0] == 200000000 then pure () else error \"assertion failed\"\n  if candidate [-1.4,4.6,6.3] == 75 then pure () else error \"assertion failed\"\n  if candidate [-1.4,17.9,18.9,19.9] == 1086 then pure () else error \"assertion failed\"\n  if candidate [0.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0] == 1 then pure () else error \"assertion failed\"\n  if candidate [-1.0,1.0,0.0] == 2 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_134_check_if_last_char_is_a_letter", "language": "hs", "prompt": "-- | Create a function that returns True if the last character\n--  of a given string is an alphabetical character and is not\n--  a part of a word, and False otherwise.\n--  Note: \"word\" is a group of characters separated by space.\n--  Examples:\n--  >>> checkIfLastCharIsALetter \"apple pie\"\n--  False\n--  >>> checkIfLastCharIsALetter \"apple pi e\"\n--  True\n--  >>> checkIfLastCharIsALetter \"apple pi e \"\n--  False\n--  >>> checkIfLastCharIsALetter \"\"\n--  False\ncheckIfLastCharIsALetter :: String -> Bool\ncheckIfLastCharIsALetter txt =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_134_check_if_last_char_is_a_letter.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = checkIfLastCharIsALetter\n  if candidate \"apple\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e\" == True then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == False then pure () else error \"assertion failed\"\n  if candidate \"A\" == True then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie \" == False then pure () else error \"assertion failed\"\n  if candidate \"Pumpkin pie 1\" == False then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"eeeee e \" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pie\" == False then pure () else error \"assertion failed\"\n  if candidate \"apple pi e \" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_135_can_arrange", "language": "hs", "prompt": "-- | Create a function which returns the largest index of an element which\n--  is not greater than or equal to the element immediately preceding it. If\n--  no such element exists then return -1. The given array will not contain\n--  duplicate values.\n--  Examples:\n--  >>> canArrange [1,2,4,3,5]\n--  3\n--  >>> canArrange [1,2,3]\n--  (-1)\ncanArrange :: [Int] -> Int\ncanArrange arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_135_can_arrange.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = canArrange\n  if candidate [1,2,4,3,5] == 3 then pure () else error \"assertion failed\"\n  if candidate [1,2,4,5] == (-1) then pure () else error \"assertion failed\"\n  if candidate [1,4,2,5,6,7,8,9,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [4,8,5,7,3] == 4 then pure () else error \"assertion failed\"\n  if candidate [] == (-1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_136_largest_smallest_integers", "language": "hs", "prompt": "-- | Create a function that returns a tuple (a, b), where 'a' is\n--  the largest of negative integers, and 'b' is the smallest\n--  of positive integers in a list.\n--  If there is no negative or positive integers, return them as None.\n--  Examples:\n--  >>> largestSmallestIntegers [2,4,1,3,5,7]\n--  (Nothing, 1)\n--  >>> largestSmallestIntegers []\n--  (Nothing, Nothing)\n--  >>> largestSmallestIntegers [0]\n--  (Nothing, Nothing)\nlargestSmallestIntegers :: [Int] -> (Maybe Int, Maybe Int)\nlargestSmallestIntegers lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_136_largest_smallest_integers.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = largestSmallestIntegers\n  if candidate [2,4,1,3,5,7] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [2,4,1,3,5,7,0] == (Nothing, 1) then pure () else error \"assertion failed\"\n  if candidate [1,3,2,4,5,6,(-2)] == ((-2), 1) then pure () else error \"assertion failed\"\n  if candidate [4,5,3,6,2,7,(-7)] == ((-7), 2) then pure () else error \"assertion failed\"\n  if candidate [7,3,8,4,9,2,5,(-9)] == ((-9), 2) then pure () else error \"assertion failed\"\n  if candidate [] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [0] == (Nothing, Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6)] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),(-5),(-6),0] == ((-1), Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  if candidate [(-6),(-4),(-4),(-3),(-100),1] == ((-3), 1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_138_is_equal_to_sum_even", "language": "hs", "prompt": "-- | Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n--  Example\n--  >>> isEqualToSumEven 4\n--  False\n--  >>> isEqualToSumEven 6\n--  False\n--  >>> isEqualToSumEven 8\n--  True\nisEqualToSumEven :: Int -> Bool\nisEqualToSumEven n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_138_is_equal_to_sum_even.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isEqualToSumEven\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == True then pure () else error \"assertion failed\"\n  if candidate 11 == False then pure () else error \"assertion failed\"\n  if candidate 12 == True then pure () else error \"assertion failed\"\n  if candidate 13 == False then pure () else error \"assertion failed\"\n  if candidate 16 == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_139_special_factorial", "language": "hs", "prompt": "-- | The Brazilian factorial is defined as:\n--  brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n--  where n > 0\n--  For example:\n--  >>> specialFactorial 4\n--  288\n--  The function will receive an integer as input and should return the special\n--  factorial of this integer.\nspecialFactorial :: Int -> Int\nspecialFactorial n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_139_special_factorial.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = specialFactorial\n  if candidate 4 == 288 then pure () else error \"assertion failed\"\n  if candidate 5 == 34560 then pure () else error \"assertion failed\"\n  if candidate 7 == 125411328000 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_13_greatest_common_divisor", "language": "hs", "prompt": "-- | Return a greatest common divisor of two integers a and b\n--  >>> greatestCommonDivisor 3 5\n--  1\n--  >>> greatestCommonDivisor 25 15\n--  5\ngreatestCommonDivisor :: Int -> Int -> Int\ngreatestCommonDivisor a b =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_13_greatest_common_divisor.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = greatestCommonDivisor\n  if candidate 3 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 49 14 == 7 then pure () else error \"assertion failed\"\n  if candidate 144 60 == 12 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_140_fix_spaces", "language": "hs", "prompt": "-- | Given a string text, replace all spaces in it with underscores, \n--  and if a string has more than 2 consecutive spaces, \n--  then replace all consecutive spaces with - \n--  >>> fixSpaces \" Example\"\n--  \"Example\"\n--  >>> fixSpaces \" Example 1\"\n--  \"Example_1\"\n--  >>> fixSpaces \" Example 2\"\n--  \"_Example_2\"\n--  >>> fixSpaces \" Example 3\"\n--  \"_Example-3\"\nfixSpaces :: String -> String\nfixSpaces text =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_140_fix_spaces.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fixSpaces\n  if candidate \"Example\" == \"Example\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir Hanif \" == \"Mudasir_Hanif_\" then pure () else error \"assertion failed\"\n  if candidate \"Yellow Yellow  Dirty  Fellow\" == \"Yellow_Yellow__Dirty__Fellow\" then pure () else error \"assertion failed\"\n  if candidate \"Exa   mple\" == \"Exa-mple\" then pure () else error \"assertion failed\"\n  if candidate \"   Exa 1 2 2 mple\" == \"-Exa_1_2_2_mple\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_141_file_name_check", "language": "hs", "prompt": "-- | Create a function which takes a string representing a file's name, and returns\n--  'Yes' if the the file's name is valid, and returns 'No' otherwise.\n--  A file's name is considered to be valid if and only if all the following conditions \n--  are met:\n--  - There should not be more than three digits ('0'-'9') in the file's name.\n--  - The file's name contains exactly one dot '.'\n--  - The substring before the dot should not be empty, and it starts with a letter from \n--  the latin alphapet ('a'-'z' and 'A'-'Z').\n--  - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n--  Examples:\n--  >>> fileNameCheck \"example.txt\"\n--  \"Yes\"\n--  >>> fileNameCheck \"1example.dll\"\n--  \"No\"\nfileNameCheck :: String -> String\nfileNameCheck file_name =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_141_file_name_check.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fileNameCheck\n  if candidate \"example.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1example.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s1sdf3.asd\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"K.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"MY16FILE3.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"His12FILE94.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_Y.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"?aREYA.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"/this_is_valid.dll\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.wow\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_valid.txtexe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"#this2_i4s_5valid.ten\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"@this1_is6_valid.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"this_is_12valid.6exe4.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"all.exe.txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_No.exe\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"Is3youfault.txt\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"no_one#knows.dll\" == \"Yes\" then pure () else error \"assertion failed\"\n  if candidate \"1I563_Yes3.exe\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"I563_Yes3.txtt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final..txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"final132\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"_f4indsartal132.\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \".txt\" == \"No\" then pure () else error \"assertion failed\"\n  if candidate \"s.\" == \"No\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_142_sum_squares", "language": "hs", "prompt": "-- | \"\n--  This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n--  multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n--  change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n--  Examples:\n--  >>> lst\n--  [1,2,3]\n--  >>> lst\n--  []\n--  >>> lst\n--  [(-1),(-5),2,(-1),(-5)]\nsumSquares :: [Int] -> Int\nsumSquares lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_142_sum_squares.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sumSquares\n  if candidate [1,2,3] == 6 then pure () else error \"assertion failed\"\n  if candidate [1,4,9] == 14 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,1,1,1,1,1] == 9 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1),(-1)] == (-3) then pure () else error \"assertion failed\"\n  if candidate [0] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-1),(-5),2,(-1),(-5)] == (-126) then pure () else error \"assertion failed\"\n  if candidate [(-56),(-99),1,0,(-2)] == 3030 then pure () else error \"assertion failed\"\n  if candidate [(-1),0,0,0,0,0,0,0,(-1)] == 0 then pure () else error \"assertion failed\"\n  if candidate [(-16),(-9),(-2),36,36,26,(-20),25,(-40),20,(-4),12,(-26),35,37] == (-14196) then pure () else error \"assertion failed\"\n  if candidate [(-1),(-3),17,(-1),(-15),13,(-1),14,(-14),(-12),(-5),14,(-14),6,13,11,16,16,4,10] == (-1448) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_143_words_in_sentence", "language": "hs", "prompt": "-- | You are given a string representing a sentence,\n--  the sentence contains some words separated by a space,\n--  and you have to return a string that contains the words from the original sentence,\n--  whose lengths are prime numbers,\n--  the order of the words in the new string should be the same as the original one.\n--  Example 1:\n--  >>> wordsInSentence \"This is a test\"\n--  \"is\"\n--  Example 2:\n--  >>> wordsInSentence \"lets go for swimming\"\n--  \"go for\"\n--  Constraints:\n--  * 1 <= len(sentence) <= 100\n--  * sentence contains only letters\nwordsInSentence :: String -> String\nwordsInSentence sentence =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_143_words_in_sentence.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = wordsInSentence\n  if candidate \"This is a test\" == \"is\" then pure () else error \"assertion failed\"\n  if candidate \"lets go for swimming\" == \"go for\" then pure () else error \"assertion failed\"\n  if candidate \"there is no place available here\" == \"there is no place\" then pure () else error \"assertion failed\"\n  if candidate \"Hi I am Hussein\" == \"Hi am Hussein\" then pure () else error \"assertion failed\"\n  if candidate \"go for it\" == \"go for it\" then pure () else error \"assertion failed\"\n  if candidate \"here\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"here is\" == \"is\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_144_simplify", "language": "hs", "prompt": "-- | Your task is to implement a function that will simplify the expression\n--  x * n. The function returns True if x * n evaluates to a whole number and False\n--  otherwise. Both x and n, are string representation of a fraction, and have the following format,\n--  <numerator>/<denominator> where both numerator and denominator are positive whole numbers.\n--  You can assume that x, and n are valid fractions, and do not have zero as denominator.\n--  >>> simplify \"1/5\" \"5/1\"\n--  True\n--  >>> simplify \"1/6\" \"2/1\"\n--  False\n--  >>> simplify \"7/10\" \"10/2\"\n--  False\nsimplify :: String -> String -> Bool\nsimplify x n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_144_simplify.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = simplify\n  if candidate \"1/5\" \"5/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1/6\" \"2/1\" == False then pure () else error \"assertion failed\"\n  if candidate \"5/1\" \"3/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"7/10\" \"10/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"2/10\" \"50/10\" == True then pure () else error \"assertion failed\"\n  if candidate \"7/2\" \"4/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"11/6\" \"6/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"2/3\" \"5/2\" == False then pure () else error \"assertion failed\"\n  if candidate \"5/2\" \"3/5\" == False then pure () else error \"assertion failed\"\n  if candidate \"2/4\" \"8/4\" == True then pure () else error \"assertion failed\"\n  if candidate \"2/4\" \"4/2\" == True then pure () else error \"assertion failed\"\n  if candidate \"1/5\" \"5/1\" == True then pure () else error \"assertion failed\"\n  if candidate \"1/5\" \"1/5\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_145_order_by_points", "language": "hs", "prompt": "-- | Write a function which sorts the given list of integers\n--  in ascending order according to the sum of their digits.\n--  Note: if there are several items with similar sum of their digits,\n--  order them based on their index in original list.\n--  For example:\n--  >>> orderByPoints [1,11,(-1),(-11),(-12)]\n--  [(-1),(-11),1,(-12),11]\n--  >>> orderByPoints []\n--  []\norderByPoints :: [Int] -> [Int]\norderByPoints nums =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_145_order_by_points.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = orderByPoints\n  if candidate [1,11,(-1),(-11),(-12)] == [(-1),(-11),1,(-12),11] then pure () else error \"assertion failed\"\n  if candidate [1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46] == [0,2,3,6,53,423,423,423,1234,145,37,46,56,463,3457] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,(-11),(-32),43,54,(-98),2,(-3)] == [(-3),(-32),(-98),(-11),1,2,43,54] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8,9,10,11] == [1,10,2,11,3,4,5,6,7,8,9] then pure () else error \"assertion failed\"\n  if candidate [0,6,6,(-76),(-21),23,4] == [(-76),(-21),0,4,23,6,6] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_146_specialFilter", "language": "hs", "prompt": "-- | Write a function that takes an array of numbers as input and returns \n--  the number of elements in the array that are greater than 10 and both \n--  first and last digits of a number are odd (1, 3, 5, 7, 9).\n--  For example:\n--  >>> specialfilter [15,(-73),14,(-15)]\n--  1\n--  >>> specialfilter [33,(-2),(-3),45,21,109]\n--  2\nspecialfilter :: [Int] -> Int\nspecialfilter nums =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_146_specialFilter.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = specialfilter\n  if candidate [5,(-2),1,(-5)] == 0 then pure () else error \"assertion failed\"\n  if candidate [15,(-73),14,(-15)] == 1 then pure () else error \"assertion failed\"\n  if candidate [33,(-2),(-3),45,21,109] == 2 then pure () else error \"assertion failed\"\n  if candidate [43,(-12),93,125,121,109] == 4 then pure () else error \"assertion failed\"\n  if candidate [71,(-2),(-33),75,21,19] == 3 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [] == 0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_147_get_max_triples", "language": "hs", "prompt": "-- | You are given a positive integer n. You have to create an integer array a of length n.\n--  For each i (1 \u00e2\u2030\u00a4 i \u00e2\u2030\u00a4 n), the value of a[i] = i * i - i + 1.\n--  Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n--  and a[i] + a[j] + a[k] is a multiple of 3.\n--  Example :\n--  >>> getMaxTriples 5\n--  1\n--  Explanation: \n--  a = [1, 3, 7, 13, 21]\n--  The only valid triple is (1, 7, 13).\ngetMaxTriples :: Int -> Int\ngetMaxTriples n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_147_get_max_triples.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = getMaxTriples\n  if candidate 5 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 4 then pure () else error \"assertion failed\"\n  if candidate 10 == 36 then pure () else error \"assertion failed\"\n  if candidate 100 == 53361 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_149_sorted_list_sum", "language": "hs", "prompt": "-- | Write a function that accepts a list of strings as a parameter,\n--  deletes the strings that have odd lengths from it,\n--  and returns the resulted list with a sorted order,\n--  The list is always a list of strings and never an array of numbers,\n--  and it may contain duplicates.\n--  The order of the list should be ascending by length of each word, and you\n--  should return the list sorted by that rule.\n--  If two words have the same length, sort the list alphabetically.\n--  The function should return a list of strings in sorted order.\n--  You may assume that all words will have the same length.\n--  For example:\n--  >>> listSort [\"aa\",\"a\",\"aaa\"]\n--  [\"aa\"]\n--  >>> listSort [\"ab\",\"a\",\"aaa\",\"cd\"]\n--  [\"ab\",\"cd\"]\nsortedListSum :: [String] -> [String]\nsortedListSum lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_149_sorted_list_sum.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortedListSum\n  if candidate [\"aa\",\"a\",\"aaa\"] == [\"aa\"] then pure () else error \"assertion failed\"\n  if candidate [\"school\",\"AI\",\"asdf\",\"b\"] == [\"AI\",\"asdf\",\"school\"] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"b\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"d\",\"dcba\",\"abcd\",\"a\"] == [\"abcd\",\"dcba\"] then pure () else error \"assertion failed\"\n  if candidate [\"AI\",\"ai\",\"au\"] == [\"AI\",\"ai\",\"au\"] then pure () else error \"assertion failed\"\n  if candidate [\"a\",\"b\",\"b\",\"c\",\"c\",\"a\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"aaaa\",\"bbbb\",\"dd\",\"cc\"] == [\"cc\",\"dd\",\"aaaa\",\"bbbb\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_14_all_prefixes", "language": "hs", "prompt": "-- | Return list of all prefixes from shortest to longest of the input string\n--  >>> allPrefixes \"abc\"\n--  [\"a\",\"ab\",\"abc\"]\nallPrefixes :: String -> [String]\nallPrefixes string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_14_all_prefixes.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = allPrefixes\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"asdfgh\" == [\"a\",\"as\",\"asd\",\"asdf\",\"asdfg\",\"asdfgh\"] then pure () else error \"assertion failed\"\n  if candidate \"WWW\" == [\"W\",\"WW\",\"WWW\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_150_x_or_y", "language": "hs", "prompt": "-- | A simple program which should return the value of x if n is \n--  a prime number and should return the value of y otherwise.\n--  Examples:\n--  >>> xOrY 7 34 12\n--  34\n--  >>> xOrY 15 8 5\n--  5\nxOrY :: Int -> Int -> Int -> Int\nxOrY n x y =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_150_x_or_y.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = xOrY\n  if candidate 7 34 12 == 34 then pure () else error \"assertion failed\"\n  if candidate 15 8 5 == 5 then pure () else error \"assertion failed\"\n  if candidate 3 33 5212 == 33 then pure () else error \"assertion failed\"\n  if candidate 1259 3 52 == 3 then pure () else error \"assertion failed\"\n  if candidate 7919 (-1) 12 == (-1) then pure () else error \"assertion failed\"\n  if candidate 3609 1245 583 == 583 then pure () else error \"assertion failed\"\n  if candidate 91 56 129 == 129 then pure () else error \"assertion failed\"\n  if candidate 6 34 1234 == 1234 then pure () else error \"assertion failed\"\n  if candidate 1 2 0 == 0 then pure () else error \"assertion failed\"\n  if candidate 2 2 0 == 2 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_151_double_the_difference", "language": "hs", "prompt": "-- | Given a list of numbers, return the sum of squares of the numbers\n--  in the list that are odd. Ignore numbers that are negative or not integers.\n--  >>> doubleTheDifference [1,3,2,0]\n--  10\n--  >>> doubleTheDifference [(-1),(-2),0]\n--  0\n--  >>> doubleTheDifference [9,(-2)]\n--  81\n--  >>> doubleTheDifference [0]\n--  0\n--  If the input list is empty, return 0.\ndoubleTheDifference :: [Float] -> Int\ndoubleTheDifference lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_151_double_the_difference.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = doubleTheDifference\n  if candidate [.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [5.0,4.0] == 25 then pure () else error \"assertion failed\"\n  if candidate [0.1,0.2,0.3] == 0 then pure () else error \"assertion failed\"\n  if candidate [-10.0,-20.0,-30.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [-1.0,-2.0,8.0] == 0 then pure () else error \"assertion failed\"\n  if candidate [0.2,3.0,5.0] == 34 then pure () else error \"assertion failed\"\n  if candidate [-9.0,-7.0,-5.0,-3.0,-1.0,1.0,3.0,5.0,7.0,9.0] == 165 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_152_compare", "language": "hs", "prompt": "-- | I think we all remember that feeling when the result of some long-awaited\n--  event is finally known. The feelings and thoughts you have at that moment are\n--  definitely worth noting down and comparing.\n--  Your task is to determine if a person correctly guessed the results of a number of matches.\n--  You are given two arrays of scores and guesses of equal length, where each index shows a match. \n--  Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n--  the value is 0, and if not, the value is the absolute difference between the guess and the score.\n--  example:\n--  >>> compare [1,2,3,4,5,1] [1,2,3,4,2,(-2)]\n--  [0,0,0,0,3,3]\n--  >>> compare [0,5,0,0,0,4] [4,1,1,0,0,(-2)]\n--  [4,4,1,0,0,6]\ncompare :: [Int] -> [Int] -> [Int]\ncompare game guess =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_152_compare.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = compare\n  if candidate [1,2,3,4,5,1] [1,2,3,4,2,(-2)] == [0,0,0,0,3,3] then pure () else error \"assertion failed\"\n  if candidate [0,0,0,0,0,0] [0,0,0,0,0,0] == [0,0,0,0,0,0] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] [(-1),(-2),(-3)] == [2,4,6] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,5] [(-1),2,3,4] == [2,0,0,1] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_153_Strongest_Extension", "language": "hs", "prompt": "-- | You will be given the name of a class (a string) and a list of extensions.\n--  The extensions are to be used to load additional classes to the class. The\n--  strength of the extension is as follows: Let CAP be the number of the uppercase\n--  letters in the extension's name, and let SM be the number of lowercase letters \n--  in the extension's name, the strength is given by the fraction CAP - SM. \n--  You should find the strongest extension and return a string in this \n--  format: ClassName.StrongestExtensionName.\n--  If there are two or more extensions with the same strength, you should\n--  choose the one that comes first in the list.\n--  For example, if you are given \"Slices\" as the class and a list of the\n--  extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n--  return 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n--  (its strength is -1).\n--  Example:\n--  >>> strongestExtension \"my_class\" [\"AA\",\"Be\",\"CC\"]\n--  \"my_class.AA\"\nstrongestExtension :: String -> [String] -> String\nstrongestExtension class_name extensions =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_153_Strongest_Extension.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = strongestExtension\n  if candidate \"Watashi\" [\"tEN\",\"niNE\",\"eIGHt8OKe\"] == \"Watashi.eIGHt8OKe\" then pure () else error \"assertion failed\"\n  if candidate \"Boku123\" [\"nani\",\"NazeDa\",\"YEs.WeCaNe\",\"32145tggg\"] == \"Boku123.YEs.WeCaNe\" then pure () else error \"assertion failed\"\n  if candidate \"__YESIMHERE\" [\"t\",\"eMptY\",\"nothing\",\"zeR00\",\"NuLl__\",\"123NoooneB321\"] == \"__YESIMHERE.NuLl__\" then pure () else error \"assertion failed\"\n  if candidate \"K\" [\"Ta\",\"TAR\",\"t234An\",\"cosSo\"] == \"K.TAR\" then pure () else error \"assertion failed\"\n  if candidate \"__HAHA\" [\"Tab\",\"123\",\"781345\",\"-_-\"] == \"__HAHA.123\" then pure () else error \"assertion failed\"\n  if candidate \"YameRore\" [\"HhAas\",\"okIWILL123\",\"WorkOut\",\"Fails\",\"-_-\"] == \"YameRore.okIWILL123\" then pure () else error \"assertion failed\"\n  if candidate \"finNNalLLly\" [\"Die\",\"NowW\",\"Wow\",\"WoW\"] == \"finNNalLLly.WoW\" then pure () else error \"assertion failed\"\n  if candidate \"_\" [\"Bb\",\"91245\"] == \"_.Bb\" then pure () else error \"assertion failed\"\n  if candidate \"Sp\" [\"671235\",\"Bb\"] == \"Sp.671235\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_154_cycpattern_check", "language": "hs", "prompt": "-- | You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n--  >>> cycpatternCheck \"abcd\" \"abd\"\n--  False\n--  >>> cycpatternCheck \"hello\" \"ell\"\n--  True\n--  >>> cycpatternCheck \"whassup\" \"psus\"\n--  False\n--  >>> cycpatternCheck \"abab\" \"baa\"\n--  True\n--  >>> cycpatternCheck \"efef\" \"eeff\"\n--  False\n--  >>> cycpatternCheck \"himenss\" \"simen\"\n--  True\ncycpatternCheck :: String -> String -> Bool\ncycpatternCheck a b =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_154_cycpattern_check.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = cycpatternCheck\n  if candidate \"xyzw\" \"xyw\" == False then pure () else error \"assertion failed\"\n  if candidate \"yello\" \"ell\" == True then pure () else error \"assertion failed\"\n  if candidate \"whattup\" \"ptut\" == False then pure () else error \"assertion failed\"\n  if candidate \"efef\" \"fee\" == True then pure () else error \"assertion failed\"\n  if candidate \"abab\" \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"winemtt\" \"tinem\" == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_155_even_odd_count", "language": "hs", "prompt": "-- | Given an integer. return a tuple that has the number of even and odd digits respectively.\n--  Example:\n--  >>> evenOddCount (-12)\n--  (1, 1)\n--  >>> evenOddCount 123\n--  (1, 2)\nevenOddCount :: Int -> (Int, Int)\nevenOddCount num =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_155_even_odd_count.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = evenOddCount\n  if candidate 7 == (0, 1) then pure () else error \"assertion failed\"\n  if candidate (-78) == (1, 1) then pure () else error \"assertion failed\"\n  if candidate 3452 == (2, 2) then pure () else error \"assertion failed\"\n  if candidate 346211 == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-345821) == (3, 3) then pure () else error \"assertion failed\"\n  if candidate (-2) == (1, 0) then pure () else error \"assertion failed\"\n  if candidate (-45347) == (2, 3) then pure () else error \"assertion failed\"\n  if candidate 0 == (1, 0) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_156_int_to_mini_roman", "language": "hs", "prompt": "-- | Given a positive integer, obtain its roman numeral equivalent as a string,\n--  and return it in lowercase.\n--  Restrictions: 1 <= num <= 1000\n--  Examples:\n--  >>> intToMiniRoman 19\n--  \"xix\"\n--  >>> intToMiniRoman 152\n--  \"clii\"\n--  >>> intToMiniRoman 426\n--  \"cdxxvi\"\nintToMiniRoman :: Int -> String\nintToMiniRoman number =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_156_int_to_mini_roman.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = intToMiniRoman\n  if candidate 19 == \"xix\" then pure () else error \"assertion failed\"\n  if candidate 152 == \"clii\" then pure () else error \"assertion failed\"\n  if candidate 251 == \"ccli\" then pure () else error \"assertion failed\"\n  if candidate 426 == \"cdxxvi\" then pure () else error \"assertion failed\"\n  if candidate 500 == \"d\" then pure () else error \"assertion failed\"\n  if candidate 1 == \"i\" then pure () else error \"assertion failed\"\n  if candidate 4 == \"iv\" then pure () else error \"assertion failed\"\n  if candidate 43 == \"xliii\" then pure () else error \"assertion failed\"\n  if candidate 90 == \"xc\" then pure () else error \"assertion failed\"\n  if candidate 94 == \"xciv\" then pure () else error \"assertion failed\"\n  if candidate 532 == \"dxxxii\" then pure () else error \"assertion failed\"\n  if candidate 900 == \"cm\" then pure () else error \"assertion failed\"\n  if candidate 994 == \"cmxciv\" then pure () else error \"assertion failed\"\n  if candidate 1000 == \"m\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_157_right_angle_triangle", "language": "hs", "prompt": "-- | Given the lengths of the three sides of a triangle. Return True if the three\n--  sides form a right-angled triangle, False otherwise.\n--  A right-angled triangle is a triangle in which one angle is right angle or \n--  90 degree.\n--  Example:\n--  >>> rightAngleTriangle 3 4 5\n--  True\n--  >>> rightAngleTriangle 1 2 3\n--  False\nrightAngleTriangle :: Int -> Int -> Int -> Bool\nrightAngleTriangle a b c =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_157_right_angle_triangle.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = rightAngleTriangle\n  if candidate 3 4 5 == True then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == False then pure () else error \"assertion failed\"\n  if candidate 10 6 8 == True then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == False then pure () else error \"assertion failed\"\n  if candidate 7 24 25 == True then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == False then pure () else error \"assertion failed\"\n  if candidate 5 12 13 == True then pure () else error \"assertion failed\"\n  if candidate 15 8 17 == True then pure () else error \"assertion failed\"\n  if candidate 48 55 73 == True then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == False then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_158_find_max", "language": "hs", "prompt": "-- | Write a function that accepts a list of strings.\n--  The list contains different words. Return the word with maximum number\n--  of unique characters. If multiple strings have maximum number of unique\n--  characters, return the one which comes first in lexicographical order.\n--  >>> findMax [\"name\",\"of\",\"string\"]\n--  \"string\"\n--  >>> findMax [\"name\",\"enam\",\"game\"]\n--  \"enam\"\n--  >>> findMax [\"aaaaaaa\",\"bb\",\"cc\"]\n--  \"aaaaaaa\"\nfindMax :: [String] -> String\nfindMax words =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_158_find_max.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = findMax\n  if candidate [\"name\",\"of\",\"string\"] == \"string\" then pure () else error \"assertion failed\"\n  if candidate [\"name\",\"enam\",\"game\"] == \"enam\" then pure () else error \"assertion failed\"\n  if candidate [\"aaaaaaa\",\"bb\",\"cc\"] == \"aaaaaaa\" then pure () else error \"assertion failed\"\n  if candidate [\"abc\",\"cba\"] == \"abc\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"this\",\"game\",\"of\",\"footbott\"] == \"footbott\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"gonna\",\"rock\"] == \"gonna\" then pure () else error \"assertion failed\"\n  if candidate [\"we\",\"are\",\"a\",\"mad\",\"nation\"] == \"nation\" then pure () else error \"assertion failed\"\n  if candidate [\"this\",\"is\",\"a\",\"prrk\"] == \"this\" then pure () else error \"assertion failed\"\n  if candidate [\"b\"] == \"b\" then pure () else error \"assertion failed\"\n  if candidate [\"play\",\"play\",\"play\"] == \"play\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_159_eat", "language": "hs", "prompt": "-- | You're a hungry rabbit, and you already have eaten a certain number of carrots,\n--  but now you need to eat more carrots to complete the day's meals.\n--  you should return an array of [ total number of eaten carrots after your meals,\n--  the number of carrots left after your meals ]\n--  if there are not enough remaining carrots, you will eat all remaining carrots, but will still be hungry.\n--  Example:\n--  >>> eat 5 6 10\n--  [11,4]\n--  >>> eat 4 8 9\n--  [12,1]\n--  >>> eat 1 10 10\n--  [11,0]\n--  >>> eat 2 11 5\n--  [7,0]\n--  Variables:\n--  @number : integer\n--  the number of carrots that you have eaten.\n--  @need : integer\n--  the number of carrots that you need to eat.\n--  @remaining : integer\n--  the number of remaining carrots thet exist in stock\n--  Constrain:\n--  * 0 <= number <= 1000\n--  * 0 <= need <= 1000\n--  * 0 <= remaining <= 1000\n--  Have fun :)\neat :: Int -> Int -> Int -> [Int]\neat number need remaining =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_159_eat.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = eat\n  if candidate 5 6 10 == [11,4] then pure () else error \"assertion failed\"\n  if candidate 4 8 9 == [12,1] then pure () else error \"assertion failed\"\n  if candidate 1 10 10 == [11,0] then pure () else error \"assertion failed\"\n  if candidate 2 11 5 == [7,0] then pure () else error \"assertion failed\"\n  if candidate 4 5 7 == [9,2] then pure () else error \"assertion failed\"\n  if candidate 4 5 1 == [5,0] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_15_string_sequence", "language": "hs", "prompt": "-- | Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n--  >>> stringSequence 0\n--  \"0\"\n--  >>> stringSequence 5\n--  \"0 1 2 3 4 5\"\nstringSequence :: Int -> String\nstringSequence n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_15_string_sequence.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = stringSequence\n  if candidate 0 == \"0\" then pure () else error \"assertion failed\"\n  if candidate 3 == \"0 1 2 3\" then pure () else error \"assertion failed\"\n  if candidate 10 == \"0 1 2 3 4 5 6 7 8 9 10\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_160_do_algebra", "language": "hs", "prompt": "-- | Given two lists operator, and operand. The first list has basic algebra operations, and \n--  the second list is a list of integers. Use the two given lists to build the algebric \n--  expression and return the evaluation of this expression.\n--  The basic algebra operations:\n--  Addition ( + ) \n--  Subtraction ( - ) \n--  Multiplication ( * ) \n--  Floor division ( // ) \n--  Exponentiation ( ** ) \n--  Example:\n--  operator['+', '*', '-']\n--  array = [2, 3, 4, 5]\n--  result = 2 + 3 * 4 - 5\n--  => result = 9\n--  Note:\n--  The length of operator list is equal to the length of operand list minus one.\n--  Operand is a list of of non-negative integers.\n--  Operator list has at least one operator, and operand list has at least two operands.\ndoAlgebra :: [String] -> [Int] -> Int\ndoAlgebra operator operand =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_160_do_algebra.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = doAlgebra\n  if candidate [\"**\",\"*\",\"+\"] [2,3,4,5] == 37 then pure () else error \"assertion failed\"\n  if candidate [\"+\",\"*\",\"-\"] [2,3,4,5] == 9 then pure () else error \"assertion failed\"\n  if candidate [\"//\",\"*\"] [7,3,4] == 8 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_161_solve", "language": "hs", "prompt": "-- | You are given a string s.\n--  if s[i] is a letter, reverse its case from lower to upper or vise versa, \n--  otherwise keep it as it is.\n--  If the string contains no letters, reverse the string.\n--  The function should return the resulted string.\n--  Examples\n--  >>> solve \"1234\"\n--  \"4321\"\n--  >>> solve \"ab\"\n--  \"AB\"\n--  >>> solve \"#a@C\"\n--  \"#A@c\"\nsolve :: String -> String\nsolve s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_161_solve.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate \"AsDf\" == \"aSdF\" then pure () else error \"assertion failed\"\n  if candidate \"1234\" == \"4321\" then pure () else error \"assertion failed\"\n  if candidate \"ab\" == \"AB\" then pure () else error \"assertion failed\"\n  if candidate \"#a@C\" == \"#A@c\" then pure () else error \"assertion failed\"\n  if candidate \"#AsdfW^45\" == \"#aSDFw^45\" then pure () else error \"assertion failed\"\n  if candidate \"#6@2\" == \"2@6#\" then pure () else error \"assertion failed\"\n  if candidate \"#$a^D\" == \"#$A^d\" then pure () else error \"assertion failed\"\n  if candidate \"#ccc\" == \"#CCC\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_162_string_to_md5", "language": "hs", "prompt": "-- | Given a string 'text', return its md5 hash equivalent string.\n--  If 'text' is an empty string, return None.\n--  >>> stringToMd5 \"Hello world\"\n--  Just (\"3e25960a79dbc69b674cd4ec67a72c62\")\nstringToMd5 :: String -> Maybe String\nstringToMd5 text =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_162_string_to_md5.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = stringToMd5\n  if candidate \"Hello world\" == Just (\"3e25960a79dbc69b674cd4ec67a72c62\") then pure () else error \"assertion failed\"\n  if candidate \"\" == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate \"A B C\" == Just (\"0ef78513b0cb8cef12743f5aeb35f888\") then pure () else error \"assertion failed\"\n  if candidate \"password\" == Just (\"5f4dcc3b5aa765d61d8327deb882cf99\") then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_163_generate_integers", "language": "hs", "prompt": "-- | Given two positive integers a and b, return the even digits between a\n--  and b, in ascending order.\n--  For example:\n--  >>> generateIntegers 2 8\n--  [2,4,6,8]\n--  >>> generateIntegers 8 2\n--  [2,4,6,8]\n--  >>> generateIntegers 10 14\n--  []\ngenerateIntegers :: Int -> Int -> [Int]\ngenerateIntegers a b =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_163_generate_integers.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = generateIntegers\n  if candidate 2 10 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 10 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 132 2 == [2,4,6,8] then pure () else error \"assertion failed\"\n  if candidate 17 89 == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_16_count_distinct_characters", "language": "hs", "prompt": "-- | Given a string, find out how many distinct characters (regardless of case) does it consist of\n--  >>> countDistinctCharacters \"xyzXYZ\"\n--  3\n--  >>> countDistinctCharacters \"Jerry\"\n--  4\ncountDistinctCharacters :: String -> Int\ncountDistinctCharacters string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_16_count_distinct_characters.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = countDistinctCharacters\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abcde\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"abcdecadeCADE\" == 5 then pure () else error \"assertion failed\"\n  if candidate \"aaaaAAAAaaaa\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"Jerry jERRY JeRRRY\" == 5 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_17_parse_music", "language": "hs", "prompt": "-- | Input to this function is a string representing musical notes in a special ASCII format.\n--  Your task is to parse this string and return list of integers corresponding to how many beats does each\n--  not last.\n--  Here is a legend:\n--  'o' - whole note, lasts four beats\n--  'o|' - half note, lasts two beats\n--  '.|' - quater note, lasts one beat\n--  >>> parseMusic \"o o| .| o| o| .| .| .| .| o o\"\n--  [4,2,1,2,2,1,1,1,1,4,4]\nparseMusic :: String -> [Int]\nparseMusic music_string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_17_parse_music.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = parseMusic\n  if candidate \"\" == [] then pure () else error \"assertion failed\"\n  if candidate \"o o o o\" == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \".| .| .| .|\" == [1,1,1,1] then pure () else error \"assertion failed\"\n  if candidate \"o| o| .| .| o o o o\" == [2,2,1,1,4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate \"o| .| o| .| o o| o o|\" == [2,1,2,1,4,2,4,2] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_18_how_many_times", "language": "hs", "prompt": "-- | Find how many times a given substring can be found in the original string. Count overlaping cases.\n--  >>> howManyTimes \"\" \"a\"\n--  0\n--  >>> howManyTimes \"aaa\" \"a\"\n--  3\n--  >>> howManyTimes \"aaaa\" \"aa\"\n--  3\nhowManyTimes :: String -> String -> Int\nhowManyTimes string substring =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_18_how_many_times.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = howManyTimes\n  if candidate \"\" \"x\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"xyxyxyx\" \"x\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"cacacacac\" \"cac\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"john doe\" \"john\" == 1 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_19_sort_numbers", "language": "hs", "prompt": "-- | Input is a space-delimited string of numberals from 'zero' to 'nine'.\n--  Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n--  Return the string with numbers sorted from smallest to largest\n--  >>> sortNumbers \"three one five\"\n--  \"one three five\"\nsortNumbers :: String -> String\nsortNumbers numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_19_sort_numbers.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortNumbers\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"three\" == \"three\" then pure () else error \"assertion failed\"\n  if candidate \"three five nine\" == \"three five nine\" then pure () else error \"assertion failed\"\n  if candidate \"five zero four seven nine eight\" == \"zero four five seven eight nine\" then pure () else error \"assertion failed\"\n  if candidate \"six five four three two one zero\" == \"zero one two three four five six\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_1_separate_paren_groups", "language": "hs", "prompt": "-- | Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n--  separate those group into separate strings and return the list of those.\n--  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n--  Ignore any spaces in the input string.\n--  >>> separateParenGroups \"( ) (( )) (( )( ))\"\n--  [\"()\",\"(())\",\"(()())\"]\nseparateParenGroups :: String -> [String]\nseparateParenGroups paren_string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_1_separate_paren_groups.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = separateParenGroups\n  if candidate \"(()()) ((())) () ((())()())\" == [\"(()())\",\"((()))\",\"()\",\"((())()())\"] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [\"()\",\"(())\",\"((()))\",\"(((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [\"(()(())((())))\"] then pure () else error \"assertion failed\"\n  if candidate \"( ) (( )) (( )( ))\" == [\"()\",\"(())\",\"(()())\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_20_find_closest_elements", "language": "hs", "prompt": "-- | From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n--  other and return them in order (smaller number, larger number).\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.2]\n--  (2.0, 2.2)\n--  >>> findClosestElements [1.0,2.0,3.0,4.0,5.0,2.0]\n--  (2.0, 2.0)\nfindClosestElements :: [Float] -> (Float, Float)\nfindClosestElements numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_20_find_closest_elements.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = findClosestElements\n  if candidate [1.0,2.0,3.9,4.0,5.0,2.2] == (3.9, 4.0) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,5.9,4.0,5.0] == (5.0, 5.9) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.2] == (2.0, 2.2) then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0,2.0] == (2.0, 2.0) then pure () else error \"assertion failed\"\n  if candidate [1.1,2.2,3.1,4.1,5.1] == (2.2, 3.1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_21_rescale_to_unit", "language": "hs", "prompt": "-- | Given list of numbers (of at least two elements), apply a linear transform to that list,\n--  such that the smallest number will become 0 and the largest will become 1\n--  >>> rescaleToUnit [1.0,2.0,3.0,4.0,5.0]\n--  [0.0,0.25,0.5,0.75,1.0]\nrescaleToUnit :: [Float] -> [Float]\nrescaleToUnit numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_21_rescale_to_unit.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = rescaleToUnit\n  if candidate [2.0,49.9] == [0.0,1.0] then pure () else error \"assertion failed\"\n  if candidate [100.0,49.9] == [1.0,0.0] then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == [0.0,0.25,0.5,0.75,1.0] then pure () else error \"assertion failed\"\n  if candidate [2.0,1.0,5.0,3.0,4.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  if candidate [12.0,11.0,15.0,13.0,14.0] == [0.25,0.0,1.0,0.5,0.75] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_23_strlen", "language": "hs", "prompt": "-- | Return length of given string\n--  >>> strlen \"\"\n--  0\n--  >>> strlen \"abc\"\n--  3\nstrlen :: String -> Int\nstrlen string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_23_strlen.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = strlen\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"x\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"asdasnakj\" == 9 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_24_largest_divisor", "language": "hs", "prompt": "-- | For a given number n, find the largest number that divides n evenly, smaller than n\n--  >>> largestDivisor 15\n--  5\nlargestDivisor :: Int -> Int\nlargestDivisor n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_24_largest_divisor.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = largestDivisor\n  if candidate 3 == 1 then pure () else error \"assertion failed\"\n  if candidate 7 == 1 then pure () else error \"assertion failed\"\n  if candidate 10 == 5 then pure () else error \"assertion failed\"\n  if candidate 100 == 50 then pure () else error \"assertion failed\"\n  if candidate 49 == 7 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_25_factorize", "language": "hs", "prompt": "-- | Return list of prime factors of given integer in the order from smallest to largest.\n--  Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n--  Input number should be equal to the product of all factors\n--  >>> factorize 8\n--  [2,2,2]\n--  >>> factorize 25\n--  [5,5]\n--  >>> factorize 70\n--  [2,5,7]\nfactorize :: Int -> [Int]\nfactorize n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_25_factorize.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = factorize\n  if candidate 2 == [2] then pure () else error \"assertion failed\"\n  if candidate 4 == [2,2] then pure () else error \"assertion failed\"\n  if candidate 8 == [2,2,2] then pure () else error \"assertion failed\"\n  if candidate 57 == [3,19] then pure () else error \"assertion failed\"\n  if candidate 3249 == [3,3,19,19] then pure () else error \"assertion failed\"\n  if candidate 185193 == [3,3,3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 20577 == [3,19,19,19] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,3] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_26_remove_duplicates", "language": "hs", "prompt": "-- | From a list of integers, remove all elements that occur more than once.\n--  Keep order of elements left the same as in the input.\n--  >>> removeDuplicates [1,2,3,2,4]\n--  [1,3,4]\nremoveDuplicates :: [Int] -> [Int]\nremoveDuplicates numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_26_remove_duplicates.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = removeDuplicates\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,4,3,5] == [1,4,5] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_27_flip_case", "language": "hs", "prompt": "-- | For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n--  >>> flipCase \"Hello\"\n--  \"hELLO\"\nflipCase :: String -> String\nflipCase string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_27_flip_case.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = flipCase\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hello!\" == \"hELLO!\" then pure () else error \"assertion failed\"\n  if candidate \"These violent delights have violent ends\" == \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_28_concatenate", "language": "hs", "prompt": "-- | Concatenate list of strings into a single string\n--  >>> concatenate []\n--  \"\"\n--  >>> concatenate [\"a\",\"b\",\"c\"]\n--  \"abc\"\nconcatenate :: [String] -> String\nconcatenate strings =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_28_concatenate.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = concatenate\n  if candidate [] == \"\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\"] == \"xyz\" then pure () else error \"assertion failed\"\n  if candidate [\"x\",\"y\",\"z\",\"w\",\"k\"] == \"xyzwk\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_29_filter_by_prefix", "language": "hs", "prompt": "-- | Filter an input list of strings only for ones that start with a given prefix.\n--  >>> filterByPrefix [] \"a\"\n--  []\n--  >>> filterByPrefix [\"abc\",\"bcd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"array\"]\nfilterByPrefix :: [String] -> String -> [String]\nfilterByPrefix strings prefix =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_29_filter_by_prefix.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = filterByPrefix\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_2_truncate_number", "language": "hs", "prompt": "-- | Given a positive floating point number, it can be decomposed into\n--  and integer part (largest integer smaller than given number) and decimals\n--  (leftover part always smaller than 1).\n--  Return the decimal part of the number.\n--  >>> truncateNumber 3.5\n--  0.5\ntruncateNumber :: Float -> Float\ntruncateNumber number =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_2_truncate_number.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = truncateNumber\n  if candidate 3.5 == 0.5 then pure () else error \"assertion failed\"\n  if candidate 1.25 == 0.25 then pure () else error \"assertion failed\"\n  if candidate 123.0 == 0.0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_30_get_positive", "language": "hs", "prompt": "-- | Return only positive numbers in the list.\n--  >>> getPositive [(-1),2,(-4),5,6]\n--  [2,5,6]\n--  >>> getPositive [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  [5,3,2,3,9,123,1]\ngetPositive :: [Int] -> [Int]\ngetPositive l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_30_get_positive.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = getPositive\n  if candidate [(-1),(-2),4,5,6] == [4,5,6] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,3,3,9,0,123,1,(-10)] == [5,3,2,3,3,9,123,1] then pure () else error \"assertion failed\"\n  if candidate [(-1),(-2)] == [] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_31_is_prime", "language": "hs", "prompt": "-- | Return true if a given number is prime, and false otherwise.\n--  >>> isPrime 6\n--  False\n--  >>> isPrime 101\n--  True\n--  >>> isPrime 11\n--  True\n--  >>> isPrime 13441\n--  True\n--  >>> isPrime 61\n--  True\n--  >>> isPrime 4\n--  False\n--  >>> isPrime 1\n--  False\nisPrime :: Int -> Bool\nisPrime n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_31_is_prime.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isPrime\n  if candidate 6 == False then pure () else error \"assertion failed\"\n  if candidate 101 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 13441 == True then pure () else error \"assertion failed\"\n  if candidate 61 == True then pure () else error \"assertion failed\"\n  if candidate 4 == False then pure () else error \"assertion failed\"\n  if candidate 1 == False then pure () else error \"assertion failed\"\n  if candidate 5 == True then pure () else error \"assertion failed\"\n  if candidate 11 == True then pure () else error \"assertion failed\"\n  if candidate 17 == True then pure () else error \"assertion failed\"\n  if candidate 85 == False then pure () else error \"assertion failed\"\n  if candidate 77 == False then pure () else error \"assertion failed\"\n  if candidate 255379 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_33_sort_third", "language": "hs", "prompt": "-- | This function takes a list l and returns a list l' such that\n--  l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n--  to the values of the corresponding indicies of l, but sorted.\n--  >>> sortThird [1,2,3]\n--  [1,2,3]\n--  >>> sortThird [5,6,3,4,8,9,2]\n--  [2,6,3,4,8,9,5]\nsortThird :: [Int] -> [Int]\nsortThird l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_33_sort_third.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortThird\n  if candidate [5,6,3,4,8,9,2] == [2,6,3,4,8,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,8,3,4,6,9,2] == [2,8,3,4,6,9,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,9,4,8,3,2] == [2,6,9,4,8,3,5] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,4,8,9,2,1] == [2,6,3,4,8,9,5,1] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_34_unique", "language": "hs", "prompt": "-- | Return sorted unique elements in a list\n--  >>> unique [5,3,5,2,3,3,9,0,123]\n--  [0,2,3,5,9,123]\nunique :: [Int] -> [Int]\nunique l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_34_unique.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = unique\n  if candidate [5,3,5,2,3,3,9,0,123] == [0,2,3,5,9,123] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_35_max_element", "language": "hs", "prompt": "-- | Return maximum element in the list.\n--  >>> maxElement [1,2,3]\n--  3\n--  >>> maxElement [5,3,(-5),2,(-3),3,9,0,123,1,(-10)]\n--  123\nmaxElement :: [Int] -> Int\nmaxElement l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_35_max_element.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = maxElement\n  if candidate [1,2,3] == 3 then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,124,1,(-10)] == 124 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_36_fizz_buzz", "language": "hs", "prompt": "-- | Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n--  >>> fizzBuzz 50\n--  0\n--  >>> fizzBuzz 78\n--  2\n--  >>> fizzBuzz 79\n--  3\nfizzBuzz :: Int -> Int\nfizzBuzz n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_36_fizz_buzz.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fizzBuzz\n  if candidate 50 == 0 then pure () else error \"assertion failed\"\n  if candidate 78 == 2 then pure () else error \"assertion failed\"\n  if candidate 79 == 3 then pure () else error \"assertion failed\"\n  if candidate 100 == 3 then pure () else error \"assertion failed\"\n  if candidate 200 == 6 then pure () else error \"assertion failed\"\n  if candidate 4000 == 192 then pure () else error \"assertion failed\"\n  if candidate 10000 == 639 then pure () else error \"assertion failed\"\n  if candidate 100000 == 8026 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_37_sort_even", "language": "hs", "prompt": "-- | This function takes a list l and returns a list l' such that\n--  l' is identical to l in the odd indicies, while its values at the even indicies are equal\n--  to the values of the even indicies of l, but sorted.\n--  >>> sortEven [1,2,3]\n--  [1,2,3]\n--  >>> sortEven [5,6,3,4]\n--  [3,6,5,4]\nsortEven :: [Int] -> [Int]\nsortEven l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_37_sort_even.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortEven\n  if candidate [1,2,3] == [1,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,3,(-5),2,(-3),3,9,0,123,1,(-10)] == [(-10),3,(-5),2,(-3),3,5,0,9,1,123] then pure () else error \"assertion failed\"\n  if candidate [5,8,(-12),4,23,2,3,11,12,(-10)] == [(-12),8,3,4,5,2,12,11,23,(-10)] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_39_prime_fib", "language": "hs", "prompt": "-- | prime_fib returns n-th number that is a Fibonacci number and it's also prime.\n--  >>> primeFib 1\n--  2\n--  >>> primeFib 2\n--  3\n--  >>> primeFib 3\n--  5\n--  >>> primeFib 4\n--  13\n--  >>> primeFib 5\n--  89\nprimeFib :: Int -> Int\nprimeFib n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_39_prime_fib.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = primeFib\n  if candidate 1 == 2 then pure () else error \"assertion failed\"\n  if candidate 2 == 3 then pure () else error \"assertion failed\"\n  if candidate 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 4 == 13 then pure () else error \"assertion failed\"\n  if candidate 5 == 89 then pure () else error \"assertion failed\"\n  if candidate 6 == 233 then pure () else error \"assertion failed\"\n  if candidate 7 == 1597 then pure () else error \"assertion failed\"\n  if candidate 8 == 28657 then pure () else error \"assertion failed\"\n  if candidate 9 == 514229 then pure () else error \"assertion failed\"\n  if candidate 10 == 433494437 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_3_below_zero", "language": "hs", "prompt": "-- | You're given a list of deposit and withdrawal operations on a bank account that starts with\n--  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n--  at that point function should return True. Otherwise it should return False.\n--  >>> belowZero [1,2,3]\n--  False\n--  >>> belowZero [1,2,(-4),5]\n--  True\nbelowZero :: [Int] -> Bool\nbelowZero operations =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_3_below_zero.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = belowZero\n  if candidate [] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-3),1,2,(-3)] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,(-4),5,6] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-4)] == False then pure () else error \"assertion failed\"\n  if candidate [1,(-1),2,(-2),5,(-5),4,(-5)] == True then pure () else error \"assertion failed\"\n  if candidate [1,(-2),2,(-2),5,(-5),4,(-4)] == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_40_triples_sum_to_zero", "language": "hs", "prompt": "-- | triples_sum_to_zero takes a list of integers as an input.\n--  it returns True if there are three distinct elements in the list that\n--  sum to zero, and False otherwise.\n--  >>> triplesSumToZero [1,3,5,0]\n--  False\n--  >>> triplesSumToZero [1,3,(-2),1]\n--  True\n--  >>> triplesSumToZero [1,2,3,7]\n--  False\n--  >>> triplesSumToZero [2,4,(-5),3,9,7]\n--  True\n--  >>> triplesSumToZero [1]\n--  False\ntriplesSumToZero :: [Int] -> Bool\ntriplesSumToZero l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_40_triples_sum_to_zero.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = triplesSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-1)] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,5,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,9,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  if candidate [100,3,5,(-100)] == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_41_car_race_collision", "language": "hs", "prompt": "-- | Imagine a road that's a perfectly straight infinitely long line.\n--  n cars are driving left to right;  simultaneously, a different set of n cars\n--  are driving right to left.   The two sets of cars start out being very far from\n--  each other.  All cars move in the same speed.  Two cars are said to collide\n--  when a car that's moving left to right hits a car that's moving right to left.\n--  However, the cars are infinitely sturdy and strong; as a result, they continue moving\n--  in their trajectory as if they did not collide.\n--  This function outputs the number of such collisions.\ncarRaceCollision :: Int -> Int\ncarRaceCollision n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_41_car_race_collision.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = carRaceCollision\n  if candidate 2 == 4 then pure () else error \"assertion failed\"\n  if candidate 3 == 9 then pure () else error \"assertion failed\"\n  if candidate 4 == 16 then pure () else error \"assertion failed\"\n  if candidate 8 == 64 then pure () else error \"assertion failed\"\n  if candidate 10 == 100 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_42_incr_list", "language": "hs", "prompt": "-- | Return list with elements incremented by 1.\n--  >>> incrList [1,2,3]\n--  [2,3,4]\n--  >>> incrList [5,3,5,2,3,3,9,0,123]\n--  [6,4,6,3,4,4,10,1,124]\nincrList :: [Int] -> [Int]\nincrList l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_42_incr_list.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = incrList\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [4,3,2] then pure () else error \"assertion failed\"\n  if candidate [5,2,5,2,3,3,9,0,123] == [6,3,6,3,4,4,10,1,124] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_43_pairs_sum_to_zero", "language": "hs", "prompt": "-- | pairs_sum_to_zero takes a list of integers as an input.\n--  it returns True if there are two distinct elements in the list that\n--  sum to zero, and False otherwise.\n--  >>> pairsSumToZero [1,3,5,0]\n--  False\n--  >>> pairsSumToZero [1,3,(-2),1]\n--  False\n--  >>> pairsSumToZero [1,2,3,7]\n--  False\n--  >>> pairsSumToZero [2,4,(-5),3,5,7]\n--  True\n--  >>> pairsSumToZero [1]\n--  False\npairsSumToZero :: [Int] -> Bool\npairsSumToZero l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_43_pairs_sum_to_zero.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = pairsSumToZero\n  if candidate [1,3,5,0] == False then pure () else error \"assertion failed\"\n  if candidate [1,3,(-2),1] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,7] == False then pure () else error \"assertion failed\"\n  if candidate [2,4,(-5),3,5,7] == True then pure () else error \"assertion failed\"\n  if candidate [1] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,30] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),3,2,31] == True then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,30] == False then pure () else error \"assertion failed\"\n  if candidate [(-3),9,(-1),4,2,31] == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_44_change_base", "language": "hs", "prompt": "-- | Change numerical base of input number x to base.\n--  return string representation after the conversion.\n--  base numbers are less than 10.\n--  >>> changeBase 8 3\n--  \"22\"\n--  >>> changeBase 8 2\n--  \"1000\"\n--  >>> changeBase 7 2\n--  \"111\"\nchangeBase :: Int -> Int -> String\nchangeBase x base =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_44_change_base.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = changeBase\n  if candidate 8 3 == \"22\" then pure () else error \"assertion failed\"\n  if candidate 9 3 == \"100\" then pure () else error \"assertion failed\"\n  if candidate 234 2 == \"11101010\" then pure () else error \"assertion failed\"\n  if candidate 16 2 == \"10000\" then pure () else error \"assertion failed\"\n  if candidate 8 2 == \"1000\" then pure () else error \"assertion failed\"\n  if candidate 7 2 == \"111\" then pure () else error \"assertion failed\"\n  if candidate 2 3 == \"2\" then pure () else error \"assertion failed\"\n  if candidate 3 4 == \"3\" then pure () else error \"assertion failed\"\n  if candidate 4 5 == \"4\" then pure () else error \"assertion failed\"\n  if candidate 5 6 == \"5\" then pure () else error \"assertion failed\"\n  if candidate 6 7 == \"6\" then pure () else error \"assertion failed\"\n  if candidate 7 8 == \"7\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_45_triangle_area", "language": "hs", "prompt": "-- | Given length of a side and high return area for a triangle.\n--  >>> triangleArea 5 3\n--  7.5\ntriangleArea :: Int -> Int -> Float\ntriangleArea a h =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_45_triangle_area.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 5 3 == 7.5 then pure () else error \"assertion failed\"\n  if candidate 2 2 == 2.0 then pure () else error \"assertion failed\"\n  if candidate 10 8 == 40.0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_46_fib4", "language": "hs", "prompt": "-- | The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n--  fib4(0) -> 0\n--  fib4(1) -> 0\n--  fib4(2) -> 2\n--  fib4(3) -> 0\n--  fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n--  Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n--  >>> fib4 5\n--  4\n--  >>> fib4 6\n--  8\n--  >>> fib4 7\n--  14\nfib4 :: Int -> Int\nfib4 n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_46_fib4.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fib4\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 28 then pure () else error \"assertion failed\"\n  if candidate 10 == 104 then pure () else error \"assertion failed\"\n  if candidate 12 == 386 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_47_median", "language": "hs", "prompt": "-- | Return median of elements in the list l.\n--  >>> median [3,1,2,4,5]\n--  3.0\n--  >>> median [(-10),4,6,1000,10,20]\n--  15.0\nmedian :: [Int] -> Float\nmedian l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_47_median.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = median\n  if candidate [3,1,2,4,5] == 3.0 then pure () else error \"assertion failed\"\n  if candidate [(-10),4,6,1000,10,20] == 8.0 then pure () else error \"assertion failed\"\n  if candidate [5] == 5.0 then pure () else error \"assertion failed\"\n  if candidate [6,5] == 5.5 then pure () else error \"assertion failed\"\n  if candidate [8,1,3,9,9,2,7] == 7.0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_48_is_palindrome", "language": "hs", "prompt": "-- | Checks if given string is a palindrome\n--  >>> isPalindrome \"\"\n--  True\n--  >>> isPalindrome \"aba\"\n--  True\n--  >>> isPalindrome \"aaaaa\"\n--  True\n--  >>> isPalindrome \"zbcd\"\n--  False\nisPalindrome :: String -> Bool\nisPalindrome text =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_48_is_palindrome.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isPalindrome\n  if candidate \"\" == True then pure () else error \"assertion failed\"\n  if candidate \"aba\" == True then pure () else error \"assertion failed\"\n  if candidate \"aaaaa\" == True then pure () else error \"assertion failed\"\n  if candidate \"zbcd\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywyx\" == True then pure () else error \"assertion failed\"\n  if candidate \"xywyz\" == False then pure () else error \"assertion failed\"\n  if candidate \"xywzx\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_49_modp", "language": "hs", "prompt": "-- | Return 2^n modulo p (be aware of numerics).\n--  >>> modp 3 5\n--  3\n--  >>> modp 1101 101\n--  2\n--  >>> modp 0 101\n--  1\n--  >>> modp 3 11\n--  8\n--  >>> modp 100 101\n--  1\nmodp :: Int -> Int -> Int\nmodp n p =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_49_modp.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = modp\n  if candidate 3 5 == 3 then pure () else error \"assertion failed\"\n  if candidate 1101 101 == 2 then pure () else error \"assertion failed\"\n  if candidate 0 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 3 11 == 8 then pure () else error \"assertion failed\"\n  if candidate 100 101 == 1 then pure () else error \"assertion failed\"\n  if candidate 30 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 31 5 == 3 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_4_mean_absolute_deviation", "language": "hs", "prompt": "-- | For a given list of input numbers, calculate Mean Absolute Deviation\n--  around the mean of this dataset.\n--  Mean Absolute Deviation is the average absolute difference between each\n--  element and a centerpoint (mean in this case):\n--  MAD = average | x - x_mean |\n--  >>> meanAbsoluteDeviation [1.0,2.0,3.0,4.0]\n--  1.0\nmeanAbsoluteDeviation :: [Float] -> Float\nmeanAbsoluteDeviation numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_4_mean_absolute_deviation.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = meanAbsoluteDeviation\n  if candidate [1.0,2.0] == 0.5 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0] == 1.0 then pure () else error \"assertion failed\"\n  if candidate [1.0,2.0,3.0,4.0,5.0] == 1.2 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_51_remove_vowels", "language": "hs", "prompt": "-- | remove_vowels is a function that takes string and returns string without vowels.\n--  >>> removeVowels \"\"\n--  \"\"\n--  >>> removeVowels \"abcdef\"\n--  \"bcdf\"\n--  >>> removeVowels \"aaaaa\"\n--  \"\"\n--  >>> removeVowels \"aaBAA\"\n--  \"B\"\n--  >>> removeVowels \"zbcd\"\n--  \"zbcd\"\nremoveVowels :: String -> String\nremoveVowels text =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_51_remove_vowels.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = removeVowels\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"abcdef\nghijklm\" == \"bcdf\nghjklm\" then pure () else error \"assertion failed\"\n  if candidate \"fedcba\" == \"fdcb\" then pure () else error \"assertion failed\"\n  if candidate \"eeeee\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"acBAA\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"EcBOO\" == \"cB\" then pure () else error \"assertion failed\"\n  if candidate \"ybcd\" == \"ybcd\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_52_below_threshold", "language": "hs", "prompt": "-- | Return True if all numbers in the list l are below threshold t.\n--  >>> belowThreshold [1,2,4,10] 100\n--  True\n--  >>> belowThreshold [1,20,4,10] 5\n--  False\nbelowThreshold :: [Int] -> Int -> Bool\nbelowThreshold l t =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_52_below_threshold.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = belowThreshold\n  if candidate [1,2,4,10] 100 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 5 == False then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 21 == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] 22 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 11 == True then pure () else error \"assertion failed\"\n  if candidate [1,8,4,10] 10 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_53_add", "language": "hs", "prompt": "-- | Add two numbers x and y\n--  >>> add 2 3\n--  5\n--  >>> add 5 7\n--  12\nadd :: Int -> Int -> Int\nadd x y =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_53_add.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate 0 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 0 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 3 == 5 then pure () else error \"assertion failed\"\n  if candidate 5 7 == 12 then pure () else error \"assertion failed\"\n  if candidate 7 5 == 12 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_54_same_chars", "language": "hs", "prompt": "-- | Check if two words have the same characters.\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddeddabc\"\n--  True\n--  >>> sameChars \"abcd\" \"dddddddabc\"\n--  True\n--  >>> sameChars \"dddddddabc\" \"abcd\"\n--  True\n--  >>> sameChars \"eabcd\" \"dddddddabc\"\n--  False\n--  >>> sameChars \"abcd\" \"dddddddabce\"\n--  False\n--  >>> sameChars \"eabcdzzzz\" \"dddzzzzzzzddddabc\"\n--  False\nsameChars :: String -> String -> Bool\nsameChars s0 s1 =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_54_same_chars.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sameChars\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabc\" == True then pure () else error \"assertion failed\"\n  if candidate \"dddddddabc\" \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"eabcd\" \"dddddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" \"dddddddabcf\" == False then pure () else error \"assertion failed\"\n  if candidate \"eabcdzzzz\" \"dddzzzzzzzddddabc\" == False then pure () else error \"assertion failed\"\n  if candidate \"aabb\" \"aaccc\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_55_fib", "language": "hs", "prompt": "-- | Return n-th Fibonacci number.\n--  >>> fib 10\n--  55\n--  >>> fib 1\n--  1\n--  >>> fib 8\n--  21\nfib :: Int -> Int\nfib n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_55_fib.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fib\n  if candidate 10 == 55 then pure () else error \"assertion failed\"\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 8 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 89 then pure () else error \"assertion failed\"\n  if candidate 12 == 144 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_56_correct_bracketing", "language": "hs", "prompt": "-- | brackets is a string of \"<\" and \">\".\n--  return True if every opening bracket has a corresponding closing bracket.\n--  >>> correctBracketing \"<\"\n--  False\n--  >>> correctBracketing \"<>\"\n--  True\n--  >>> correctBracketing \"<<><>>\"\n--  True\n--  >>> correctBracketing \"><<>\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_56_correct_bracketing.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"<>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<><>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<><><<<><><>><>><<><><<>>>\" == True then pure () else error \"assertion failed\"\n  if candidate \"<<<><>>>>\" == False then pure () else error \"assertion failed\"\n  if candidate \"><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<<<\" == False then pure () else error \"assertion failed\"\n  if candidate \">\" == False then pure () else error \"assertion failed\"\n  if candidate \"<<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>><<>\" == False then pure () else error \"assertion failed\"\n  if candidate \"<><><<><>><>>><>\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_57_monotonic", "language": "hs", "prompt": "-- | Return True is list elements are monotonically increasing or decreasing.\n--  >>> monotonic [1,2,4,20]\n--  True\n--  >>> monotonic [1,20,4,10]\n--  False\n--  >>> monotonic [4,1,0,(-10)]\n--  True\nmonotonic :: [Int] -> Bool\nmonotonic l =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_57_monotonic.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = monotonic\n  if candidate [1,2,4,10] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,4,20] == True then pure () else error \"assertion failed\"\n  if candidate [1,20,4,10] == False then pure () else error \"assertion failed\"\n  if candidate [4,1,0,(-10)] == True then pure () else error \"assertion failed\"\n  if candidate [4,1,1,0] == True then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,5,60] == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,60] == True then pure () else error \"assertion failed\"\n  if candidate [9,9,9,9] == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_58_common", "language": "hs", "prompt": "-- | Return sorted unique common elements for two lists.\n--  >>> common [1,4,3,34,653,2,5] [5,7,1,5,9,653,121]\n--  [1,5,653]\n--  >>> common [5,3,2,8] [3,2]\n--  [2,3]\ncommon :: [Int] -> [Int] -> [Int]\ncommon l1 l2 =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_58_common.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = common\n  if candidate [1,4,3,34,653,2,5] [5,7,1,5,9,653,121] == [1,5,653] then pure () else error \"assertion failed\"\n  if candidate [5,3,2,8] [3,2] == [2,3] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [3,2,4] == [2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,8] [] == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_59_largest_prime_factor", "language": "hs", "prompt": "-- | Return the largest prime factor of n. Assume n > 1 and is not a prime.\n--  >>> largestPrimeFactor 13195\n--  29\n--  >>> largestPrimeFactor 2048\n--  2\nlargestPrimeFactor :: Int -> Int\nlargestPrimeFactor n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_59_largest_prime_factor.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = largestPrimeFactor\n  if candidate 15 == 5 then pure () else error \"assertion failed\"\n  if candidate 27 == 3 then pure () else error \"assertion failed\"\n  if candidate 63 == 7 then pure () else error \"assertion failed\"\n  if candidate 330 == 11 then pure () else error \"assertion failed\"\n  if candidate 13195 == 29 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_5_intersperse", "language": "hs", "prompt": "-- | Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n--  >>> intersperse [] 4\n--  []\n--  >>> intersperse [1,2,3] 4\n--  [1,4,2,4,3]\nintersperse :: [Int] -> Int -> [Int]\nintersperse numbers delimeter =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_5_intersperse.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = intersperse\n  if candidate [] 7 == [] then pure () else error \"assertion failed\"\n  if candidate [5,6,3,2] 8 == [5,8,6,8,3,8,2] then pure () else error \"assertion failed\"\n  if candidate [2,2,2] 2 == [2,2,2,2,2] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_60_sum_to_n", "language": "hs", "prompt": "-- | sum_to_n is a function that sums numbers from 1 to n.\n--  >>> sumToN 30\n--  465\n--  >>> sumToN 100\n--  5050\n--  >>> sumToN 5\n--  15\n--  >>> sumToN 10\n--  55\n--  >>> sumToN 1\n--  1\nsumToN :: Int -> Int\nsumToN n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_60_sum_to_n.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sumToN\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 6 == 21 then pure () else error \"assertion failed\"\n  if candidate 11 == 66 then pure () else error \"assertion failed\"\n  if candidate 30 == 465 then pure () else error \"assertion failed\"\n  if candidate 100 == 5050 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_61_correct_bracketing", "language": "hs", "prompt": "-- | brackets is a string of \"(\" and \")\".\n--  return True if every opening bracket has a corresponding closing bracket.\n--  >>> correctBracketing \"(\"\n--  False\n--  >>> correctBracketing \"()\"\n--  True\n--  >>> correctBracketing \"(()())\"\n--  True\n--  >>> correctBracketing \")(()\"\n--  False\ncorrectBracketing :: String -> Bool\ncorrectBracketing brackets =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_61_correct_bracketing.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = correctBracketing\n  if candidate \"()\" == True then pure () else error \"assertion failed\"\n  if candidate \"(()())\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()\" == True then pure () else error \"assertion failed\"\n  if candidate \"()()((()()())())(()()(()))\" == True then pure () else error \"assertion failed\"\n  if candidate \"((()())))\" == False then pure () else error \"assertion failed\"\n  if candidate \")(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"(\" == False then pure () else error \"assertion failed\"\n  if candidate \"((((\" == False then pure () else error \"assertion failed\"\n  if candidate \")\" == False then pure () else error \"assertion failed\"\n  if candidate \"(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())())(()\" == False then pure () else error \"assertion failed\"\n  if candidate \"()()(()())()))()\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_62_derivative", "language": "hs", "prompt": "-- | xs represent coefficients of a polynomial.\n--  xs[0] + xs[1] * x + xs[2] * x^2 + ....\n--  Return derivative of this polynomial in the same form.\n--  >>> derivative [3,1,2,4,5]\n--  [1,4,12,20]\n--  >>> derivative [1,2,3]\n--  [2,6]\nderivative :: [Int] -> [Int]\nderivative xs =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_62_derivative.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = derivative\n  if candidate [3,1,2,4,5] == [1,4,12,20] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,6] then pure () else error \"assertion failed\"\n  if candidate [3,2,1] == [2,2] then pure () else error \"assertion failed\"\n  if candidate [3,2,1,0,4] == [2,2,0,16] then pure () else error \"assertion failed\"\n  if candidate [1] == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_63_fibfib", "language": "hs", "prompt": "-- | The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n--  fibfib(0) == 0\n--  fibfib(1) == 0\n--  fibfib(2) == 1\n--  fibfib(n) == fibfib(n-1) + fibfib(n-2) + fibfib(n-3).\n--  Please write a function to efficiently compute the n-th element of the fibfib number sequence.\n--  >>> fibfib 1\n--  0\n--  >>> fibfib 5\n--  4\n--  >>> fibfib 8\n--  24\nfibfib :: Int -> Int\nfibfib n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_63_fibfib.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fibfib\n  if candidate 2 == 1 then pure () else error \"assertion failed\"\n  if candidate 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 5 == 4 then pure () else error \"assertion failed\"\n  if candidate 8 == 24 then pure () else error \"assertion failed\"\n  if candidate 10 == 81 then pure () else error \"assertion failed\"\n  if candidate 12 == 274 then pure () else error \"assertion failed\"\n  if candidate 14 == 927 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_64_vowels_count", "language": "hs", "prompt": "-- | Write a function vowels_count which takes a string representing\n--  a word as input and returns the number of vowels in the string.\n--  Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n--  vowel, but only when it is at the end of the given word.\n--  Example:\n--  >>> vowelsCount \"abcde\"\n--  2\n--  >>> vowelsCount \"ACEDY\"\n--  3\nvowelsCount :: String -> Int\nvowelsCount s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_64_vowels_count.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = vowelsCount\n  if candidate \"abcde\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"Alone\" == 3 then pure () else error \"assertion failed\"\n  if candidate \"key\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bye\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"keY\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"bYe\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"ACEDY\" == 3 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_65_circular_shift", "language": "hs", "prompt": "-- | Circular shift the digits of the integer x, shift the digits right by shift\n--  and return the result as a string.\n--  If shift > number of digits, return digits reversed.\n--  >>> circularShift 12 1\n--  \"21\"\n--  >>> circularShift 12 2\n--  \"12\"\ncircularShift :: Int -> Int -> String\ncircularShift x shift =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_65_circular_shift.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = circularShift\n  if candidate 100 2 == \"001\" then pure () else error \"assertion failed\"\n  if candidate 12 2 == \"12\" then pure () else error \"assertion failed\"\n  if candidate 97 8 == \"79\" then pure () else error \"assertion failed\"\n  if candidate 12 1 == \"21\" then pure () else error \"assertion failed\"\n  if candidate 11 101 == \"11\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_66_digitSum", "language": "hs", "prompt": "-- | Task\n--  Write a function that takes a string as input and returns the sum of the upper characters only'\n--  ASCII codes.\n--  Examples:\n--  >>> digitsum \"\"\n--  0\n--  >>> digitsum \"abAB\"\n--  131\n--  >>> digitsum \"abcCd\"\n--  67\n--  >>> digitsum \"helloE\"\n--  69\n--  >>> digitsum \"woArBld\"\n--  131\n--  >>> digitsum \"aAaaaXa\"\n--  153\ndigitsum :: String -> Int\ndigitsum s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_66_digitSum.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = digitsum\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"abAB\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"abcCd\" == 67 then pure () else error \"assertion failed\"\n  if candidate \"helloE\" == 69 then pure () else error \"assertion failed\"\n  if candidate \"woArBld\" == 131 then pure () else error \"assertion failed\"\n  if candidate \"aAaaaXa\" == 153 then pure () else error \"assertion failed\"\n  if candidate \" How are yOu?\" == 151 then pure () else error \"assertion failed\"\n  if candidate \"You arE Very Smart\" == 327 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_67_fruit_distribution", "language": "hs", "prompt": "-- | In this task, you will be given a string that represents a number of apples and oranges \n--  that are distributed in a basket of fruit this basket contains \n--  apples, oranges, and mango fruits. Given the string that represents the total number of \n--  the oranges and apples and an integer that represent the total number of the fruits \n--  in the basket return the number of the mango fruits in the basket.\n--  for examble:\n--  >>> fruitDistribution \"5 apples and 6 oranges\" 19\n--  8\n--  >>> fruitDistribution \"0 apples and 1 oranges\" 3\n--  2\n--  >>> fruitDistribution \"2 apples and 3 oranges\" 100\n--  95\n--  >>> fruitDistribution \"100 apples and 1 oranges\" 120\n--  19\nfruitDistribution :: String -> Int -> Int\nfruitDistribution s n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_67_fruit_distribution.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = fruitDistribution\n  if candidate \"5 apples and 6 oranges\" 19 == 8 then pure () else error \"assertion failed\"\n  if candidate \"5 apples and 6 oranges\" 21 == 10 then pure () else error \"assertion failed\"\n  if candidate \"0 apples and 1 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 0 oranges\" 3 == 2 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 100 == 95 then pure () else error \"assertion failed\"\n  if candidate \"2 apples and 3 oranges\" 5 == 0 then pure () else error \"assertion failed\"\n  if candidate \"1 apples and 100 oranges\" 120 == 19 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_68_pluck", "language": "hs", "prompt": "-- | \"Given an array representing a branch of a tree that has non-negative integer nodes\n--  your task is to pluck one of the nodes and return it.\n--  The plucked node should be the node with the smallest even value.\n--  If multiple nodes with the same smallest even value are found return the node that has smallest index.\n--  The plucked node should be returned in a list, [ smalest_value, its index ],\n--  If there are no even values or the given array is empty, return [].\n--  Example 1:\n--  >>> pluck [4,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 2:\n--  >>> pluck [1,2,3]\n--  [2,1]\n--  Explanation: 2 has the smallest even value, and 2 has the smallest index.\n--  Example 3:\n--  >>> pluck []\n--  []\n--  Example 4:\n--  >>> pluck [5,0,3,0,4,2]\n--  [0,1]\n--  Explanation: 0 is the smallest value, but  there are two zeros,\n--  so we will choose the first zero, which has the smallest index.\n--  Constraints:\n--  * 1 <= nodes.length <= 10000\n--  * 0 <= node.value\npluck :: [Int] -> [Int]\npluck arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_68_pluck.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = pluck\n  if candidate [4,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3] == [2,1] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5,0,3,0,4,2] == [0,1] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,0,5,3] == [0,3] then pure () else error \"assertion failed\"\n  if candidate [5,4,8,4,8] == [4,1] then pure () else error \"assertion failed\"\n  if candidate [7,6,7,1] == [6,1] then pure () else error \"assertion failed\"\n  if candidate [7,9,7,1] == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_69_search", "language": "hs", "prompt": "-- | You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n--  zero, and has a frequency greater than or equal to the value of the integer itself. \n--  The frequency of an integer is the number of times it appears in the list.\n--  If no such a value exist, return -1.\n--  Examples:\n--  >>> search [4,1,2,2,3,1]\n--  2\n--  >>> search [1,2,2,3,3,3,4,4,4]\n--  3\n--  >>> search [5,5,4,4,4]\n--  (-1)\nsearch :: [Int] -> Int\nsearch lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_69_search.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = search\n  if candidate [5,5,5,5,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [4,1,4,1,4,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [3,3] == (-1) then pure () else error \"assertion failed\"\n  if candidate [8,8,8,8,8,8,8,8] == 8 then pure () else error \"assertion failed\"\n  if candidate [2,3,3,2,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [2,7,8,8,4,8,7,3,9,6,5,10,4,3,6,7,1,7,4,10,8,1] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,2,8,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [6,7,1,8,8,10,5,8,5,3,10] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,3,6,5,6,4] == (-1) then pure () else error \"assertion failed\"\n  if candidate [6,9,6,7,1,4,7,1,8,8,9,8,10,10,8,4,10,4,10,1,2,9,5,7,9] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,9,10,1,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [6,9,7,5,8,7,5,3,7,5,10,10,3,6,10,2,8,6,5,4,9,5,3,10] == 5 then pure () else error \"assertion failed\"\n  if candidate [1] == 1 then pure () else error \"assertion failed\"\n  if candidate [8,8,10,6,4,3,5,8,2,4,2,8,4,6,10,4,2,1,10,2,1,1,5] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,10,4,8,2,10,5,1,2,9,5,5,6,3,8,6,4,10] == 2 then pure () else error \"assertion failed\"\n  if candidate [1,6,10,1,6,9,10,8,6,8,7,3] == 1 then pure () else error \"assertion failed\"\n  if candidate [9,2,4,1,5,1,5,2,5,7,7,7,3,10,1,5,4,2,8,4,1,9,10,7,10,2,8,10,9,4] == 4 then pure () else error \"assertion failed\"\n  if candidate [2,6,4,2,8,7,5,6,4,10,4,6,3,7,8,8,3,1,4,2,2,10,7] == 4 then pure () else error \"assertion failed\"\n  if candidate [9,8,6,10,2,6,10,2,7,8,10,3,8,2,6,2,3,1] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,5,3,9,5,6,3,2,8,5,6,10,10,6,8,4,10,7,7,10,8] == (-1) then pure () else error \"assertion failed\"\n  if candidate [10] == (-1) then pure () else error \"assertion failed\"\n  if candidate [9,7,7,2,4,7,2,10,9,7,5,7,2] == 2 then pure () else error \"assertion failed\"\n  if candidate [5,4,10,2,1,1,10,3,6,1,8] == 1 then pure () else error \"assertion failed\"\n  if candidate [7,9,9,9,3,4,1,5,9,1,2,1,1,10,7,5,6,7,6,7,7,6] == 1 then pure () else error \"assertion failed\"\n  if candidate [3,10,10,9,2] == (-1) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_6_parse_nested_parens", "language": "hs", "prompt": "-- | Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n--  For each of the group, output the deepest level of nesting of parentheses.\n--  E.g. (()()) has maximum two levels of nesting while ((())) has three.\n--  >>> parseNestedParens \"(()()) ((())) () ((())()())\"\n--  [2,3,1,3]\nparseNestedParens :: String -> [Int]\nparseNestedParens paren_string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_6_parse_nested_parens.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = parseNestedParens\n  if candidate \"(()()) ((())) () ((())()())\" == [2,3,1,3] then pure () else error \"assertion failed\"\n  if candidate \"() (()) ((())) (((())))\" == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate \"(()(())((())))\" == [4] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_70_strange_sort_list", "language": "hs", "prompt": "-- | Given list of integers, return list in strange order.\n--  Strange sorting, is when you start with the minimum value,\n--  then maximum of the remaining integers, then minimum and so on.\n--  Examples:\n--  >>> strangeSortList [1,2,3,4]\n--  [1,4,2,3]\n--  >>> strangeSortList [5,5,5,5]\n--  [5,5,5,5]\n--  >>> strangeSortList []\n--  []\nstrangeSortList :: [Int] -> [Int]\nstrangeSortList lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_70_strange_sort_list.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = strangeSortList\n  if candidate [1,2,3,4] == [1,4,2,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9] == [5,9,6,8,7] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5] == [1,5,2,4,3] then pure () else error \"assertion failed\"\n  if candidate [5,6,7,8,9,1] == [1,9,5,8,6,7] then pure () else error \"assertion failed\"\n  if candidate [5,5,5,5] == [5,5,5,5] then pure () else error \"assertion failed\"\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,5,6,7,8] == [1,8,2,7,3,6,4,5] then pure () else error \"assertion failed\"\n  if candidate [0,2,2,2,5,5,(-5),(-5)] == [(-5),5,(-5),5,0,2,2,2] then pure () else error \"assertion failed\"\n  if candidate [111111] == [111111] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_71_triangle_area", "language": "hs", "prompt": "-- | Given the lengths of the three sides of a triangle. Return the area of\n--  the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n--  Otherwise return -1\n--  Three sides make a valid triangle when the sum of any two sides is greater \n--  than the third side.\n--  Example:\n--  >>> triangleArea 3 4 5\n--  6.0\n--  >>> triangleArea 1 2 10\n--  (-1).0\ntriangleArea :: Int -> Int -> Int -> Float\ntriangleArea a b c =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_71_triangle_area.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = triangleArea\n  if candidate 3 4 5 == 6.0 then pure () else error \"assertion failed\"\n  if candidate 1 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 4 8 5 == 8.18 then pure () else error \"assertion failed\"\n  if candidate 2 2 2 == 1.73 then pure () else error \"assertion failed\"\n  if candidate 1 2 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 10 5 7 == 16.25 then pure () else error \"assertion failed\"\n  if candidate 2 6 3 == (-1).0 then pure () else error \"assertion failed\"\n  if candidate 1 1 1 == 0.43 then pure () else error \"assertion failed\"\n  if candidate 2 2 10 == (-1).0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_72_will_it_fly", "language": "hs", "prompt": "-- | Write a function that returns True if the object q will fly, and False otherwise.\n--  The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n--  Example:\n--  >>> willItFly [1,2] 5\n--  False\n--  # 1+2 is less than the maximum possible weight, but it's unbalanced.\n--  >>> willItFly [3,2,3] 1\n--  False\n--  # it's balanced, but 3+2+3 is more than the maximum possible weight.\n--  >>> willItFly [3,2,3] 9\n--  True\n--  # 3+2+3 is less than the maximum possible weight, and it's balanced.\n--  >>> willItFly [3] 5\n--  True\n--  # 3 is less than the maximum possible weight, and it's balanced.\nwillItFly :: [Int] -> Int -> Bool\nwillItFly q w =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_72_will_it_fly.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = willItFly\n  if candidate [3,2,3] 9 == True then pure () else error \"assertion failed\"\n  if candidate [1,2] 5 == False then pure () else error \"assertion failed\"\n  if candidate [3] 5 == True then pure () else error \"assertion failed\"\n  if candidate [3,2,3] 1 == False then pure () else error \"assertion failed\"\n  if candidate [1,2,3] 6 == False then pure () else error \"assertion failed\"\n  if candidate [5] 5 == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_73_smallest_change", "language": "hs", "prompt": "-- | Given an array arr of integers, find the minimum number of elements that\n--  need to be changed to make the array palindromic. A palindromic array is an array that\n--  is read the same backwards and forwards. In one change, you can change one element to any other element.\n--  For example:\n--  >>> smallestChange [1,2,3,5,4,7,9,6]\n--  4\n--  >>> smallestChange [1,2,3,4,3,2,2]\n--  1\n--  >>> smallestChange [1,2,3,2,1]\n--  0\nsmallestChange :: [Int] -> Int\nsmallestChange arr =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_73_smallest_change.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = smallestChange\n  if candidate [1,2,3,5,4,7,9,6] == 4 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4,3,2,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,4,4,2] == 1 then pure () else error \"assertion failed\"\n  if candidate [1,2,3,2,1] == 0 then pure () else error \"assertion failed\"\n  if candidate [3,1,1,3] == 0 then pure () else error \"assertion failed\"\n  if candidate [1] == 0 then pure () else error \"assertion failed\"\n  if candidate [0,1] == 1 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_74_total_match", "language": "hs", "prompt": "-- | Write a function that accepts two lists of strings and returns the list that has \n--  total number of chars in the all strings of the list less than the other list.\n--  if the two lists have the same number of chars, return the first list.\n--  Examples\n--  >>> totalMatch [] []\n--  []\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"Hi\"]\n--  [\"hI\",\"Hi\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"]\n--  [\"hi\",\"admin\"]\n--  >>> totalMatch [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"]\n--  [\"hI\",\"hi\",\"hi\"]\n--  >>> totalMatch [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"]\n--  [\"4\"]\ntotalMatch :: [String] -> [String] -> [String]\ntotalMatch lst1 lst2 =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_74_total_match.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = totalMatch\n  if candidate [] [] == [] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\"] == [\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hi\",\"hi\",\"admin\",\"project\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [\"4\"] [\"1\",\"2\",\"3\",\"4\",\"5\"] == [\"4\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"Hi\"] == [\"hI\",\"Hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hi\"] == [\"hI\",\"hi\",\"hi\"] then pure () else error \"assertion failed\"\n  if candidate [\"hi\",\"admin\"] [\"hI\",\"hi\",\"hii\"] == [\"hi\",\"admin\"] then pure () else error \"assertion failed\"\n  if candidate [] [\"this\"] == [] then pure () else error \"assertion failed\"\n  if candidate [\"this\"] [] == [] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_75_is_multiply_prime", "language": "hs", "prompt": "-- | Write a function that returns true if the given number is the multiplication of 3 prime numbers\n--  and false otherwise.\n--  Knowing that (a) is less then 100. \n--  Example:\n--  >>> isMultiplyPrime 30\n--  True\n--  30 = 2 * 3 * 5\nisMultiplyPrime :: Int -> Bool\nisMultiplyPrime a =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_75_is_multiply_prime.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isMultiplyPrime\n  if candidate 5 == False then pure () else error \"assertion failed\"\n  if candidate 30 == True then pure () else error \"assertion failed\"\n  if candidate 8 == True then pure () else error \"assertion failed\"\n  if candidate 10 == False then pure () else error \"assertion failed\"\n  if candidate 125 == True then pure () else error \"assertion failed\"\n  if candidate 105 == True then pure () else error \"assertion failed\"\n  if candidate 126 == False then pure () else error \"assertion failed\"\n  if candidate 729 == False then pure () else error \"assertion failed\"\n  if candidate 891 == False then pure () else error \"assertion failed\"\n  if candidate 1001 == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_76_is_simple_power", "language": "hs", "prompt": "-- | Your task is to write a function that returns true if a number x is a simple\n--  power of n and false in other cases.\n--  x is a simple power of n if n**int=x\n--  For example:\n--  >>> isSimplePower 1 4\n--  True\n--  >>> isSimplePower 2 2\n--  True\n--  >>> isSimplePower 8 2\n--  True\n--  >>> isSimplePower 3 2\n--  False\n--  >>> isSimplePower 3 1\n--  False\n--  >>> isSimplePower 5 3\n--  False\nisSimplePower :: Int -> Int -> Bool\nisSimplePower x n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_76_is_simple_power.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isSimplePower\n  if candidate 16 2 == True then pure () else error \"assertion failed\"\n  if candidate 143214 16 == False then pure () else error \"assertion failed\"\n  if candidate 4 2 == True then pure () else error \"assertion failed\"\n  if candidate 9 3 == True then pure () else error \"assertion failed\"\n  if candidate 16 4 == True then pure () else error \"assertion failed\"\n  if candidate 24 2 == False then pure () else error \"assertion failed\"\n  if candidate 128 4 == False then pure () else error \"assertion failed\"\n  if candidate 12 6 == False then pure () else error \"assertion failed\"\n  if candidate 1 1 == True then pure () else error \"assertion failed\"\n  if candidate 1 12 == True then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_77_iscube", "language": "hs", "prompt": "-- | Write a function that takes an integer a and returns True \n--  if this ingeger is a cube of some integer number.\n--  Note: you may assume the input is always valid.\n--  Examples:\n--  >>> iscube 1\n--  True\n--  >>> iscube 2\n--  False\n--  >>> iscube (-1)\n--  True\n--  >>> iscube 64\n--  True\n--  >>> iscube 0\n--  True\n--  >>> iscube 180\n--  False\niscube :: Int -> Bool\niscube a =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_77_iscube.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = iscube\n  if candidate 1 == True then pure () else error \"assertion failed\"\n  if candidate 2 == False then pure () else error \"assertion failed\"\n  if candidate (-1) == True then pure () else error \"assertion failed\"\n  if candidate 64 == True then pure () else error \"assertion failed\"\n  if candidate 180 == False then pure () else error \"assertion failed\"\n  if candidate 1000 == True then pure () else error \"assertion failed\"\n  if candidate 0 == True then pure () else error \"assertion failed\"\n  if candidate 1729 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_78_hex_key", "language": "hs", "prompt": "-- | You have been tasked to write a function that receives \n--  a hexadecimal number as a string and counts the number of hexadecimal \n--  digits that are primes (prime number, or a prime, is a natural number \n--  greater than 1 that is not a product of two smaller natural numbers).\n--  Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n--  Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n--  So you have to determine a number of the following digits: 2, 3, 5, 7, \n--  B (=decimal 11), D (=decimal 13).\n--  Note: you may assume the input is always correct or empty string, \n--  and symbols A,B,C,D,E,F are always uppercase.\n--  Examples:\n--  >>> hexKey \"AB\"\n--  1\n--  >>> hexKey \"1077E\"\n--  2\n--  >>> hexKey \"ABED1A33\"\n--  4\n--  >>> hexKey \"123456789ABCDEF0\"\n--  6\n--  >>> hexKey \"2020\"\n--  2\nhexKey :: String -> Int\nhexKey num =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_78_hex_key.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = hexKey\n  if candidate \"AB\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"1077E\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"ABED1A33\" == 4 then pure () else error \"assertion failed\"\n  if candidate \"2020\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"123456789ABCDEF0\" == 6 then pure () else error \"assertion failed\"\n  if candidate \"112233445566778899AABBCCDDEEFF00\" == 12 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_79_decimal_to_binary", "language": "hs", "prompt": "-- | You will be given a number in decimal form and your task is to convert it to\n--  binary format. The function should return a string, with each character representing a binary\n--  number. Each character in the string will be '0' or '1'.\n--  There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n--  The extra characters are there to help with the format.\n--  Examples:\n--  >>> decimalToBinary 15\n--  \"db1111db\"\n--  >>> decimalToBinary 32\n--  \"db100000db\"\ndecimalToBinary :: Int -> String\ndecimalToBinary decimal =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_79_decimal_to_binary.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = decimalToBinary\n  if candidate 0 == \"db0db\" then pure () else error \"assertion failed\"\n  if candidate 32 == \"db100000db\" then pure () else error \"assertion failed\"\n  if candidate 103 == \"db1100111db\" then pure () else error \"assertion failed\"\n  if candidate 15 == \"db1111db\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_7_filter_by_substring", "language": "hs", "prompt": "-- | Filter an input list of strings only for ones that contain given substring\n--  >>> filterBySubstring [] \"a\"\n--  []\n--  >>> filterBySubstring [\"abc\",\"bacd\",\"cde\",\"array\"] \"a\"\n--  [\"abc\",\"bacd\",\"array\"]\nfilterBySubstring :: [String] -> String -> [String]\nfilterBySubstring strings substring =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_7_filter_by_substring.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = filterBySubstring\n  if candidate [] \"john\" == [] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"xxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xxx\" == [\"xxx\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"xxx\",\"asd\",\"aaaxxy\",\"john doe\",\"xxxAAA\",\"xxx\"] \"xx\" == [\"xxx\",\"aaaxxy\",\"xxxAAA\",\"xxx\"] then pure () else error \"assertion failed\"\n  if candidate [\"grunt\",\"trumpet\",\"prune\",\"gruesome\"] \"run\" == [\"grunt\",\"prune\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_80_is_happy", "language": "hs", "prompt": "-- | You are given a string s.\n--  Your task is to check if the string is happy or not.\n--  A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n--  For example:\n--  >>> isHappy \"a\"\n--  False\n--  >>> isHappy \"aa\"\n--  False\n--  >>> isHappy \"abcd\"\n--  True\n--  >>> isHappy \"aabb\"\n--  False\n--  >>> isHappy \"adb\"\n--  True\n--  >>> isHappy \"xyy\"\n--  False\nisHappy :: String -> Bool\nisHappy s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_80_is_happy.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isHappy\n  if candidate \"a\" == False then pure () else error \"assertion failed\"\n  if candidate \"aa\" == False then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == True then pure () else error \"assertion failed\"\n  if candidate \"aabb\" == False then pure () else error \"assertion failed\"\n  if candidate \"adb\" == True then pure () else error \"assertion failed\"\n  if candidate \"xyy\" == False then pure () else error \"assertion failed\"\n  if candidate \"iopaxpoi\" == True then pure () else error \"assertion failed\"\n  if candidate \"iopaxioi\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_81_numerical_letter_grade", "language": "hs", "prompt": "-- | It is the last week of the semester and the teacher has to give the grades\n--  to students. The teacher has been making her own algorithm for grading.\n--  The only problem is, she has lost the code she used for grading.\n--  She has given you a list of GPAs for some students and you have to write \n--  a function that can output a list of letter grades using the following table:\n--  GPA       |    Letter grade\n--  4.0                A+\n--  > 3.7                A \n--  > 3.3                A- \n--  > 3.0                B+\n--  > 2.7                B \n--  > 2.3                B-\n--  > 2.0                C+\n--  > 1.7                C\n--  > 1.3                C-\n--  > 1.0                D+ \n--  > 0.7                D \n--  > 0.0                D-\n--  0.0                E\n--  Example:\n--  >>> gradeEquation [4.0,3,1.7,2,3.5]\n--  [\"A+\",\"B\",\"C-\",\"C\",\"A-\"]\nnumericalLetterGrade :: [Float] -> [String]\nnumericalLetterGrade grades =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_81_numerical_letter_grade.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = numericalLetterGrade\n  if candidate [4.0,3,1.7,2,3.5] == [\"A+\",\"B\",\"C-\",\"C\",\"A-\"] then pure () else error \"assertion failed\"\n  if candidate [1.2] == [\"D+\"] then pure () else error \"assertion failed\"\n  if candidate [0.5] == [\"D-\"] then pure () else error \"assertion failed\"\n  if candidate [0.0] == [\"E\"] then pure () else error \"assertion failed\"\n  if candidate [1.0,0.3,1.5,2.8,3.3] == [\"D\",\"D-\",\"C-\",\"B\",\"B+\"] then pure () else error \"assertion failed\"\n  if candidate [0.0,0.7] == [\"E\",\"D-\"] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_82_prime_length", "language": "hs", "prompt": "-- | Write a function that takes a string and returns True if the string\n--  length is a prime number or False otherwise\n--  Examples\n--  >>> primeLength \"Hello\"\n--  True\n--  >>> primeLength \"abcdcba\"\n--  True\n--  >>> primeLength \"kittens\"\n--  True\n--  >>> primeLength \"orange\"\n--  False\nprimeLength :: String -> Bool\nprimeLength string =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_82_prime_length.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = primeLength\n  if candidate \"Hello\" == True then pure () else error \"assertion failed\"\n  if candidate \"abcdcba\" == True then pure () else error \"assertion failed\"\n  if candidate \"kittens\" == True then pure () else error \"assertion failed\"\n  if candidate \"orange\" == False then pure () else error \"assertion failed\"\n  if candidate \"wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"world\" == True then pure () else error \"assertion failed\"\n  if candidate \"MadaM\" == True then pure () else error \"assertion failed\"\n  if candidate \"Wow\" == True then pure () else error \"assertion failed\"\n  if candidate \"\" == False then pure () else error \"assertion failed\"\n  if candidate \"HI\" == True then pure () else error \"assertion failed\"\n  if candidate \"go\" == True then pure () else error \"assertion failed\"\n  if candidate \"gogo\" == False then pure () else error \"assertion failed\"\n  if candidate \"aaaaaaaaaaaaaaa\" == False then pure () else error \"assertion failed\"\n  if candidate \"Madam\" == True then pure () else error \"assertion failed\"\n  if candidate \"M\" == False then pure () else error \"assertion failed\"\n  if candidate \"0\" == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_83_starts_one_ends", "language": "hs", "prompt": "-- | Given a positive integer n, return the count of the numbers of n-digit\n--  positive integers that start or end with 1.\nstartsOneEnds :: Int -> Int\nstartsOneEnds n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_83_starts_one_ends.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = startsOneEnds\n  if candidate 1 == 1 then pure () else error \"assertion failed\"\n  if candidate 2 == 18 then pure () else error \"assertion failed\"\n  if candidate 3 == 180 then pure () else error \"assertion failed\"\n  if candidate 4 == 1800 then pure () else error \"assertion failed\"\n  if candidate 5 == 18000 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_84_solve", "language": "hs", "prompt": "-- | Given a positive integer N, return the total sum of its digits in binary.\n--  Example\n--  >>> solve 1000\n--  \"1\"\n--  >>> solve 150\n--  \"110\"\n--  >>> solve 147\n--  \"1100\"\n--  Variables:\n--  @N integer\n--  Constraints: 0 \u00e2\u2030\u00a4 N \u00e2\u2030\u00a4 10000.\n--  Output:\n--  a string of binary number\nsolve :: Int -> String\nsolve N =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_84_solve.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = solve\n  if candidate 1000 == \"1\" then pure () else error \"assertion failed\"\n  if candidate 150 == \"110\" then pure () else error \"assertion failed\"\n  if candidate 147 == \"1100\" then pure () else error \"assertion failed\"\n  if candidate 333 == \"1001\" then pure () else error \"assertion failed\"\n  if candidate 963 == \"10010\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_85_add", "language": "hs", "prompt": "-- | Given a non-empty list of integers lst. add the even elements that are at odd indices..\n--  Examples:\n--  >>> add [4,2,6,7]\n--  2\nadd :: [Int] -> Int\nadd lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_85_add.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = add\n  if candidate [4,88] == 88 then pure () else error \"assertion failed\"\n  if candidate [4,5,6,7,2,122] == 122 then pure () else error \"assertion failed\"\n  if candidate [4,0,6,7] == 0 then pure () else error \"assertion failed\"\n  if candidate [4,4,6,8] == 12 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_86_anti_shuffle", "language": "hs", "prompt": "-- | Write a function that takes a string and returns an ordered version of it.\n--  Ordered version of string, is a string where all words (separated by space)\n--  are replaced by a new word where all the characters arranged in\n--  ascending order based on ascii value.\n--  Note: You should keep the order of words and blank spaces in the sentence.\n--  For example:\n--  >>> antiShuffle \"Hi\"\n--  \"Hi\"\n--  >>> antiShuffle \"hello\"\n--  \"ehllo\"\n--  >>> antiShuffle \"Hello World!!!\"\n--  \"Hello !!!Wdlor\"\nantiShuffle :: String -> String\nantiShuffle s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_86_anti_shuffle.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = antiShuffle\n  if candidate \"Hi\" == \"Hi\" then pure () else error \"assertion failed\"\n  if candidate \"hello\" == \"ehllo\" then pure () else error \"assertion failed\"\n  if candidate \"number\" == \"bemnru\" then pure () else error \"assertion failed\"\n  if candidate \"abcd\" == \"abcd\" then pure () else error \"assertion failed\"\n  if candidate \"Hello World!!!\" == \"Hello !!!Wdlor\" then pure () else error \"assertion failed\"\n  if candidate \"\" == \"\" then pure () else error \"assertion failed\"\n  if candidate \"Hi. My name is Mister Robot. How are you?\" == \".Hi My aemn is Meirst .Rboot How aer ?ouy\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_87_get_row", "language": "hs", "prompt": "-- | You are given a 2 dimensional data, as a nested lists,\n--  which is similar to matrix, however, unlike matrices,\n--  each row may contain a different number of columns.\n--  Given lst, and integer x, find integers x in the list,\n--  and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n--  each tuple is a coordinate - (row, columns), starting with 0.\n--  Sort coordinates initially by rows in ascending order.\n--  Also, sort coordinates of the row by columns in descending order.\n--  Examples:\n--  >>> getRow [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1\n--  [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)]\n--  >>> getRow [] 1\n--  []\n--  >>> getRow [[],[1],[1,2,3]] 3\n--  [(2, 2)]\ngetRow :: [[Int]] -> Int -> [(Int, Int)]\ngetRow lst x =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_87_get_row.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = getRow\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 4),(1, 0),(2, 5),(2, 0)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6],[1,2,3,4,5,6]] 2 == [(0, 1),(1, 1),(2, 1),(3, 1),(4, 1),(5, 1)] then pure () else error \"assertion failed\"\n  if candidate [[1,2,3,4,5,6],[1,2,3,4,5,6],[1,1,3,4,5,6],[1,2,1,4,5,6],[1,2,3,1,5,6],[1,2,3,4,1,6],[1,2,3,4,5,1]] 1 == [(0, 0),(1, 0),(2, 1),(2, 0),(3, 2),(3, 0),(4, 3),(4, 0),(5, 4),(5, 0),(6, 5),(6, 0)] then pure () else error \"assertion failed\"\n  if candidate [] 1 == [] then pure () else error \"assertion failed\"\n  if candidate [[1]] 2 == [] then pure () else error \"assertion failed\"\n  if candidate [[],[1],[1,2,3]] 3 == [(2, 2)] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_88_sort_array", "language": "hs", "prompt": "-- | Given an array of non-negative integers, return a copy of the given array after sorting,\n--  you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n--  or sort it in descending order if the sum( first index value, last index value) is even.\n--  Note:\n--  * don't change the given array.\n--  Examples:\n--  >>> sortArray []\n--  []\n--  >>> sortArray [5]\n--  [5]\n--  >>> sortArray [2,4,3,0,1,5]\n--  [0,1,2,3,4,5]\n--  >>> sortArray [2,4,3,0,1,5,6]\n--  [6,5,4,3,2,1,0]\nsortArray :: [Int] -> [Int]\nsortArray array =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_88_sort_array.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sortArray\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [5] == [5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5] == [0,1,2,3,4,5] then pure () else error \"assertion failed\"\n  if candidate [2,4,3,0,1,5,6] == [6,5,4,3,2,1,0] then pure () else error \"assertion failed\"\n  if candidate [2,1] == [1,2] then pure () else error \"assertion failed\"\n  if candidate [15,42,87,32,11,0] == [0,11,15,32,42,87] then pure () else error \"assertion failed\"\n  if candidate [21,14,23,11] == [23,21,14,11] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_89_encrypt", "language": "hs", "prompt": "-- | Create a function encrypt that takes a string as an argument and\n--  returns a string encrypted with the alphabet being rotated. \n--  The alphabet should be rotated in a manner such that the letters \n--  shift down by two multiplied to two places.\n--  For example:\n--  >>> encrypt \"hi\"\n--  \"lm\"\n--  >>> encrypt \"asdfghjkl\"\n--  \"ewhjklnop\"\n--  >>> encrypt \"gf\"\n--  \"kj\"\n--  >>> encrypt \"et\"\n--  \"ix\"\nencrypt :: String -> String\nencrypt s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_89_encrypt.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = encrypt\n  if candidate \"hi\" == \"lm\" then pure () else error \"assertion failed\"\n  if candidate \"asdfghjkl\" == \"ewhjklnop\" then pure () else error \"assertion failed\"\n  if candidate \"gf\" == \"kj\" then pure () else error \"assertion failed\"\n  if candidate \"et\" == \"ix\" then pure () else error \"assertion failed\"\n  if candidate \"faewfawefaewg\" == \"jeiajeaijeiak\" then pure () else error \"assertion failed\"\n  if candidate \"hellomyfriend\" == \"lippsqcjvmirh\" then pure () else error \"assertion failed\"\n  if candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\" == \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\" then pure () else error \"assertion failed\"\n  if candidate \"a\" == \"e\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_8_sum_product", "language": "hs", "prompt": "-- | For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n--  Empty sum should be equal to 0 and empty product should be equal to 1.\n--  >>> sumProduct []\n--  (0, 1)\n--  >>> sumProduct [1,2,3,4]\n--  (10, 24)\nsumProduct :: [Int] -> (Int, Int)\nsumProduct numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_8_sum_product.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = sumProduct\n  if candidate [] == (0, 1) then pure () else error \"assertion failed\"\n  if candidate [1,1,1] == (3, 1) then pure () else error \"assertion failed\"\n  if candidate [100,0] == (100, 0) then pure () else error \"assertion failed\"\n  if candidate [3,5,7] == (15, 105) then pure () else error \"assertion failed\"\n  if candidate [10] == (10, 10) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_90_next_smallest", "language": "hs", "prompt": "-- | You are given a list of integers.\n--  Write a function next_smallest() that returns the 2nd smallest element of the list.\n--  Return None if there is no such element.\n--  >>> nextSmallest [1,2,3,4,5]\n--  Just (2)\n--  >>> nextSmallest [5,1,4,3,2]\n--  Just (2)\n--  >>> nextSmallest []\n--  Just (Nothing)\n--  >>> nextSmallest [1,1]\n--  Just (Nothing)\nnextSmallest :: [Int] -> Maybe Int\nnextSmallest lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_90_next_smallest.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = nextSmallest\n  if candidate [1,2,3,4,5] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [5,1,4,3,2] == Just (2) then pure () else error \"assertion failed\"\n  if candidate [] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [1,1,1,1,0] == Just (1) then pure () else error \"assertion failed\"\n  if candidate [1,1] == Just (Nothing) then pure () else error \"assertion failed\"\n  if candidate [(-35),34,12,(-45)] == Just ((-35)) then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_91_is_bored", "language": "hs", "prompt": "-- | You'll be given a string of words, and your task is to count the number\n--  of boredoms. A boredom is a sentence that starts with the word \"I\".\n--  Sentences are delimited by '.', '?' or '!'.\n--  For example:\n--  >>> isBored \"Hello world\"\n--  0\n--  >>> isBored \"The sky is blue. The sun is shining. I love this weather\"\n--  1\nisBored :: String -> Int\nisBored S =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_91_is_bored.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = isBored\n  if candidate \"Hello world\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"Is the sky blue?\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I love It !\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"bIt\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"I feel good today. I will be productive. will kill It\" == 2 then pure () else error \"assertion failed\"\n  if candidate \"You and I are going for a walk\" == 0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_92_any_int", "language": "hs", "prompt": "-- | Create a function that takes 3 numbers.\n--  Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n--  Returns false in any other cases.\n--  Examples\n--  >>> anyInt 5 2 7\n--  True\n--  >>> anyInt 3 2 2\n--  False\n--  >>> anyInt 3 (-2) 1\n--  True\n--  >>> anyInt 3.6 -2.2 2\n--  False\nanyInt :: Float -> Float -> Float -> Bool\nanyInt x y z =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_92_any_int.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = anyInt\n  if candidate 2.0 3.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.5 2.0 3.0 == False then pure () else error \"assertion failed\"\n  if candidate 1.5 5.0 3.5 == False then pure () else error \"assertion failed\"\n  if candidate 2.0 6.0 2.0 == False then pure () else error \"assertion failed\"\n  if candidate 4.0 2.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.2 2.2 2.2 == False then pure () else error \"assertion failed\"\n  if candidate (-4).0 6.0 2.0 == True then pure () else error \"assertion failed\"\n  if candidate 2.0 1.0 1.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == True then pure () else error \"assertion failed\"\n  if candidate 3.0 4.0 7.0 == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_93_encode", "language": "hs", "prompt": "-- | Write a function that takes a message, and encodes in such a \n--  way that it swaps case of all letters, replaces all vowels in \n--  the message with the letter that appears 2 places ahead of that \n--  vowel in the english alphabet. \n--  Assume only letters. \n--  Examples:\n--  >>> encode \"test\"\n--  \"TGST\"\n--  >>> encode \"This is a message\"\n--  \"tHKS KS C MGSSCGG\"\nencode :: String -> String\nencode message =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_93_encode.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = encode\n  if candidate \"TEST\" == \"tgst\" then pure () else error \"assertion failed\"\n  if candidate \"Mudasir\" == \"mWDCSKR\" then pure () else error \"assertion failed\"\n  if candidate \"YES\" == \"ygs\" then pure () else error \"assertion failed\"\n  if candidate \"This is a message\" == \"tHKS KS C MGSSCGG\" then pure () else error \"assertion failed\"\n  if candidate \"I DoNt KnOw WhAt tO WrItE\" == \"k dQnT kNqW wHcT Tq wRkTg\" then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_94_skjkasdkd", "language": "hs", "prompt": "-- | You are given a list of integers.\n--  You need to find the largest prime value and return the sum of its digits.\n--  Examples:\n--  >>> skjkasdkd [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3]\n--  10\n--  >>> skjkasdkd [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1]\n--  25\n--  >>> skjkasdkd [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3]\n--  13\n--  >>> skjkasdkd [0,724,32,71,99,32,6,0,5,91,83,0,5,6]\n--  11\n--  >>> skjkasdkd [0,81,12,3,1,21]\n--  3\n--  >>> skjkasdkd [0,8,1,2,1,7]\n--  7\nskjkasdkd :: [Int] -> Int\nskjkasdkd lst =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_94_skjkasdkd.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = skjkasdkd\n  if candidate [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] == 10 then pure () else error \"assertion failed\"\n  if candidate [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] == 25 then pure () else error \"assertion failed\"\n  if candidate [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] == 13 then pure () else error \"assertion failed\"\n  if candidate [0,724,32,71,99,32,6,0,5,91,83,0,5,6] == 11 then pure () else error \"assertion failed\"\n  if candidate [0,81,12,3,1,21] == 3 then pure () else error \"assertion failed\"\n  if candidate [0,8,1,2,1,7] == 7 then pure () else error \"assertion failed\"\n  if candidate [8191] == 19 then pure () else error \"assertion failed\"\n  if candidate [8191,123456,127,7] == 19 then pure () else error \"assertion failed\"\n  if candidate [127,97,8192] == 10 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_95_check_dict_case", "language": "hs", "prompt": "-- | Given a dictionary, return True if all keys are strings in lower \n--  case or all keys are strings in upper case, else return False.\n--  The function should return False is the given dictionary is empty.\n--  Examples:\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"b\", \"banana\")]\n--  True\n--  >>> checkDictCase [(\"a\", \"apple\"), (\"A\", \"banana\"), (\"B\", \"banana\")]\n--  False\n--  >>> checkDictCase [(\"a\", \"apple\"), (8, \"banana\"), (\"a\", \"apple\")]\n--  False\n--  >>> checkDictCase [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")]\n--  False\n--  >>> checkDictCase [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")]\n--  True\ncheckDictCase :: [(String, String)] -> Bool\ncheckDictCase dict =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_95_check_dict_case.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = checkDictCase\n  if candidate [(\"p\", \"pineapple\"), (\"b\", \"banana\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"A\", \"banana\"), (\"B\", \"banana\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"p\", \"pineapple\"), (\"5\", \"banana\"), (\"a\", \"apple\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"Name\", \"John\"), (\"Age\", \"36\"), (\"City\", \"Houston\")] == False then pure () else error \"assertion failed\"\n  if candidate [(\"STATE\", \"NC\"), (\"ZIP\", \"12345\")] == True then pure () else error \"assertion failed\"\n  if candidate [(\"fruit\", \"Orange\"), (\"taste\", \"Sweet\")] == True then pure () else error \"assertion failed\"\n  if candidate [] == False then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_96_count_up_to", "language": "hs", "prompt": "-- | Implement a function that takes an non-negative integer and returns an array of the first n\n--  integers that are prime numbers and less than n.\n--  for example:\n--  >>> countUpTo 5\n--  [2,3]\n--  >>> countUpTo 11\n--  [2,3,5,7]\n--  >>> countUpTo 0\n--  []\n--  >>> countUpTo 20\n--  [2,3,5,7,11,13,17,19]\n--  >>> countUpTo 1\n--  []\n--  >>> countUpTo 18\n--  [2,3,5,7,11,13,17]\ncountUpTo :: Int -> [Int]\ncountUpTo n =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_96_count_up_to.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = countUpTo\n  if candidate 5 == [2,3] then pure () else error \"assertion failed\"\n  if candidate 6 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 7 == [2,3,5] then pure () else error \"assertion failed\"\n  if candidate 10 == [2,3,5,7] then pure () else error \"assertion failed\"\n  if candidate 0 == [] then pure () else error \"assertion failed\"\n  if candidate 22 == [2,3,5,7,11,13,17,19] then pure () else error \"assertion failed\"\n  if candidate 1 == [] then pure () else error \"assertion failed\"\n  if candidate 18 == [2,3,5,7,11,13,17] then pure () else error \"assertion failed\"\n  if candidate 47 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43] then pure () else error \"assertion failed\"\n  if candidate 101 == [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_97_multiply", "language": "hs", "prompt": "-- | Complete the function that takes two integers and returns \n--  the product of their unit digits.\n--  Assume the input is always valid.\n--  Examples:\n--  >>> multiply 148 412\n--  16\n--  >>> multiply 19 28\n--  72\n--  >>> multiply 2020 1851\n--  0\n--  >>> multiply 14 (-15)\n--  20\nmultiply :: Int -> Int -> Int\nmultiply a b =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_97_multiply.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = multiply\n  if candidate 148 412 == 16 then pure () else error \"assertion failed\"\n  if candidate 19 28 == 72 then pure () else error \"assertion failed\"\n  if candidate 2020 1851 == 0 then pure () else error \"assertion failed\"\n  if candidate 14 (-15) == 20 then pure () else error \"assertion failed\"\n  if candidate 76 67 == 42 then pure () else error \"assertion failed\"\n  if candidate 17 27 == 49 then pure () else error \"assertion failed\"\n  if candidate 0 1 == 0 then pure () else error \"assertion failed\"\n  if candidate 0 0 == 0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_98_count_upper", "language": "hs", "prompt": "-- | Given a string s, count the number of uppercase vowels in even indices.\n--  For example:\n--  >>> countUpper \"aBCdEf\"\n--  1\n--  >>> countUpper \"abcdefg\"\n--  0\n--  >>> countUpper \"dBBE\"\n--  0\ncountUpper :: String -> Int\ncountUpper s =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_98_count_upper.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = countUpper\n  if candidate \"aBCdEf\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"abcdefg\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"dBBE\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"B\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"U\" == 1 then pure () else error \"assertion failed\"\n  if candidate \"\" == 0 then pure () else error \"assertion failed\"\n  if candidate \"EEEE\" == 2 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_99_closest_integer", "language": "hs", "prompt": "-- | Create a function that takes a value (string) representing a number\n--  and returns the closest integer to it. If the number is equidistant\n--  from two integers, round it away from zero.\n--  Examples\n--  >>> closestInteger \"10\"\n--  10\n--  >>> closestInteger \"15.3\"\n--  15\n--  Note:\n--  Rounding away from zero means that if the given number is equidistant\n--  from two integers, the one you should return is the one that is the\n--  farthest from zero. For example closest_integer(\"14.5\") should\n--  return 15 and closest_integer(\"-14.5\") should return -15.\nclosestInteger :: String -> Int\nclosestInteger value =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_99_closest_integer.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = closestInteger\n  if candidate \"10\" == 10 then pure () else error \"assertion failed\"\n  if candidate \"14.5\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"-15.5\" == (-16) then pure () else error \"assertion failed\"\n  if candidate \"15.3\" == 15 then pure () else error \"assertion failed\"\n  if candidate \"0\" == 0 then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
{"name": "HumanEval_9_rolling_max", "language": "hs", "prompt": "-- | From a given list of integers, generate a list of rolling maximum element found until given moment\n--  in the sequence.\n--  >>> rollingMax [1,2,3,2,3,4,2]\n--  [1,2,3,3,3,4,4]\nrollingMax :: [Int] -> [Int]\nrollingMax numbers =", "doctests": "transform", "original": "C:\\Users\\Thomas\\PycharmProjects\\MultiPL-E\\datasets\\..\\datasets\\originals-with-cleaned-doctests\\HumanEval_9_rolling_max.py", "prompt_terminology": "verbatim", "tests": "\nmain :: IO ()\nmain = do\n  let candidate = rollingMax\n  if candidate [] == [] then pure () else error \"assertion failed\"\n  if candidate [1,2,3,4] == [1,2,3,4] then pure () else error \"assertion failed\"\n  if candidate [4,3,2,1] == [4,4,4,4] then pure () else error \"assertion failed\"\n  if candidate [3,2,3,100,3] == [3,3,3,100,100] then pure () else error \"assertion failed\"\n  pure ()", "stop_tokens": ["\n\n", "\n{-", "\n-- |", "\n--", "\ntype", "\ndata", "\nnewtype"]}
