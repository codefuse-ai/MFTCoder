{"name": "mbpp_100_next_smallest_palindrome", "language": "swift", "prompt": "\n/// Write a function to find the next smallest palindrome of a specified integer, returned as an integer.\nfunc next_smallest_palindrome(num: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_100_next_smallest_palindrome.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_smallest_palindrome(num: 99) == 101)\nassert(next_smallest_palindrome(num: 1221) == 1331)\nassert(next_smallest_palindrome(num: 120) == 121)", "stop_tokens": ["\n}"]}
{"name": "mbpp_101_kth_element", "language": "swift", "prompt": "\n/// Write a function to find the kth element in the given array using 1-based indexing.\nfunc kth_element(arr: [Int], k: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_101_kth_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(kth_element(arr: [12, 3, 5, 7, 19], k: 2) == 3)\nassert(kth_element(arr: [17, 24, 8, 23], k: 3) == 8)\nassert(kth_element(arr: [16, 21, 25, 36, 4], k: 4) == 36)", "stop_tokens": ["\n}"]}
{"name": "mbpp_102_snake_to_camel", "language": "swift", "prompt": "\n/// Write a function to convert a snake case string to camel case string.\nfunc snake_to_camel(word: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_102_snake_to_camel.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(snake_to_camel(word: \"python_program\") == \"PythonProgram\")\nassert(snake_to_camel(word: \"python_language\") == \"PythonLanguage\")\nassert(snake_to_camel(word: \"programming_language\") == \"ProgrammingLanguage\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_103_eulerian_num", "language": "swift", "prompt": "\n/// Write a function to find the Eulerian number a(n, m).\nfunc eulerian_num(n: Int, m: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_103_eulerian_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(eulerian_num(n: 3, m: 1) == 4)\nassert(eulerian_num(n: 4, m: 1) == 11)\nassert(eulerian_num(n: 5, m: 3) == 26)", "stop_tokens": ["\n}"]}
{"name": "mbpp_104_sort_sublists", "language": "swift", "prompt": "\n/// Write a function to sort each sublist of strings in a given list of lists.\nfunc sort_sublists(input_list: [[String]]) -> [[String]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_104_sort_sublists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_sublists(input_list: [[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]]) == [[\"green\", \"orange\"], [\"black\", \"white\"], [\"black\", \"orange\", \"white\"]])\nassert(sort_sublists(input_list: [[\" red \", \"green\"], [\"blue \", \" black\"], [\" orange\", \"brown\"]]) == [[\" red \", \"green\"], [\" black\", \"blue \"], [\" orange\", \"brown\"]])\nassert(sort_sublists(input_list: [[\"zilver\", \"gold\"], [\"magnesium\", \"aluminium\"], [\"steel\", \"bronze\"]]) == [[\"gold\", \"zilver\"], [\"aluminium\", \"magnesium\"], [\"bronze\", \"steel\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_105_count", "language": "swift", "prompt": "\n/// Write a python function to count true booleans in the given list.\nfunc count(lst: [Bool]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_105_count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count(lst: [true, false, true]) == 2)\nassert(count(lst: [false, false]) == 0)\nassert(count(lst: [true, true, true]) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_106_add_lists", "language": "swift", "prompt": "\n/// Write a function to append the given list to the given tuples.\nfunc add_lists(test_list: [Int], test_tup: (Int, Int)) -> (Int, Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_106_add_lists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_lists(test_list: [5, 6, 7], test_tup: (9, 10)) == (9, 10, 5, 6, 7))\nassert(add_lists(test_list: [6, 7, 8], test_tup: (10, 11)) == (10, 11, 6, 7, 8))\nassert(add_lists(test_list: [7, 8, 9], test_tup: (11, 12)) == (11, 12, 7, 8, 9))", "stop_tokens": ["\n}"]}
{"name": "mbpp_108_merge_sorted_list", "language": "swift", "prompt": "\n/// Write a function to merge three lists into a single sorted list.\nfunc merge_sorted_list(num1: [Int], num2: [Int], num3: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_108_merge_sorted_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(merge_sorted_list(num1: [25, 24, 15, 4, 5, 29, 110], num2: [19, 20, 11, 56, 25, 233, 154], num3: [24, 26, 54, 48]) == [4, 5, 11, 15, 19, 20, 24, 24, 25, 25, 26, 29, 48, 54, 56, 110, 154, 233])\nassert(merge_sorted_list(num1: [1, 3, 5, 6, 8, 9], num2: [2, 5, 7, 11], num3: [1, 4, 7, 8, 12]) == [1, 1, 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12])\nassert(merge_sorted_list(num1: [18, 14, 10, 9, 8, 7, 9, 3, 2, 4, 1], num2: [25, 35, 22, 85, 14, 65, 75, 25, 58], num3: [12, 74, 9, 50, 61, 41]) == [1, 2, 3, 4, 7, 8, 9, 9, 9, 10, 12, 14, 14, 18, 22, 25, 25, 35, 41, 50, 58, 61, 65, 74, 75, 85])", "stop_tokens": ["\n}"]}
{"name": "mbpp_109_odd_Equivalent", "language": "swift", "prompt": "\n/// Write a python function to find the number of numbers with an odd value when rotating a binary string the given number of times.\nfunc odd_Equivalent(s: String, n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_109_odd_Equivalent.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_Equivalent(s: \"011001\", n: 6) == 3)\nassert(odd_Equivalent(s: \"11011\", n: 5) == 4)\nassert(odd_Equivalent(s: \"1010\", n: 4) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_113_check_integer", "language": "swift", "prompt": "\n/// Write a function to check if a string represents an integer or not.\nfunc check_integer(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_113_check_integer.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_integer(text: \"python\") == false)\nassert(check_integer(text: \"1\") == true)\nassert(check_integer(text: \"12345\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_115_empty_dit", "language": "swift", "prompt": "\n/// Write a function to check whether all dictionaries in a list are empty or not.\nfunc empty_dit(list1: AnyHashable) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_115_empty_dit.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(empty_dit(list1: [[:] as [AnyHashable : AnyHashable], [:] as [AnyHashable : AnyHashable], [:] as [AnyHashable : AnyHashable]]) == true)\nassert(empty_dit(list1: [:] as [AnyHashable : AnyHashable]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_116_tuple_to_int", "language": "swift", "prompt": "\n/// Write a function to convert a given tuple of positive integers into a single integer.\nfunc tuple_to_int(nums: (Int, Int, Int)) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_116_tuple_to_int.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tuple_to_int(nums: (1, 2, 3)) == 123)\nassert(tuple_to_int(nums: (4, 5, 6)) == 456)\nassert(tuple_to_int(nums: (5, 6, 7)) == 567)", "stop_tokens": ["\n}"]}
{"name": "mbpp_117_list_to_float", "language": "swift", "prompt": "\n/// Write a function to convert all possible convertible elements in a list of lists to floats.\nfunc list_to_float(test_list: [(String, String)]) -> [(Double, Double)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_117_list_to_float.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(list_to_float(test_list: [(\"3\", \"4\"), (\"1\", \"26.45\"), (\"7.32\", \"8\"), (\"4\", \"8\")]) == [(3.0, 4.0), (1.0, 26.45), (7.32, 8.0), (4.0, 8.0)])\nassert(list_to_float(test_list: [(\"4\", \"4\"), (\"2\", \"27\"), (\"4.12\", \"9\"), (\"7\", \"11\")]) == [(4.0, 4.0), (2.0, 27.0), (4.12, 9.0), (7.0, 11.0)])\nassert(list_to_float(test_list: [(\"6\", \"78\"), (\"5\", \"26.45\"), (\"1.33\", \"4\"), (\"82\", \"13\")]) == [(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_118_string_to_list", "language": "swift", "prompt": "\n/// Write a function to convert a string to a list of strings split on the space character.\nfunc string_to_list(string: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_118_string_to_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_list(string: \"python programming\") == [\"python\", \"programming\"])\nassert(string_to_list(string: \"lists tuples strings\") == [\"lists\", \"tuples\", \"strings\"])\nassert(string_to_list(string: \"write a program\") == [\"write\", \"a\", \"program\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_119_search", "language": "swift", "prompt": "\n/// Write a python function to find the element that appears only once in a sorted array.\nfunc search(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_119_search.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(search(arr: [1, 1, 2, 2, 3]) == 3)\nassert(search(arr: [1, 1, 3, 3, 4, 4, 5, 5, 7, 7, 8]) == 8)\nassert(search(arr: [1, 2, 2, 3, 3, 4, 4]) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_11_remove_Occ", "language": "swift", "prompt": "\n/// Write a python function to remove first and last occurrence of a given character from the string.\nfunc remove_Occ(s: String, ch: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_11_remove_Occ.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_Occ(s: \"hello\", ch: \"l\") == \"heo\")\nassert(remove_Occ(s: \"abcda\", ch: \"a\") == \"bcd\")\nassert(remove_Occ(s: \"PHP\", ch: \"P\") == \"H\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_120_max_product_tuple", "language": "swift", "prompt": "\n/// Write a function to find the maximum absolute product between numbers in pairs of tuples within a given list.\nfunc max_product_tuple(list1: [(Int, Int)]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_120_max_product_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_product_tuple(list1: [(2, 7), (2, 6), (1, 8), (4, 9)]) == 36)\nassert(max_product_tuple(list1: [(10, 20), (15, 2), (5, 10)]) == 200)\nassert(max_product_tuple(list1: [(11, 44), (10, 15), (20, 5), (12, 9)]) == 484)", "stop_tokens": ["\n}"]}
{"name": "mbpp_123_amicable_numbers_sum", "language": "swift", "prompt": "\n/// Write a function to sum all amicable numbers from 1 to a specified number.\nfunc amicable_numbers_sum(limit: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_123_amicable_numbers_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(amicable_numbers_sum(limit: 999) == 504)\nassert(amicable_numbers_sum(limit: 9999) == 31626)\nassert(amicable_numbers_sum(limit: 99) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_125_find_length", "language": "swift", "prompt": "\n/// Write a function to find the maximum difference between the number of 0s and number of 1s in any sub-string of the given binary string.\nfunc find_length(string: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_125_find_length.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_length(string: \"11000010001\") == 6)\nassert(find_length(string: \"10111\") == 1)\nassert(find_length(string: \"11011101100101\") == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_126_sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of common divisors of two given numbers.\nfunc sum(a: Int, b: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_126_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum(a: 10, b: 15) == 6)\nassert(sum(a: 100, b: 150) == 93)\nassert(sum(a: 4, b: 6) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_127_multiply_int", "language": "swift", "prompt": "\n/// Write a function to multiply two integers.\nfunc multiply_int(x: Int, y: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_127_multiply_int.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply_int(x: 10, y: 20) == 200)\nassert(multiply_int(x: 5, y: 10) == 50)\nassert(multiply_int(x: 4, y: 8) == 32)", "stop_tokens": ["\n}"]}
{"name": "mbpp_128_long_words", "language": "swift", "prompt": "\n/// Write a function to find words that are longer than n characters from a given list of words.\nfunc long_words(n: Int, str: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_128_long_words.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(long_words(n: 3, str: \"python is a programming language\") == [\"python\", \"programming\", \"language\"])\nassert(long_words(n: 2, str: \"writing a program\") == [\"writing\", \"program\"])\nassert(long_words(n: 5, str: \"sorting list\") == [\"sorting\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_129_magic_square_test", "language": "swift", "prompt": "\n/// Write a function to calculate whether the matrix is a magic square.\nfunc magic_square_test(my_matrix: [[Int]]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_129_magic_square_test.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(magic_square_test(my_matrix: [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]]) == true)\nassert(magic_square_test(my_matrix: [[2, 7, 6], [9, 5, 1], [4, 3, 8]]) == true)\nassert(magic_square_test(my_matrix: [[2, 7, 6], [9, 5, 1], [4, 3, 7]]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_12_sort_matrix", "language": "swift", "prompt": "\n/// Write a function to sort a given matrix in ascending order according to the sum of its rows.\nfunc sort_matrix(M: [[Int]]) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_12_sort_matrix.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_matrix(M: [[1, 2, 3], [2, 4, 5], [1, 1, 1]]) == [[1, 1, 1], [1, 2, 3], [2, 4, 5]])\nassert(sort_matrix(M: [[1, 2, 3], [-2, 4, -5], [1, -1, 1]]) == [[-2, 4, -5], [1, -1, 1], [1, 2, 3]])\nassert(sort_matrix(M: [[5, 8, 9], [6, 4, 3], [2, 1, 4]]) == [[2, 1, 4], [6, 4, 3], [5, 8, 9]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_130_max_occurrences", "language": "swift", "prompt": "\n/// Write a function to find the item with maximum frequency in a given list.\nfunc max_occurrences(nums: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_130_max_occurrences.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_occurrences(nums: [2, 3, 8, 4, 7, 9, 8, 2, 6, 5, 1, 6, 1, 2, 3, 2, 4, 6, 9, 1, 2]) == 2)\nassert(max_occurrences(nums: [2, 3, 8, 4, 7, 9, 8, 7, 9, 15, 14, 10, 12, 13, 16, 18]) == 8)\nassert(max_occurrences(nums: [10, 20, 20, 30, 40, 90, 80, 50, 30, 20, 50, 10]) == 20)", "stop_tokens": ["\n}"]}
{"name": "mbpp_131_reverse_vowels", "language": "swift", "prompt": "\n/// Write a python function to reverse only the vowels of a given string (where y is not a vowel).\nfunc reverse_vowels(str1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_131_reverse_vowels.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_vowels(str1: \"Python\") == \"Python\")\nassert(reverse_vowels(str1: \"USA\") == \"ASU\")\nassert(reverse_vowels(str1: \"ab\") == \"ab\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_132_tup_string", "language": "swift", "prompt": "\n/// Write a function to convert a list to a string.\nfunc tup_string(tup1: [String]) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_132_tup_string.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tup_string(tup1: [\"e\", \"x\", \"e\", \"r\", \"c\", \"i\", \"s\", \"e\", \"s\"]) == \"exercises\")\nassert(tup_string(tup1: [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"]) == \"python\")\nassert(tup_string(tup1: [\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"]) == \"program\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_133_sum_negativenum", "language": "swift", "prompt": "\n/// Write a function to calculate the sum of the negative numbers of a given list of numbers.\nfunc sum_negativenum(nums: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_133_sum_negativenum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_negativenum(nums: [2, 4, -6, -9, 11, -12, 14, -5, 17]) == -32)\nassert(sum_negativenum(nums: [10, 15, -14, 13, -18, 12, -20]) == -52)\nassert(sum_negativenum(nums: [19, -65, 57, 39, 152, -639, 121, 44, 90, -190]) == -894)", "stop_tokens": ["\n}"]}
{"name": "mbpp_135_hexagonal_num", "language": "swift", "prompt": "\n/// Write a function to find the nth hexagonal number.\nfunc hexagonal_num(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_135_hexagonal_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(hexagonal_num(n: 10) == 190)\nassert(hexagonal_num(n: 5) == 45)\nassert(hexagonal_num(n: 7) == 91)", "stop_tokens": ["\n}"]}
{"name": "mbpp_138_is_Sum_Of_Powers_Of_Two", "language": "swift", "prompt": "\n/// Write a python function to check whether the given number can be represented as sum of non-zero powers of 2 or not.\nfunc is_Sum_Of_Powers_Of_Two(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_138_is_Sum_Of_Powers_Of_Two.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_Sum_Of_Powers_Of_Two(n: 10) == true)\nassert(is_Sum_Of_Powers_Of_Two(n: 7) == false)\nassert(is_Sum_Of_Powers_Of_Two(n: 14) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_141_pancake_sort", "language": "swift", "prompt": "\n/// Write a function to sort a list of elements.\nfunc pancake_sort(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_141_pancake_sort.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pancake_sort(nums: [15, 79, 25, 38, 69]) == [15, 25, 38, 69, 79])\nassert(pancake_sort(nums: [98, 12, 54, 36, 85]) == [12, 36, 54, 85, 98])\nassert(pancake_sort(nums: [41, 42, 32, 12, 23]) == [12, 23, 32, 41, 42])", "stop_tokens": ["\n}"]}
{"name": "mbpp_142_count_samepair", "language": "swift", "prompt": "\n/// Write a function to count number items that are identical in the same position of three given lists.\nfunc count_samepair(list1: [Int], list2: [Int], list3: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_142_count_samepair.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_samepair(list1: [1, 2, 3, 4, 5, 6, 7, 8], list2: [2, 2, 3, 1, 2, 6, 7, 9], list3: [2, 1, 3, 1, 2, 6, 7, 9]) == 3)\nassert(count_samepair(list1: [1, 2, 3, 4, 5, 6, 7, 8], list2: [2, 2, 3, 1, 2, 6, 7, 8], list3: [2, 1, 3, 1, 2, 6, 7, 8]) == 4)\nassert(count_samepair(list1: [1, 2, 3, 4, 2, 6, 7, 8], list2: [2, 2, 3, 1, 2, 6, 7, 8], list3: [2, 1, 3, 1, 2, 6, 7, 8]) == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_143_find_lists", "language": "swift", "prompt": "\n/// Write a function to find number of lists present in the given list.\nfunc find_lists(Input: [AnyHashable]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_143_find_lists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_lists(Input: [[1, 2, 3, 4], [5, 6, 7, 8]]) == 2)\nassert(find_lists(Input: [[1, 2], [3, 4], [5, 6]]) == 3)\nassert(find_lists(Input: [9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_145_max_Abs_Diff", "language": "swift", "prompt": "\n/// Write a python function to find the maximum difference between any two elements in a given array.\nfunc max_Abs_Diff(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_145_max_Abs_Diff.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_Abs_Diff(arr: [2, 1, 5, 3]) == 4)\nassert(max_Abs_Diff(arr: [9, 3, 2, 5, 1]) == 8)\nassert(max_Abs_Diff(arr: [3, 2, 1]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_14_find_Volume", "language": "swift", "prompt": "\n/// Write a python function to find the volume of a triangular prism.\nfunc find_Volume(l: Int, b: Int, h: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_14_find_Volume.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Volume(l: 10, b: 8, h: 6) == 240)\nassert(find_Volume(l: 3, b: 2, h: 2) == 6)\nassert(find_Volume(l: 1, b: 2, h: 1) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_160_find_solution", "language": "swift", "prompt": "\n/// Write a function that returns integers x and y that satisfy ax + by = n as a tuple, or return None if no solution exists.\nfunc find_solution(a: Int, b: Int, n: Int) -> (Int, Int)? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_160_find_solution.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_solution(a: 2, b: 3, n: 7) == (2, 1))\nassert(find_solution(a: 4, b: 2, n: 7) == nil)\nassert(find_solution(a: 1, b: 13, n: 17) == (4, 1))", "stop_tokens": ["\n}"]}
{"name": "mbpp_161_remove_elements", "language": "swift", "prompt": "\n/// Write a function to remove all elements from a given list present in another list.\nfunc remove_elements(list1: [Int], list2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_161_remove_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_elements(list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], list2: [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 10])\nassert(remove_elements(list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], list2: [1, 3, 5, 7]) == [2, 4, 6, 8, 9, 10])\nassert(remove_elements(list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], list2: [5, 7]) == [1, 2, 3, 4, 6, 8, 9, 10])", "stop_tokens": ["\n}"]}
{"name": "mbpp_162_sum_series", "language": "swift", "prompt": "\n/// Write a function to calculate the sum (n - 2*i) from i=0 to n // 2, for instance n + (n-2) + (n-4)... (until n-x =< 0).\nfunc sum_series(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_162_sum_series.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_series(n: 6) == 12)\nassert(sum_series(n: 10) == 30)\nassert(sum_series(n: 9) == 25)", "stop_tokens": ["\n}"]}
{"name": "mbpp_164_are_equivalent", "language": "swift", "prompt": "\n/// Write a function to determine if the sum of the divisors of two integers are the same.\nfunc are_equivalent(num1: Int, num2: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_164_are_equivalent.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(are_equivalent(num1: 36, num2: 57) == false)\nassert(are_equivalent(num1: 2, num2: 4) == false)\nassert(are_equivalent(num1: 23, num2: 47) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_165_count_char_position", "language": "swift", "prompt": "\n/// Write a function to count the number of characters in a string that occur at the same position in the string as in the English alphabet (case insensitive).\nfunc count_char_position(str1: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_165_count_char_position.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_char_position(str1: \"xbcefg\") == 2)\nassert(count_char_position(str1: \"ABcED\") == 3)\nassert(count_char_position(str1: \"AbgdeF\") == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_166_find_even_pair", "language": "swift", "prompt": "\n/// Write a function that counts the number of pairs of integers in a list that xor to an even number.\nfunc find_even_pair(A: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_166_find_even_pair.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_even_pair(A: [5, 4, 7, 2, 1]) == 4)\nassert(find_even_pair(A: [7, 2, 8, 1, 0, 5, 11]) == 9)\nassert(find_even_pair(A: [1, 2, 3]) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_167_next_power_of_2", "language": "swift", "prompt": "\n/// Write a python function to find the smallest power of 2 greater than or equal to n.\nfunc next_power_of_2(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_167_next_power_of_2.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_power_of_2(n: 0) == 1)\nassert(next_power_of_2(n: 5) == 8)\nassert(next_power_of_2(n: 17) == 32)", "stop_tokens": ["\n}"]}
{"name": "mbpp_168_frequency", "language": "swift", "prompt": "\n/// Write a function to count the number of occurrences of a number in a given list.\nfunc frequency(a: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_168_frequency.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(frequency(a: [1, 2, 3], x: 4) == 0)\nassert(frequency(a: [1, 2, 2, 3, 3, 3, 4], x: 3) == 3)\nassert(frequency(a: [0, 1, 2, 3, 1, 2], x: 1) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_16_text_lowercase_underscore", "language": "swift", "prompt": "\n/// Write a function to that returns true if the input string contains sequences of lowercase letters joined with an underscore and false otherwise.\nfunc text_lowercase_underscore(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_16_text_lowercase_underscore.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_lowercase_underscore(text: \"aab_cbbbc\") == true)\nassert(text_lowercase_underscore(text: \"aab_Abbbc\") == false)\nassert(text_lowercase_underscore(text: \"Aaab_abbbc\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_170_sum_range_list", "language": "swift", "prompt": "\n/// Write a function to find the sum of numbers in a list within a range specified by two indices.\nfunc sum_range_list(list1: [Int], m: Int, n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_170_sum_range_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_range_list(list1: [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], m: 8, n: 10) == 29)\nassert(sum_range_list(list1: [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], m: 5, n: 7) == 16)\nassert(sum_range_list(list1: [2, 1, 5, 6, 8, 3, 4, 9, 10, 11, 8, 12], m: 7, n: 10) == 38)", "stop_tokens": ["\n}"]}
{"name": "mbpp_171_perimeter_pentagon", "language": "swift", "prompt": "\n/// Write a function to find the perimeter of a regular pentagon from the length of its sides.\nfunc perimeter_pentagon(a: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_171_perimeter_pentagon.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(perimeter_pentagon(a: 5) == 25)\nassert(perimeter_pentagon(a: 10) == 50)\nassert(perimeter_pentagon(a: 15) == 75)", "stop_tokens": ["\n}"]}
{"name": "mbpp_172_count_occurance", "language": "swift", "prompt": "\n/// Write a function to count the number of occurence of the string 'std' in a given string.\nfunc count_occurance(s: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_172_count_occurance.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_occurance(s: \"letstdlenstdporstd\") == 3)\nassert(count_occurance(s: \"truststdsolensporsd\") == 1)\nassert(count_occurance(s: \"makestdsostdworthit\") == 2)\nassert(count_occurance(s: \"stds\") == 1)\nassert(count_occurance(s: \"\") == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_17_square_perimeter", "language": "swift", "prompt": "\n/// Write a function that returns the perimeter of a square given its side length as input.\nfunc square_perimeter(a: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_17_square_perimeter.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(square_perimeter(a: 10) == 40)\nassert(square_perimeter(a: 5) == 20)\nassert(square_perimeter(a: 4) == 16)", "stop_tokens": ["\n}"]}
{"name": "mbpp_18_remove_dirty_chars", "language": "swift", "prompt": "\n/// Write a function to remove characters from the first string which are present in the second string.\nfunc remove_dirty_chars(string: String, second_string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_18_remove_dirty_chars.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_dirty_chars(string: \"probasscurve\", second_string: \"pros\") == \"bacuve\")\nassert(remove_dirty_chars(string: \"digitalindia\", second_string: \"talent\") == \"digiidi\")\nassert(remove_dirty_chars(string: \"exoticmiles\", second_string: \"toxic\") == \"emles\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_19_test_duplicate", "language": "swift", "prompt": "\n/// Write a function to find whether a given array of integers contains any duplicate element.\nfunc test_duplicate(arraynums: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_19_test_duplicate.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(test_duplicate(arraynums: [1, 2, 3, 4, 5]) == false)\nassert(test_duplicate(arraynums: [1, 2, 3, 4, 4]) == true)\nassert(test_duplicate(arraynums: [1, 1, 2, 2, 3, 3, 4, 4, 5]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_20_is_woodall", "language": "swift", "prompt": "\n/// Write a function to check if the given number is woodball or not.\nfunc is_woodall(x: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_20_is_woodall.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_woodall(x: 383) == true)\nassert(is_woodall(x: 254) == false)\nassert(is_woodall(x: 200) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_222_check_type", "language": "swift", "prompt": "\n/// Write a function to check if all the elements in tuple have same data type or not.\nfunc check_type(test_tuple: AnyHashable) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_222_check_type.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_type(test_tuple: (5, 6, 7, 3, 5, 6)) == true)\nassert(check_type(test_tuple: (1, 2, \"4\")) == false)\nassert(check_type(test_tuple: (3, 2, 1, 4, 5)) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_223_is_majority", "language": "swift", "prompt": "\n/// Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\nfunc is_majority(arr: [Int], n: Int, x: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_223_is_majority.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_majority(arr: [1, 2, 3, 3, 3, 3, 10], n: 7, x: 3) == true)\nassert(is_majority(arr: [1, 1, 2, 4, 4, 4, 6, 6], n: 8, x: 4) == false)\nassert(is_majority(arr: [1, 1, 1, 2, 2], n: 5, x: 1) == true)\nassert(is_majority(arr: [1, 1, 2, 2], n: 5, x: 1) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_224_count_Set_Bits", "language": "swift", "prompt": "\n/// Write a python function to count the number of set bits (binary digits with value 1) in a given number.\nfunc count_Set_Bits(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_224_count_Set_Bits.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_Set_Bits(n: 2) == 1)\nassert(count_Set_Bits(n: 4) == 1)\nassert(count_Set_Bits(n: 6) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_226_odd_values_string", "language": "swift", "prompt": "\n/// Write a python function to remove the characters which have odd index values of a given string.\nfunc odd_values_string(str: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_226_odd_values_string.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_values_string(str: \"abcdef\") == \"ace\")\nassert(odd_values_string(str: \"python\") == \"pto\")\nassert(odd_values_string(str: \"data\") == \"dt\")\nassert(odd_values_string(str: \"lambs\") == \"lms\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_227_min_of_three", "language": "swift", "prompt": "\n/// Write a function to find minimum of three numbers.\nfunc min_of_three(a: Int, b: Int, c: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_227_min_of_three.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_of_three(a: 10, b: 20, c: 0) == 0)\nassert(min_of_three(a: 19, b: 15, c: 18) == 15)\nassert(min_of_three(a: -10, b: -20, c: -30) == -30)", "stop_tokens": ["\n}"]}
{"name": "mbpp_228_all_Bits_Set_In_The_Given_Range", "language": "swift", "prompt": "\n/// Write a python function to check whether all the bits are unset in the given range or not.\nfunc all_Bits_Set_In_The_Given_Range(n: Int, l: Int, r: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_228_all_Bits_Set_In_The_Given_Range.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_Bits_Set_In_The_Given_Range(n: 4, l: 1, r: 2) == true)\nassert(all_Bits_Set_In_The_Given_Range(n: 17, l: 2, r: 4) == true)\nassert(all_Bits_Set_In_The_Given_Range(n: 39, l: 4, r: 6) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_229_re_arrange_array", "language": "swift", "prompt": "\n/// Write a function that takes in an array and an integer n, and re-arranges the first n elements of the given array so that all negative elements appear before positive ones, and where the relative order among negative and positive elements is preserved.\nfunc re_arrange_array(arr: [Int], n: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_229_re_arrange_array.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(re_arrange_array(arr: [-1, 2, -3, 4, 5, 6, -7, 8, 9], n: 9) == [-1, -3, -7, 4, 5, 6, 2, 8, 9])\nassert(re_arrange_array(arr: [12, -14, -26, 13, 15], n: 5) == [-14, -26, 12, 13, 15])\nassert(re_arrange_array(arr: [10, 24, 36, -42, -39, -78, 85], n: 7) == [-42, -39, -78, 10, 24, 36, 85])", "stop_tokens": ["\n}"]}
{"name": "mbpp_230_replace_blank", "language": "swift", "prompt": "\n/// Write a function that takes in a string and character, replaces blank spaces in the string with the character, and returns the string.\nfunc replace_blank(str1: String, char: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_230_replace_blank.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_blank(str1: \"hello people\", char: \"@\") == \"hello@people\")\nassert(replace_blank(str1: \"python program language\", char: \"$\") == \"python$program$language\")\nassert(replace_blank(str1: \"blank space\", char: \"-\") == \"blank-space\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_234_volume_cube", "language": "swift", "prompt": "\n/// Write a function to find the volume of a cube given its side length.\nfunc volume_cube(l: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_234_volume_cube.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(volume_cube(l: 3) == 27)\nassert(volume_cube(l: 2) == 8)\nassert(volume_cube(l: 5) == 125)", "stop_tokens": ["\n}"]}
{"name": "mbpp_237_check_occurences", "language": "swift", "prompt": "\n/// Write a function that takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\nfunc check_occurences(test_list: [(Int, Int)]) -> [(Int, Int) : Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_237_check_occurences.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_occurences(test_list: [(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == [(1, 3) : 2, (2, 5) : 2, (3, 6) : 1])\nassert(check_occurences(test_list: [(4, 2), (2, 4), (3, 6), (6, 3), (7, 4)]) == [(2, 4) : 2, (3, 6) : 2, (4, 7) : 1])\nassert(check_occurences(test_list: [(13, 2), (11, 23), (12, 25), (25, 12), (16, 23)]) == [(2, 13) : 1, (11, 23) : 1, (12, 25) : 2, (16, 23) : 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_238_number_of_substrings", "language": "swift", "prompt": "\n/// Write a python function to count the number of non-empty substrings of a given string.\nfunc number_of_substrings(str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_238_number_of_substrings.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(number_of_substrings(str: \"abc\") == 6)\nassert(number_of_substrings(str: \"abcd\") == 10)\nassert(number_of_substrings(str: \"abcde\") == 15)", "stop_tokens": ["\n}"]}
{"name": "mbpp_239_get_total_number_of_sequences", "language": "swift", "prompt": "\n/// Write a function that takes in positive integers m and n and finds the number of possible sequences of length n, such that each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\nfunc get_total_number_of_sequences(m: Int, n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_239_get_total_number_of_sequences.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_total_number_of_sequences(m: 10, n: 4) == 4)\nassert(get_total_number_of_sequences(m: 5, n: 2) == 6)\nassert(get_total_number_of_sequences(m: 16, n: 3) == 84)", "stop_tokens": ["\n}"]}
{"name": "mbpp_240_replace_list", "language": "swift", "prompt": "\n/// Write a function that takes in two lists and replaces the last element of the first list with the elements of the second list.\nfunc replace_list(list1: [AnyHashable], list2: [AnyHashable]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_240_replace_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_list(list1: [1, 3, 5, 7, 9, 10], list2: [2, 4, 6, 8]) == [1, 3, 5, 7, 9, 2, 4, 6, 8])\nassert(replace_list(list1: [1, 2, 3, 4, 5], list2: [5, 6, 7, 8]) == [1, 2, 3, 4, 5, 6, 7, 8])\nassert(replace_list(list1: [\"red\", \"blue\", \"green\"], list2: [\"yellow\"]) == [\"red\", \"blue\", \"yellow\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_242_count_charac", "language": "swift", "prompt": "\n/// Write a function to count the total number of characters in a string.\nfunc count_charac(str1: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_242_count_charac.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_charac(str1: \"python programming\") == 18)\nassert(count_charac(str1: \"language\") == 8)\nassert(count_charac(str1: \"words\") == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_244_next_Perfect_Square", "language": "swift", "prompt": "\n/// Write a python function to find the next perfect square greater than a given number.\nfunc next_Perfect_Square(N: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_244_next_Perfect_Square.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(next_Perfect_Square(N: 35) == 36)\nassert(next_Perfect_Square(N: 6) == 9)\nassert(next_Perfect_Square(N: 9) == 16)", "stop_tokens": ["\n}"]}
{"name": "mbpp_245_max_sum", "language": "swift", "prompt": "\n/// Write a function that takes an array and finds the maximum sum of a bitonic subsequence for the given array, where a sequence is bitonic if it is first increasing and then decreasing.\nfunc max_sum(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_245_max_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_sum(arr: [1, 15, 51, 45, 33, 100, 12, 18, 9]) == 194)\nassert(max_sum(arr: [80, 60, 30, 40, 20, 10]) == 210)\nassert(max_sum(arr: [2, 3, 14, 16, 21, 23, 29, 30]) == 138)", "stop_tokens": ["\n}"]}
{"name": "mbpp_247_lps", "language": "swift", "prompt": "\n/// Write a function to find the length of the longest palindromic subsequence in the given string.\nfunc lps(str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_247_lps.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(lps(str: \"TENS FOR TENS\") == 5)\nassert(lps(str: \"CARDIO FOR CARDS\") == 7)\nassert(lps(str: \"PART OF THE JOURNEY IS PART\") == 9)", "stop_tokens": ["\n}"]}
{"name": "mbpp_249_intersection_array", "language": "swift", "prompt": "\n/// Write a function to find the intersection of two arrays.\nfunc intersection_array(array_nums1: [Int], array_nums2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_249_intersection_array.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(intersection_array(array_nums1: [1, 2, 3, 5, 7, 8, 9, 10], array_nums2: [1, 2, 4, 8, 9]) == [1, 2, 8, 9])\nassert(intersection_array(array_nums1: [1, 2, 3, 5, 7, 8, 9, 10], array_nums2: [3, 5, 7, 9]) == [3, 5, 7, 9])\nassert(intersection_array(array_nums1: [1, 2, 3, 5, 7, 8, 9, 10], array_nums2: [10, 20, 30, 40]) == [10])", "stop_tokens": ["\n}"]}
{"name": "mbpp_250_count_X", "language": "swift", "prompt": "\n/// Write a python function that takes in a tuple and an element and counts the occcurences of the element in the list.\nfunc count_X(tup: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_250_count_X.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_X(tup: [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], x: 4) == 0)\nassert(count_X(tup: [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], x: 10) == 3)\nassert(count_X(tup: [10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2], x: 8) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_251_insert_element", "language": "swift", "prompt": "\n/// Write a function that takes in a list and an element and inserts the element before each element in the list, and returns the resulting list.\nfunc insert_element(list: [String], element: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_251_insert_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(insert_element(list: [\"Red\", \"Green\", \"Black\"], element: \"c\") == [\"c\", \"Red\", \"c\", \"Green\", \"c\", \"Black\"])\nassert(insert_element(list: [\"python\", \"java\"], element: \"program\") == [\"program\", \"python\", \"program\", \"java\"])\nassert(insert_element(list: [\"happy\", \"sad\"], element: \"laugh\") == [\"laugh\", \"happy\", \"laugh\", \"sad\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_252_convert", "language": "swift", "prompt": "\n/// Write a python function to convert complex numbers to polar coordinates.\nfunc convert(numbers: Int) -> (Double, Double) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_252_convert.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(convert(numbers: 1) == (1.0, 0.0))\nassert(convert(numbers: 4) == (4.0, 0.0))\nassert(convert(numbers: 5) == (5.0, 0.0))", "stop_tokens": ["\n}"]}
{"name": "mbpp_253_count_integer", "language": "swift", "prompt": "\nenum Value: Equatable, Hashable {\n    case intValue(Int)\n    case stringValue(String)\n    case doubleValue(Double)\n}\n\n            \n/// Write a python function that returns the number of integer elements in a given list.\nfunc count_integer(list1: [Value]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_253_count_integer.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_integer(list1: [.intValue(1), .intValue(2), .stringValue(\"abc\"), .doubleValue(1.2)]) == 2)\nassert(count_integer(list1: [.intValue(1), .intValue(2), .intValue(3)]) == 3)\nassert(count_integer(list1: [.intValue(1), .doubleValue(1.2), .intValue(4), .doubleValue(5.1)]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_255_combinations_colors", "language": "swift", "prompt": "\n/// Write a function that takes in a list and length n, and generates all combinations (with repetition) of the elements of the list and returns a list with a list for each combination.\nfunc combinations_colors(l: [String], n: Int) -> [[String]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_255_combinations_colors.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(combinations_colors(l: [\"Red\", \"Green\", \"Blue\"], n: 1) == [[\"Red\"], [\"Green\"], [\"Blue\"]])\nassert(combinations_colors(l: [\"Red\", \"Green\", \"Blue\"], n: 2) == [[\"Red\", \"Red\"], [\"Red\", \"Green\"], [\"Red\", \"Blue\"], [\"Green\", \"Green\"], [\"Green\", \"Blue\"], [\"Blue\", \"Blue\"]])\nassert(combinations_colors(l: [\"Red\", \"Green\", \"Blue\"], n: 3) == [[\"Red\", \"Red\", \"Red\"], [\"Red\", \"Red\", \"Green\"], [\"Red\", \"Red\", \"Blue\"], [\"Red\", \"Green\", \"Green\"], [\"Red\", \"Green\", \"Blue\"], [\"Red\", \"Blue\", \"Blue\"], [\"Green\", \"Green\", \"Green\"], [\"Green\", \"Green\", \"Blue\"], [\"Green\", \"Blue\", \"Blue\"], [\"Blue\", \"Blue\", \"Blue\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_256_count_Primes_nums", "language": "swift", "prompt": "\n/// Write a python function that takes in a non-negative number and returns the number of prime numbers less than the given non-negative number.\nfunc count_Primes_nums(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_256_count_Primes_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_Primes_nums(n: 5) == 2)\nassert(count_Primes_nums(n: 10) == 4)\nassert(count_Primes_nums(n: 100) == 25)", "stop_tokens": ["\n}"]}
{"name": "mbpp_257_swap_numbers", "language": "swift", "prompt": "\n/// Write a function that takes in two numbers and returns a list with the second number and then the first number.\nfunc swap_numbers(a: Int, b: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_257_swap_numbers.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(swap_numbers(a: 10, b: 20) == [20, 10])\nassert(swap_numbers(a: 15, b: 17) == [17, 15])\nassert(swap_numbers(a: 100, b: 200) == [200, 100])", "stop_tokens": ["\n}"]}
{"name": "mbpp_259_maximize_elements", "language": "swift", "prompt": "\n/// Write a function to maximize the given two lists.\nfunc maximize_elements(test_tup1: [[Int]], test_tup2: [[Int]]) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_259_maximize_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximize_elements(test_tup1: [[1, 3], [4, 5], [2, 9], [1, 10]], test_tup2: [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 7], [4, 9], [2, 9], [7, 10]])\nassert(maximize_elements(test_tup1: [[2, 4], [5, 6], [3, 10], [2, 11]], test_tup2: [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[7, 8], [5, 10], [3, 10], [8, 11]])\nassert(maximize_elements(test_tup1: [[3, 5], [6, 7], [4, 11], [3, 12]], test_tup2: [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[8, 9], [6, 11], [4, 11], [9, 12]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_260_newman_prime", "language": "swift", "prompt": "\n/// Write a function to find the nth newman\u2013shanks\u2013williams prime number.\nfunc newman_prime(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_260_newman_prime.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(newman_prime(n: 3) == 7)\nassert(newman_prime(n: 4) == 17)\nassert(newman_prime(n: 5) == 41)", "stop_tokens": ["\n}"]}
{"name": "mbpp_261_division_elements", "language": "swift", "prompt": "\n/// Write a function that takes in two tuples and performs mathematical division operation element-wise across the given tuples.\nfunc division_elements(test_tup1: (Int, Int, Int, Int), test_tup2: (Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_261_division_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(division_elements(test_tup1: (10, 4, 6, 9), test_tup2: (5, 2, 3, 3)) == (2, 2, 2, 3))\nassert(division_elements(test_tup1: (12, 6, 8, 16), test_tup2: (6, 3, 4, 4)) == (2, 2, 2, 4))\nassert(division_elements(test_tup1: (20, 14, 36, 18), test_tup2: (5, 7, 6, 9)) == (4, 2, 6, 2))", "stop_tokens": ["\n}"]}
{"name": "mbpp_262_split_two_parts", "language": "swift", "prompt": "\n/// Write a function that takes in a list and an integer L and splits the given list into two parts where the length of the first part of the list is L, and returns the resulting lists in a tuple.\nfunc split_two_parts(list1: [AnyHashable], L: Int) -> AnyHashable {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_262_split_two_parts.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_two_parts(list1: [1, 1, 2, 3, 4, 4, 5, 1], L: 3) == ([1, 1, 2], [3, 4, 4, 5, 1]))\nassert(split_two_parts(list1: [\"a\", \"b\", \"c\", \"d\"], L: 2) == ([\"a\", \"b\"], [\"c\", \"d\"]))\nassert(split_two_parts(list1: [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"], L: 4) == ([\"p\", \"y\", \"t\", \"h\"], [\"o\", \"n\"]))", "stop_tokens": ["\n}"]}
{"name": "mbpp_264_dog_age", "language": "swift", "prompt": "\n/// Write a function to calculate a dog's age in dog's years.\nfunc dog_age(h_age: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_264_dog_age.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(dog_age(h_age: 12) == 61)\nassert(dog_age(h_age: 15) == 73)\nassert(dog_age(h_age: 24) == 109)", "stop_tokens": ["\n}"]}
{"name": "mbpp_265_list_split", "language": "swift", "prompt": "\n/// Write a function that takes in a list and an integer n and splits a list for every nth element, returning a list of the resulting lists.\nfunc list_split(S: [AnyHashable], step: Int) -> [[AnyHashable]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_265_list_split.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(list_split(S: [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\"], step: 3) == [[\"a\", \"d\", \"g\", \"j\", \"m\"], [\"b\", \"e\", \"h\", \"k\", \"n\"], [\"c\", \"f\", \"i\", \"l\"]])\nassert(list_split(S: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], step: 3) == [[1, 4, 7, 10, 13], [2, 5, 8, 11, 14], [3, 6, 9, 12]])\nassert(list_split(S: [\"python\", \"java\", \"C\", \"C++\", \"DBMS\", \"SQL\"], step: 2) == [[\"python\", \"C\", \"DBMS\"], [\"java\", \"C++\", \"SQL\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_266_lateralsurface_cube", "language": "swift", "prompt": "\n/// Write a function to find the lateral surface area of a cube given its side length.\nfunc lateralsurface_cube(l: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_266_lateralsurface_cube.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(lateralsurface_cube(l: 5) == 100)\nassert(lateralsurface_cube(l: 9) == 324)\nassert(lateralsurface_cube(l: 10) == 400)", "stop_tokens": ["\n}"]}
{"name": "mbpp_267_square_Sum", "language": "swift", "prompt": "\n/// Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\nfunc square_Sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_267_square_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(square_Sum(n: 2) == 10)\nassert(square_Sum(n: 3) == 35)\nassert(square_Sum(n: 4) == 84)", "stop_tokens": ["\n}"]}
{"name": "mbpp_268_find_star_num", "language": "swift", "prompt": "\n/// Write a function to find the n'th star number.\nfunc find_star_num(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_268_find_star_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_star_num(n: 3) == 37)\nassert(find_star_num(n: 4) == 73)\nassert(find_star_num(n: 5) == 121)", "stop_tokens": ["\n}"]}
{"name": "mbpp_269_ascii_value", "language": "swift", "prompt": "\n/// Write a function to find the ascii value of a character.\nfunc ascii_value(k: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_269_ascii_value.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(ascii_value(k: \"A\") == 65)\nassert(ascii_value(k: \"R\") == 82)\nassert(ascii_value(k: \"S\") == 83)", "stop_tokens": ["\n}"]}
{"name": "mbpp_270_sum_even_and_even_index", "language": "swift", "prompt": "\n/// Write a python function to find the sum of even numbers at even positions of a list.\nfunc sum_even_and_even_index(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_270_sum_even_and_even_index.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_even_and_even_index(arr: [5, 6, 12, 1, 18, 8]) == 30)\nassert(sum_even_and_even_index(arr: [3, 20, 17, 9, 2, 10, 18, 13, 6, 18]) == 26)\nassert(sum_even_and_even_index(arr: [5, 6, 12, 1]) == 12)", "stop_tokens": ["\n}"]}
{"name": "mbpp_271_even_Power_Sum", "language": "swift", "prompt": "\n/// Write a python function that takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\nfunc even_Power_Sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_271_even_Power_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_Power_Sum(n: 2) == 1056)\nassert(even_Power_Sum(n: 3) == 8832)\nassert(even_Power_Sum(n: 1) == 32)", "stop_tokens": ["\n}"]}
{"name": "mbpp_272_rear_extract", "language": "swift", "prompt": "\n/// Write a function that takes in a list of tuples and returns a list containing the rear element of each tuple.\nfunc rear_extract(test_list: [(Int, String, Int)]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_272_rear_extract.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rear_extract(test_list: [(1, \"Rash\", 21), (2, \"Varsha\", 20), (3, \"Kil\", 19)]) == [21, 20, 19])\nassert(rear_extract(test_list: [(1, \"Sai\", 36), (2, \"Ayesha\", 25), (3, \"Salman\", 45)]) == [36, 25, 45])\nassert(rear_extract(test_list: [(1, \"Sudeep\", 14), (2, \"Vandana\", 36), (3, \"Dawood\", 56)]) == [14, 36, 56])", "stop_tokens": ["\n}"]}
{"name": "mbpp_273_substract_elements", "language": "swift", "prompt": "\n/// Write a function that takes in two tuples and subtracts the elements of the first tuple by the elements of the second tuple with the same index.\nfunc substract_elements(test_tup1: (Int, Int, Int), test_tup2: (Int, Int, Int)) -> (Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_273_substract_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(substract_elements(test_tup1: (10, 4, 5), test_tup2: (2, 5, 18)) == (8, -1, -13))\nassert(substract_elements(test_tup1: (11, 2, 3), test_tup2: (24, 45, 16)) == (-13, -43, -13))\nassert(substract_elements(test_tup1: (7, 18, 9), test_tup2: (10, 11, 12)) == (-3, 7, -3))", "stop_tokens": ["\n}"]}
{"name": "mbpp_274_even_binomial_Coeff_Sum", "language": "swift", "prompt": "\n/// Write a python function that takes in a positive integer n and finds the sum of even index binomial coefficients.\nfunc even_binomial_Coeff_Sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_274_even_binomial_Coeff_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_binomial_Coeff_Sum(n: 4) == 8)\nassert(even_binomial_Coeff_Sum(n: 6) == 32)\nassert(even_binomial_Coeff_Sum(n: 2) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_277_dict_filter", "language": "swift", "prompt": "\n/// Write a function that takes in a dictionary and integer n and filters the dictionary to only include entries with values greater than or equal to n.\nfunc dict_filter(dict: [String : Int], n: Int) -> [String : Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_277_dict_filter.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(dict_filter(dict: [\"Cierra Vega\" : 175, \"Alden Cantrell\" : 180, \"Kierra Gentry\" : 165, \"Pierre Cox\" : 190], n: 170) == [\"Cierra Vega\" : 175, \"Alden Cantrell\" : 180, \"Pierre Cox\" : 190])\nassert(dict_filter(dict: [\"Cierra Vega\" : 175, \"Alden Cantrell\" : 180, \"Kierra Gentry\" : 165, \"Pierre Cox\" : 190], n: 180) == [\"Alden Cantrell\" : 180, \"Pierre Cox\" : 190])\nassert(dict_filter(dict: [\"Cierra Vega\" : 175, \"Alden Cantrell\" : 180, \"Kierra Gentry\" : 165, \"Pierre Cox\" : 190], n: 190) == [\"Pierre Cox\" : 190])", "stop_tokens": ["\n}"]}
{"name": "mbpp_278_count_first_elements", "language": "swift", "prompt": "\nextension (Int, Int): Error {}\n        \n/// Write a function to find the number of elements that occurs before the list element in the given tuple.\nfunc count_first_elements(test_tup: [Result<Int, (Int, Int)>]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_278_count_first_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_first_elements(test_tup: [.success(1), .success(5), .success(7), .failure((4, 6)), .success(10)]) == 3)\nassert(count_first_elements(test_tup: [.success(2), .success(9), .failure((5, 7)), .success(11)]) == 2)\nassert(count_first_elements(test_tup: [.success(11), .success(15), .success(5), .success(8), .failure((2, 3)), .success(8)]) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_279_is_num_decagonal", "language": "swift", "prompt": "\n/// Write a function to find the nth decagonal number.\nfunc is_num_decagonal(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_279_is_num_decagonal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_num_decagonal(n: 3) == 27)\nassert(is_num_decagonal(n: 7) == 175)\nassert(is_num_decagonal(n: 10) == 370)", "stop_tokens": ["\n}"]}
{"name": "mbpp_280_sequential_search", "language": "swift", "prompt": "\n/// Write a function that takes in an array and element and returns a tuple containing a boolean that indicates if the element is in the array and the index position of the element (or -1 if the element is not found).\nfunc sequential_search(dlist: [Int], item: Int) -> (Bool, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_280_sequential_search.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sequential_search(dlist: [11, 23, 58, 31, 56, 77, 43, 12, 65, 19], item: 31) == (true, 3))\nassert(sequential_search(dlist: [12, 32, 45, 62, 35, 47, 44, 61], item: 61) == (true, 7))\nassert(sequential_search(dlist: [9, 10, 17, 19, 22, 39, 48, 56], item: 48) == (true, 6))", "stop_tokens": ["\n}"]}
{"name": "mbpp_281_all_unique", "language": "swift", "prompt": "\n/// Write a python function to check if the elements of a given list are unique or not.\nfunc all_unique(test_list: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_281_all_unique.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_unique(test_list: [1, 2, 3]) == true)\nassert(all_unique(test_list: [1, 2, 1, 2]) == false)\nassert(all_unique(test_list: [1, 2, 3, 4, 5]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_282_sub_list", "language": "swift", "prompt": "\n/// Write a function to subtract two lists element-wise.\nfunc sub_list(nums1: [Int], nums2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_282_sub_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sub_list(nums1: [1, 2, 3], nums2: [4, 5, 6]) == [-3, -3, -3])\nassert(sub_list(nums1: [1, 2], nums2: [3, 4]) == [-2, -2])\nassert(sub_list(nums1: [90, 120], nums2: [50, 70]) == [40, 50])", "stop_tokens": ["\n}"]}
{"name": "mbpp_283_validate", "language": "swift", "prompt": "\n/// Write a python function takes in an integer and check whether the frequency of each digit in the integer is less than or equal to the digit itself.\nfunc validate(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_283_validate.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(validate(n: 1234) == true)\nassert(validate(n: 51241) == false)\nassert(validate(n: 321) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_284_check_element", "language": "swift", "prompt": "\n/// Write a function that takes in a list and element and checks whether all items in the list are equal to the given element.\nfunc check_element(list: [AnyHashable], element: AnyHashable) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_284_check_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_element(list: [\"green\", \"orange\", \"black\", \"white\"], element: \"blue\") == false)\nassert(check_element(list: [1, 2, 3, 4], element: 7) == false)\nassert(check_element(list: [\"green\", \"green\", \"green\", \"green\"], element: \"green\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_285_text_match_two_three", "language": "swift", "prompt": "\n/// Write a function that checks whether a string contains the 'a' character followed by two or three 'b' characters.\nfunc text_match_two_three(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_285_text_match_two_three.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_two_three(text: \"ac\") == false)\nassert(text_match_two_three(text: \"dc\") == false)\nassert(text_match_two_three(text: \"abbbba\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_286_max_sub_array_sum_repeated", "language": "swift", "prompt": "\n/// Write a function to find the largest sum of a contiguous array in the modified array which is formed by repeating the given array k times.\nfunc max_sub_array_sum_repeated(a: [Int], n: Int, k: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_286_max_sub_array_sum_repeated.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_sub_array_sum_repeated(a: [10, 20, -30, -1], n: 4, k: 3) == 30)\nassert(max_sub_array_sum_repeated(a: [-1, 10, 20], n: 3, k: 2) == 59)\nassert(max_sub_array_sum_repeated(a: [-1, -2, -3], n: 3, k: 3) == -1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_287_square_Sum", "language": "swift", "prompt": "\n/// Write a python function takes in an integer n and returns the sum of squares of first n even natural numbers.\nfunc square_Sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_287_square_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(square_Sum(n: 2) == 20)\nassert(square_Sum(n: 3) == 56)\nassert(square_Sum(n: 4) == 120)", "stop_tokens": ["\n}"]}
{"name": "mbpp_290_max_length", "language": "swift", "prompt": "\n/// Write a function to find the list of maximum length in a list of lists.\nfunc max_length(list1: [[Int]]) -> (Int, [Int]) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_290_max_length.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_length(list1: [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17]))\nassert(max_length(list1: [[1], [5, 7], [10, 12, 14, 15]]) == (4, [10, 12, 14, 15]))\nassert(max_length(list1: [[5], [15, 20, 25]]) == (3, [15, 20, 25]))", "stop_tokens": ["\n}"]}
{"name": "mbpp_291_count_no_of_ways", "language": "swift", "prompt": "\n/// Write a function to find out the number of ways of painting the fence such that at most 2 adjacent posts have the same color for the given fence with n posts and k colors.\nfunc count_no_of_ways(n: Int, k: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_291_count_no_of_ways.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_no_of_ways(n: 2, k: 4) == 16)\nassert(count_no_of_ways(n: 3, k: 2) == 6)\nassert(count_no_of_ways(n: 4, k: 4) == 228)", "stop_tokens": ["\n}"]}
{"name": "mbpp_292_find", "language": "swift", "prompt": "\n/// Write a python function to find quotient of two numbers (rounded down to the nearest integer).\nfunc find(n: Int, m: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_292_find.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find(n: 10, m: 3) == 3)\nassert(find(n: 4, m: 2) == 2)\nassert(find(n: 20, m: 5) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_293_otherside_rightangle", "language": "swift", "prompt": "\n/// Write a function to find the third side of a right angled triangle.\nfunc otherside_rightangle(w: Int, h: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_293_otherside_rightangle.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(otherside_rightangle(w: 7, h: 8) == 10.63014581273465)\nassert(otherside_rightangle(w: 3, h: 4) == 5)\nassert(otherside_rightangle(w: 7, h: 15) == 16.55294535724685)", "stop_tokens": ["\n}"]}
{"name": "mbpp_294_max_val", "language": "swift", "prompt": "\nextension Int: Error {}\n        \n/// Write a function to find the maximum value in a given heterogeneous list.\nfunc max_val(listval: [Result<String, Int>]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_294_max_val.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 5)\nassert(max_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 25)\nassert(max_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 50)", "stop_tokens": ["\n}"]}
{"name": "mbpp_295_sum_div", "language": "swift", "prompt": "\n/// Write a function to return the sum of all divisors of a number.\nfunc sum_div(number: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_295_sum_div.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_div(number: 8) == 7)\nassert(sum_div(number: 12) == 16)\nassert(sum_div(number: 7) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_296_get_Inv_Count", "language": "swift", "prompt": "\n/// Write a python function to count inversions in an array.\nfunc get_Inv_Count(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_296_get_Inv_Count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_Inv_Count(arr: [1, 20, 6, 4, 5]) == 5)\nassert(get_Inv_Count(arr: [1, 2, 1]) == 1)\nassert(get_Inv_Count(arr: [1, 2, 5, 6, 1]) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_297_flatten_list", "language": "swift", "prompt": "\nextension [Int]: Error {}\n        \n/// Write a function to flatten a given nested list structure.\nfunc flatten_list(list1: [Result<Int, [Int]>]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_297_flatten_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(flatten_list(list1: [.success(0), .success(10), .failure([20, 30]), .success(40), .success(50), .failure([60, 70, 80]), .failure([90, 100, 110, 120])]) == [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120])\nassert(flatten_list(list1: [.failure([10, 20]), .failure([40]), .failure([30, 56, 25]), .failure([10, 20]), .failure([33]), .failure([40])]) == [10, 20, 40, 30, 56, 25, 10, 20, 33, 40])\nassert(flatten_list(list1: [.failure([1, 2, 3]), .failure([4, 5, 6]), .failure([10, 11, 12]), .failure([7, 8, 9])]) == [1, 2, 3, 4, 5, 6, 10, 11, 12, 7, 8, 9])", "stop_tokens": ["\n}"]}
{"name": "mbpp_299_max_aggregate", "language": "swift", "prompt": "\n/// Write a function to calculate the maximum aggregate from the list of tuples.\nfunc max_aggregate(stdata: [(String, Int)]) -> (String, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_299_max_aggregate.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_aggregate(stdata: [(\"Juan Whelan\", 90), (\"Sabah Colley\", 88), (\"Peter Nichols\", 7), (\"Juan Whelan\", 122), (\"Sabah Colley\", 84)]) == (\"Juan Whelan\", 212))\nassert(max_aggregate(stdata: [(\"Juan Whelan\", 50), (\"Sabah Colley\", 48), (\"Peter Nichols\", 37), (\"Juan Whelan\", 22), (\"Sabah Colley\", 14)]) == (\"Juan Whelan\", 72))\nassert(max_aggregate(stdata: [(\"Juan Whelan\", 10), (\"Sabah Colley\", 20), (\"Peter Nichols\", 30), (\"Juan Whelan\", 40), (\"Sabah Colley\", 50)]) == (\"Sabah Colley\", 70))", "stop_tokens": ["\n}"]}
{"name": "mbpp_304_find_Element", "language": "swift", "prompt": "\n/// Write a python function to find element at a given index after number of rotations.\nfunc find_Element(arr: [Int], ranges: [[Int]], rotations: Int, index: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_304_find_Element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Element(arr: [1, 2, 3, 4, 5], ranges: [[0, 2], [0, 3]], rotations: 2, index: 1) == 3)\nassert(find_Element(arr: [1, 2, 3, 4], ranges: [[0, 1], [0, 2]], rotations: 1, index: 2) == 3)\nassert(find_Element(arr: [1, 2, 3, 4, 5, 6], ranges: [[0, 1], [0, 2]], rotations: 1, index: 1) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_305_start_withp", "language": "swift", "prompt": "\n/// Write a function to return two words from a list of words starting with letter 'p'.\nfunc start_withp(words: [String]) -> (String, String) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_305_start_withp.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(start_withp(words: [\"Python PHP\", \"Java JavaScript\", \"c c++\"]) == (\"Python\", \"PHP\"))\nassert(start_withp(words: [\"Python Programming\", \"Java Programming\"]) == (\"Python\", \"Programming\"))\nassert(start_withp(words: [\"Pqrst Pqr\", \"qrstuv\"]) == (\"Pqrst\", \"Pqr\"))", "stop_tokens": ["\n}"]}
{"name": "mbpp_306_max_sum_increasing_subseq", "language": "swift", "prompt": "\n/// Write a function to find the maximum sum of increasing subsequence from prefix until ith index and also including a given kth element which is after i, i.e., k > i .\nfunc max_sum_increasing_subseq(a: [Int], n: Int, index: Int, k: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_306_max_sum_increasing_subseq.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_sum_increasing_subseq(a: [1, 101, 2, 3, 100, 4, 5], n: 7, index: 4, k: 6) == 11)\nassert(max_sum_increasing_subseq(a: [1, 101, 2, 3, 100, 4, 5], n: 7, index: 2, k: 5) == 7)\nassert(max_sum_increasing_subseq(a: [11, 15, 19, 21, 26, 28, 31], n: 7, index: 2, k: 4) == 71)", "stop_tokens": ["\n}"]}
{"name": "mbpp_308_large_product", "language": "swift", "prompt": "\n/// Write a function to find the specified number of largest products from two given lists, selecting one factor from each list.\nfunc large_product(nums1: [Int], nums2: [Int], N: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_308_large_product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 3) == [60, 54, 50])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 4) == [60, 54, 50, 48])\nassert(large_product(nums1: [1, 2, 3, 4, 5, 6], nums2: [3, 6, 8, 9, 10, 6], N: 5) == [60, 54, 50, 48, 45])", "stop_tokens": ["\n}"]}
{"name": "mbpp_309_maximum", "language": "swift", "prompt": "\n/// Write a python function to find the maximum of two numbers.\nfunc maximum(a: Int, b: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_309_maximum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maximum(a: 5, b: 10) == 10)\nassert(maximum(a: -1, b: -2) == -1)\nassert(maximum(a: 9, b: 7) == 9)", "stop_tokens": ["\n}"]}
{"name": "mbpp_310_string_to_tuple", "language": "swift", "prompt": "\n/// Write a function to convert a given string to a list of characters.\nfunc string_to_tuple(str1: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_310_string_to_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(string_to_tuple(str1: \"python 3.0\") == [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\", \"3\", \".\", \"0\"])\nassert(string_to_tuple(str1: \"item1\") == [\"i\", \"t\", \"e\", \"m\", \"1\"])\nassert(string_to_tuple(str1: \"15.10\") == [\"1\", \"5\", \".\", \"1\", \"0\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_388_highest_Power_of_2", "language": "swift", "prompt": "\n/// Write a python function to find the highest power of 2 that is less than or equal to n.\nfunc highest_Power_of_2(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_388_highest_Power_of_2.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(highest_Power_of_2(n: 10) == 8)\nassert(highest_Power_of_2(n: 19) == 16)\nassert(highest_Power_of_2(n: 32) == 32)", "stop_tokens": ["\n}"]}
{"name": "mbpp_389_find_lucas", "language": "swift", "prompt": "\n/// Write a function to find the n'th lucas number.\nfunc find_lucas(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_389_find_lucas.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_lucas(n: 9) == 76)\nassert(find_lucas(n: 4) == 7)\nassert(find_lucas(n: 3) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_390_add_string", "language": "swift", "prompt": "\n/// Write a function to apply a given format string to all of the elements in a list.\nfunc add_string(list_: [AnyHashable], string: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_390_add_string.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_string(list_: [1, 2, 3, 4], string: \"temp{0}\") == [\"temp1\", \"temp2\", \"temp3\", \"temp4\"])\nassert(add_string(list_: [\"a\", \"b\", \"c\", \"d\"], string: \"python{0}\") == [\"pythona\", \"pythonb\", \"pythonc\", \"pythond\"])\nassert(add_string(list_: [5, 6, 7, 8], string: \"string{0}\") == [\"string5\", \"string6\", \"string7\", \"string8\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_391_convert_list_dictionary", "language": "swift", "prompt": "\n/// Write a function to convert more than one list to nested dictionary.\nfunc convert_list_dictionary(l1: [String], l2: [String], l3: [Int]) -> [[String : [String : Int]]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_391_convert_list_dictionary.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(convert_list_dictionary(l1: [\"S001\", \"S002\", \"S003\", \"S004\"], l2: [\"Adina Park\", \"Leyton Marsh\", \"Duncan Boyle\", \"Saim Richards\"], l3: [85, 98, 89, 92]) == [[\"S001\" : [\"Adina Park\" : 85]], [\"S002\" : [\"Leyton Marsh\" : 98]], [\"S003\" : [\"Duncan Boyle\" : 89]], [\"S004\" : [\"Saim Richards\" : 92]]])\nassert(convert_list_dictionary(l1: [\"abc\", \"def\", \"ghi\", \"jkl\"], l2: [\"python\", \"program\", \"language\", \"programs\"], l3: [100, 200, 300, 400]) == [[\"abc\" : [\"python\" : 100]], [\"def\" : [\"program\" : 200]], [\"ghi\" : [\"language\" : 300]], [\"jkl\" : [\"programs\" : 400]]])\nassert(convert_list_dictionary(l1: [\"A1\", \"A2\", \"A3\", \"A4\"], l2: [\"java\", \"C\", \"C++\", \"DBMS\"], l3: [10, 20, 30, 40]) == [[\"A1\" : [\"java\" : 10]], [\"A2\" : [\"C\" : 20]], [\"A3\" : [\"C++\" : 30]], [\"A4\" : [\"DBMS\" : 40]]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_392_get_max_sum", "language": "swift", "prompt": "\n/// Write a function to find the maximum sum possible by using the given equation f(n) = max( (f(n/2) + f(n/3) + f(n/4) + f(n/5)), n).\nfunc get_max_sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_392_get_max_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_max_sum(n: 60) == 106)\nassert(get_max_sum(n: 10) == 12)\nassert(get_max_sum(n: 2) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_393_max_length_list", "language": "swift", "prompt": "\n/// Write a function to find the list with maximum length.\nfunc max_length_list(input_list: [[Int]]) -> (Int, [Int]) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_393_max_length_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_length_list(input_list: [[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]]) == (3, [13, 15, 17]))\nassert(max_length_list(input_list: [[1, 2, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3], [1, 2], [1]]) == (5, [1, 2, 3, 4, 5]))\nassert(max_length_list(input_list: [[3, 4, 5], [6, 7, 8, 9], [10, 11, 12]]) == (4, [6, 7, 8, 9]))", "stop_tokens": ["\n}"]}
{"name": "mbpp_394_check_distinct", "language": "swift", "prompt": "\n/// Write a function to check if given list contains no duplicates.\nfunc check_distinct(test_tup: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_394_check_distinct.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_distinct(test_tup: [1, 4, 5, 6, 1, 4]) == false)\nassert(check_distinct(test_tup: [1, 4, 5, 6]) == true)\nassert(check_distinct(test_tup: [2, 3, 4, 5, 6]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_395_first_non_repeating_character", "language": "swift", "prompt": "\n/// Write a python function to find the first non-repeated character in a given string.\nfunc first_non_repeating_character(str1: String) -> String? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_395_first_non_repeating_character.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(first_non_repeating_character(str1: \"abcabc\") == nil)\nassert(first_non_repeating_character(str1: \"abc\") == \"a\")\nassert(first_non_repeating_character(str1: \"ababc\") == \"c\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_396_check_char", "language": "swift", "prompt": "\n/// Write a function to check whether the given string starts and ends with the same character or not.\nfunc check_char(string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_396_check_char.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_char(string: \"abba\") == \"Valid\")\nassert(check_char(string: \"a\") == \"Valid\")\nassert(check_char(string: \"abcd\") == \"Invalid\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_397_median_numbers", "language": "swift", "prompt": "\n/// Write a function to find the median of three numbers.\nfunc median_numbers(a: Int, b: Int, c: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_397_median_numbers.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median_numbers(a: 25, b: 55, c: 65) == 55.0)\nassert(median_numbers(a: 20, b: 10, c: 30) == 20.0)\nassert(median_numbers(a: 15, b: 45, c: 75) == 45.0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_398_sum_of_digits", "language": "swift", "prompt": "\n/// Write a function to compute the sum of digits of each number of a given list.\nfunc sum_of_digits(nums: [AnyHashable]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_398_sum_of_digits.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_of_digits(nums: [10, 2, 56]) == 14)\nassert(sum_of_digits(nums: [[10, 20, 4, 5, \"b\", 70, \"a\"]]) == 19)\nassert(sum_of_digits(nums: [10, 20, -4, 5, -70]) == 19)", "stop_tokens": ["\n}"]}
{"name": "mbpp_399_bitwise_xor", "language": "swift", "prompt": "\n/// Write a function to perform the mathematical bitwise xor operation across the given tuples.\nfunc bitwise_xor(test_tup1: (Int, Int, Int, Int), test_tup2: (Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_399_bitwise_xor.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(bitwise_xor(test_tup1: (10, 4, 6, 9), test_tup2: (5, 2, 3, 3)) == (15, 6, 5, 10))\nassert(bitwise_xor(test_tup1: (11, 5, 7, 10), test_tup2: (6, 3, 4, 4)) == (13, 6, 3, 14))\nassert(bitwise_xor(test_tup1: (12, 6, 8, 11), test_tup2: (7, 4, 5, 6)) == (11, 2, 13, 13))", "stop_tokens": ["\n}"]}
{"name": "mbpp_3_is_not_prime", "language": "swift", "prompt": "\n/// Write a python function to identify non-prime numbers.\nfunc is_not_prime(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_3_is_not_prime.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_not_prime(n: 2) == false)\nassert(is_not_prime(n: 10) == true)\nassert(is_not_prime(n: 35) == true)\nassert(is_not_prime(n: 37) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_400_extract_freq", "language": "swift", "prompt": "\n/// Write a function to extract the number of unique tuples in the given list.\nfunc extract_freq(test_list: [(Int, Int)]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_400_extract_freq.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_freq(test_list: [(3, 4), (1, 2), (4, 3), (5, 6)]) == 3)\nassert(extract_freq(test_list: [(4, 15), (2, 3), (5, 4), (6, 7)]) == 4)\nassert(extract_freq(test_list: [(5, 16), (2, 3), (6, 5), (6, 9)]) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_401_add_nested_tuples", "language": "swift", "prompt": "\n/// Write a function to perform index wise addition of list elements in the given two nested lists.\nfunc add_nested_tuples(test_tup1: [[Int]], test_tup2: [[Int]]) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_401_add_nested_tuples.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_nested_tuples(test_tup1: [[1, 3], [4, 5], [2, 9], [1, 10]], test_tup2: [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[7, 10], [7, 14], [3, 10], [8, 13]])\nassert(add_nested_tuples(test_tup1: [[2, 4], [5, 6], [3, 10], [2, 11]], test_tup2: [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[9, 12], [9, 16], [5, 12], [10, 15]])\nassert(add_nested_tuples(test_tup1: [[3, 5], [6, 7], [4, 11], [3, 12]], test_tup2: [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[11, 14], [11, 18], [7, 14], [12, 17]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_404_minimum", "language": "swift", "prompt": "\n/// Write a python function to find the minimum of two numbers.\nfunc minimum(a: Int, b: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_404_minimum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(minimum(a: 1, b: 2) == 1)\nassert(minimum(a: -5, b: -4) == -5)\nassert(minimum(a: 0, b: 0) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_405_check_tuplex", "language": "swift", "prompt": "\nextension Int: Error {}\n        \n/// Write a function to check whether an element exists within a tuple.\nfunc check_tuplex(tuplex: [Result<String, Int>], tuple1: AnyHashable) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_405_check_tuplex.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_tuplex(tuplex: [.success(\"w\"), .failure(3), .success(\"r\"), .success(\"e\"), .success(\"s\"), .success(\"o\"), .success(\"u\"), .success(\"r\"), .success(\"c\"), .success(\"e\")], tuple1: \"r\") == true)\nassert(check_tuplex(tuplex: [.success(\"w\"), .failure(3), .success(\"r\"), .success(\"e\"), .success(\"s\"), .success(\"o\"), .success(\"u\"), .success(\"r\"), .success(\"c\"), .success(\"e\")], tuple1: \"5\") == false)\nassert(check_tuplex(tuplex: [.success(\"w\"), .failure(3), .success(\"r\"), .success(\"e\"), .success(\"s\"), .success(\"o\"), .success(\"u\"), .success(\"r\"), .success(\"c\"), .success(\"e\")], tuple1: 3) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_406_find_Parity", "language": "swift", "prompt": "\n/// Write a python function to find whether the parity of a given number is odd.\nfunc find_Parity(x: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_406_find_Parity.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Parity(x: 12) == false)\nassert(find_Parity(x: 7) == true)\nassert(find_Parity(x: 10) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_407_rearrange_bigger", "language": "swift", "prompt": "\n/// Write a function to create the next bigger number by rearranging the digits of a given number.\nfunc rearrange_bigger(n: Int) -> AnyHashable {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_407_rearrange_bigger.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rearrange_bigger(n: 12) == 21)\nassert(rearrange_bigger(n: 10) == false)\nassert(rearrange_bigger(n: 102) == 120)", "stop_tokens": ["\n}"]}
{"name": "mbpp_408_k_smallest_pairs", "language": "swift", "prompt": "\n/// Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\nfunc k_smallest_pairs(nums1: [Int], nums2: [Int], k: Int) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 2) == [[1, 2], [1, 4]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 1) == [[1, 2]])\nassert(k_smallest_pairs(nums1: [1, 3, 7], nums2: [2, 4, 6], k: 7) == [[1, 2], [1, 4], [3, 2], [1, 6], [3, 4], [3, 6], [7, 2]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_409_min_product_tuple", "language": "swift", "prompt": "\n/// Write a function to find the minimum product from the pairs of tuples within a given list.\nfunc min_product_tuple(list1: [(Int, Int)]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_409_min_product_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_product_tuple(list1: [(2, 7), (2, 6), (1, 8), (4, 9)]) == 8)\nassert(min_product_tuple(list1: [(10, 20), (15, 2), (5, 10)]) == 30)\nassert(min_product_tuple(list1: [(11, 44), (10, 15), (20, 5), (12, 9)]) == 100)", "stop_tokens": ["\n}"]}
{"name": "mbpp_410_min_val", "language": "swift", "prompt": "\nextension Int: Error {}\n        \n/// Write a function to find the minimum value in a given heterogeneous list.\nfunc min_val(listval: [Result<String, Int>]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_410_min_val.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_val(listval: [.success(\"Python\"), .failure(3), .failure(2), .failure(4), .failure(5), .success(\"version\")]) == 2)\nassert(min_val(listval: [.success(\"Python\"), .failure(15), .failure(20), .failure(25)]) == 15)\nassert(min_val(listval: [.success(\"Python\"), .failure(30), .failure(20), .failure(40), .failure(50), .success(\"version\")]) == 20)", "stop_tokens": ["\n}"]}
{"name": "mbpp_411_snake_to_camel", "language": "swift", "prompt": "\n/// Write a function to convert the given snake case string to camel case string.\nfunc snake_to_camel(word: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_411_snake_to_camel.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(snake_to_camel(word: \"android_tv\") == \"AndroidTv\")\nassert(snake_to_camel(word: \"google_pixel\") == \"GooglePixel\")\nassert(snake_to_camel(word: \"apple_watch\") == \"AppleWatch\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_412_remove_odd", "language": "swift", "prompt": "\n/// Write a python function to remove odd numbers from a given list.\nfunc remove_odd(l: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_412_remove_odd.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_odd(l: [1, 2, 3]) == [2])\nassert(remove_odd(l: [2, 4, 6]) == [2, 4, 6])\nassert(remove_odd(l: [10, 20, 3]) == [10, 20])", "stop_tokens": ["\n}"]}
{"name": "mbpp_413_extract_nth_element", "language": "swift", "prompt": "\n/// Write a function to extract the nth element from a given list of tuples.\nfunc extract_nth_element(list1: [(String, Int, Int)], n: Int) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_413_extract_nth_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_nth_element(list1: [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)], n: 0) == [\"Greyson Fulton\", \"Brady Kent\", \"Wyatt Knott\", \"Beau Turnbull\"])\nassert(extract_nth_element(list1: [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)], n: 2) == [99, 96, 94, 98])\nassert(extract_nth_element(list1: [(\"Greyson Fulton\", 98, 99), (\"Brady Kent\", 97, 96), (\"Wyatt Knott\", 91, 94), (\"Beau Turnbull\", 94, 98)], n: 1) == [98, 97, 91, 94])", "stop_tokens": ["\n}"]}
{"name": "mbpp_414_overlapping", "language": "swift", "prompt": "\n/// Write a python function to check whether any value in a sequence exists in a sequence or not.\nfunc overlapping(list1: [Int], list2: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_414_overlapping.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(overlapping(list1: [1, 2, 3, 4, 5], list2: [6, 7, 8, 9]) == false)\nassert(overlapping(list1: [1, 2, 3], list2: [4, 5, 6]) == false)\nassert(overlapping(list1: [1, 4, 5], list2: [1, 4, 5]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_415_max_Product", "language": "swift", "prompt": "\n/// Write a python function to find a pair with highest product from a given array of integers.\nfunc max_Product(arr: [Int]) -> (Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_415_max_Product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_Product(arr: [1, 2, 3, 4, 7, 0, 8, 4]) == (7, 8))\nassert(max_Product(arr: [0, -1, -2, -4, 5, 0, -6]) == (-4, -6))\nassert(max_Product(arr: [1, 2, 3]) == (2, 3))", "stop_tokens": ["\n}"]}
{"name": "mbpp_417_group_tuples", "language": "swift", "prompt": "\n/// Write a function to find common first element in given list of lists.\nfunc group_tuples(Input: [[String]]) -> [[String]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_417_group_tuples.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(group_tuples(Input: [[\"x\", \"y\"], [\"x\", \"z\"], [\"w\", \"t\"]]) == [[\"x\", \"y\", \"z\"], [\"w\", \"t\"]])\nassert(group_tuples(Input: [[\"a\", \"b\"], [\"a\", \"c\"], [\"d\", \"e\"]]) == [[\"a\", \"b\", \"c\"], [\"d\", \"e\"]])\nassert(group_tuples(Input: [[\"f\", \"g\"], [\"f\", \"g\"], [\"h\", \"i\"]]) == [[\"f\", \"g\", \"g\"], [\"h\", \"i\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_418_Find_Max", "language": "swift", "prompt": "\n/// Write a python function to find the element of a list having maximum length.\nfunc Find_Max(lst: [[AnyHashable]]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_418_Find_Max.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Find_Max(lst: [[\"A\"], [\"A\", \"B\"], [\"A\", \"B\", \"C\"]]) == [\"A\", \"B\", \"C\"])\nassert(Find_Max(lst: [[1], [1, 2], [1, 2, 3]]) == [1, 2, 3])\nassert(Find_Max(lst: [[1, 1], [1, 2, 3], [1, 5, 6, 1]]) == [1, 5, 6, 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_419_round_and_sum", "language": "swift", "prompt": "\nextension Int: Error {}\n        \n/// Write a function to round every number of a given list of numbers and print the total sum multiplied by the length of the list.\nfunc round_and_sum(list1: [Result<Double, Int>]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_419_round_and_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(round_and_sum(list1: [.success(22.4), .success(4.0), .success(-16.22), .success(-9.1), .success(11.0), .success(-12.22), .success(14.2), .success(-5.2), .success(17.5)]) == 243)\nassert(round_and_sum(list1: [.failure(5), .failure(2), .failure(9), .success(24.3), .failure(29)]) == 345)\nassert(round_and_sum(list1: [.success(25.0), .success(56.7), .success(89.2)]) == 513)", "stop_tokens": ["\n}"]}
{"name": "mbpp_420_cube_Sum", "language": "swift", "prompt": "\n/// Write a python function to find the cube sum of first n even natural numbers.\nfunc cube_Sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_420_cube_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cube_Sum(n: 2) == 72)\nassert(cube_Sum(n: 3) == 288)\nassert(cube_Sum(n: 4) == 800)", "stop_tokens": ["\n}"]}
{"name": "mbpp_421_concatenate_tuple", "language": "swift", "prompt": "\n/// Write a function to concatenate each element of tuple by the delimiter.\nfunc concatenate_tuple(test_tup: (String, String, Int, String)) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_421_concatenate_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(concatenate_tuple(test_tup: (\"ID\", \"is\", 4, \"UTS\")) == \"ID-is-4-UTS\")\nassert(concatenate_tuple(test_tup: (\"QWE\", \"is\", 4, \"RTY\")) == \"QWE-is-4-RTY\")\nassert(concatenate_tuple(test_tup: (\"ZEN\", \"is\", 4, \"OP\")) == \"ZEN-is-4-OP\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_422_find_Average_Of_Cube", "language": "swift", "prompt": "\n/// Write a python function to find the average of cubes of first n natural numbers.\nfunc find_Average_Of_Cube(n: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_422_find_Average_Of_Cube.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Average_Of_Cube(n: 2) == 4.5)\nassert(find_Average_Of_Cube(n: 3) == 12)\nassert(find_Average_Of_Cube(n: 1) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_424_extract_rear", "language": "swift", "prompt": "\n/// Write a function to extract only the rear index element of each string in the given tuple.\nfunc extract_rear(test_tuple: (String, String, String)) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_424_extract_rear.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_rear(test_tuple: (\"Mers\", \"for\", \"Vers\")) == [\"s\", \"r\", \"s\"])\nassert(extract_rear(test_tuple: (\"Avenge\", \"for\", \"People\")) == [\"e\", \"r\", \"e\"])\nassert(extract_rear(test_tuple: (\"Gotta\", \"get\", \"go\")) == [\"a\", \"t\", \"o\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_425_count_element_in_list", "language": "swift", "prompt": "\n/// Write a function to count the number of sublists containing a particular element.\nfunc count_element_in_list(list1: [[AnyHashable]], x: AnyHashable) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_425_count_element_in_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_element_in_list(list1: [[1, 3], [5, 7], [1, 11], [1, 15, 7]], x: 1) == 3)\nassert(count_element_in_list(list1: [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]], x: \"A\") == 3)\nassert(count_element_in_list(list1: [[\"A\", \"B\"], [\"A\", \"C\"], [\"A\", \"D\", \"E\"], [\"B\", \"C\", \"D\"]], x: \"E\") == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_426_filter_oddnumbers", "language": "swift", "prompt": "\n/// Write a function to filter odd numbers.\nfunc filter_oddnumbers(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_426_filter_oddnumbers.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_oddnumbers(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 3, 5, 7, 9])\nassert(filter_oddnumbers(nums: [10, 20, 45, 67, 84, 93]) == [45, 67, 93])\nassert(filter_oddnumbers(nums: [5, 7, 9, 8, 6, 4, 3]) == [5, 7, 9, 3])", "stop_tokens": ["\n}"]}
{"name": "mbpp_427_change_date_format", "language": "swift", "prompt": "\n/// Write a function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\nfunc change_date_format(dt: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_427_change_date_format.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(change_date_format(dt: \"2026-01-02\") == \"02-01-2026\")\nassert(change_date_format(dt: \"2020-11-13\") == \"13-11-2020\")\nassert(change_date_format(dt: \"2021-04-26\") == \"26-04-2021\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_428_shell_sort", "language": "swift", "prompt": "\n/// Write a function to sort the given array by using shell sort.\nfunc shell_sort(my_list: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_428_shell_sort.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(shell_sort(my_list: [12, 23, 4, 5, 3, 2, 12, 81, 56, 95]) == [2, 3, 4, 5, 12, 12, 23, 56, 81, 95])\nassert(shell_sort(my_list: [24, 22, 39, 34, 87, 73, 68]) == [22, 24, 34, 39, 68, 73, 87])\nassert(shell_sort(my_list: [32, 30, 16, 96, 82, 83, 74]) == [16, 30, 32, 74, 82, 83, 96])", "stop_tokens": ["\n}"]}
{"name": "mbpp_429_and_tuples", "language": "swift", "prompt": "\n/// Write a function to extract the elementwise and tuples from the given two tuples.\nfunc and_tuples(test_tup1: (Int, Int, Int, Int), test_tup2: (Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_429_and_tuples.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(and_tuples(test_tup1: (10, 4, 6, 9), test_tup2: (5, 2, 3, 3)) == (0, 0, 2, 1))\nassert(and_tuples(test_tup1: (1, 2, 3, 4), test_tup2: (5, 6, 7, 8)) == (1, 2, 3, 0))\nassert(and_tuples(test_tup1: (8, 9, 11, 12), test_tup2: (7, 13, 14, 17)) == (0, 9, 10, 0))", "stop_tokens": ["\n}"]}
{"name": "mbpp_430_parabola_directrix", "language": "swift", "prompt": "\n/// Write a function to find the directrix of a parabola.\nfunc parabola_directrix(a: Int, b: Int, c: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_430_parabola_directrix.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(parabola_directrix(a: 5, b: 3, c: 2) == -198)\nassert(parabola_directrix(a: 9, b: 8, c: 4) == -2336)\nassert(parabola_directrix(a: 2, b: 4, c: 6) == -130)", "stop_tokens": ["\n}"]}
{"name": "mbpp_431_common_element", "language": "swift", "prompt": "\n/// Write a function that takes two lists and returns true if they have at least one common element.\nfunc common_element(list1: [AnyHashable], list2: [AnyHashable]) -> Bool? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_431_common_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(common_element(list1: [1, 2, 3, 4, 5], list2: [5, 6, 7, 8, 9]) == true)\nassert(common_element(list1: [1, 2, 3, 4, 5], list2: [6, 7, 8, 9]) == nil)\nassert(common_element(list1: [\"a\", \"b\", \"c\"], list2: [\"d\", \"b\", \"e\"]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_432_median_trapezium", "language": "swift", "prompt": "\n/// Write a function to find the median length of a trapezium.\nfunc median_trapezium(base1: Int, base2: Int, height: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_432_median_trapezium.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(median_trapezium(base1: 15, base2: 25, height: 35) == 20)\nassert(median_trapezium(base1: 10, base2: 20, height: 30) == 15)\nassert(median_trapezium(base1: 6, base2: 9, height: 4) == 7.5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_433_check_greater", "language": "swift", "prompt": "\n/// Write a function to check whether the entered number is greater than the elements of the given array.\nfunc check_greater(arr: [Int], number: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_433_check_greater.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_greater(arr: [1, 2, 3, 4, 5], number: 4) == false)\nassert(check_greater(arr: [2, 3, 4, 5, 6], number: 8) == true)\nassert(check_greater(arr: [9, 7, 4, 8, 6, 1], number: 11) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_434_text_match_one", "language": "swift", "prompt": "\n/// Write a function that matches a string that has an a followed by one or more b's.\nfunc text_match_one(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_434_text_match_one.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_one(text: \"ac\") == false)\nassert(text_match_one(text: \"dc\") == false)\nassert(text_match_one(text: \"abba\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_435_last_Digit", "language": "swift", "prompt": "\n/// Write a python function to find the last digit of a given number.\nfunc last_Digit(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_435_last_Digit.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(last_Digit(n: 123) == 3)\nassert(last_Digit(n: 25) == 5)\nassert(last_Digit(n: 30) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_436_neg_nos", "language": "swift", "prompt": "\n/// Write a python function to return the negative numbers in a list.\nfunc neg_nos(list1: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_436_neg_nos.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(neg_nos(list1: [-1, 4, 5, -6]) == [-1, -6])\nassert(neg_nos(list1: [-1, -2, 3, 4]) == [-1, -2])\nassert(neg_nos(list1: [-7, -6, 8, 9]) == [-7, -6])", "stop_tokens": ["\n}"]}
{"name": "mbpp_437_remove_odd", "language": "swift", "prompt": "\n/// Write a function to remove odd characters in a string.\nfunc remove_odd(str1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_437_remove_odd.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_odd(str1: \"python\") == \"yhn\")\nassert(remove_odd(str1: \"program\") == \"rga\")\nassert(remove_odd(str1: \"language\") == \"agae\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_438_count_bidirectional", "language": "swift", "prompt": "\n/// Write a function to count bidirectional tuple pairs.\nfunc count_bidirectional(test_list: [(Int, Int)]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_438_count_bidirectional.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_bidirectional(test_list: [(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == 3)\nassert(count_bidirectional(test_list: [(5, 6), (1, 3), (6, 5), (9, 1), (6, 5), (2, 1)]) == 2)\nassert(count_bidirectional(test_list: [(5, 6), (1, 2), (6, 5), (9, 2), (6, 5), (2, 1)]) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_439_multiple_to_single", "language": "swift", "prompt": "\n/// Write a function to join a list of multiple integers into a single integer.\nfunc multiple_to_single(L: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_439_multiple_to_single.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiple_to_single(L: [11, 33, 50]) == 113350)\nassert(multiple_to_single(L: [-1, 2, 3, 4, 5, 6]) == -123456)\nassert(multiple_to_single(L: [10, 15, 20, 25]) == 10152025)", "stop_tokens": ["\n}"]}
{"name": "mbpp_440_find_adverb_position", "language": "swift", "prompt": "\n/// Write a function to find the first adverb and their positions in a given sentence.\nfunc find_adverb_position(text: String) -> (Int, Int, String) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_440_find_adverb_position.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_adverb_position(text: \"clearly!! we can see the sky\") == (0, 7, \"clearly\"))\nassert(find_adverb_position(text: \"seriously!! there are many roses\") == (0, 9, \"seriously\"))\nassert(find_adverb_position(text: \"unfortunately!! sita is going to home\") == (0, 13, \"unfortunately\"))", "stop_tokens": ["\n}"]}
{"name": "mbpp_441_surfacearea_cube", "language": "swift", "prompt": "\n/// Write a function to find the surface area of a cube of a given size.\nfunc surfacearea_cube(l: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_441_surfacearea_cube.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(surfacearea_cube(l: 5) == 150)\nassert(surfacearea_cube(l: 3) == 54)\nassert(surfacearea_cube(l: 10) == 600)", "stop_tokens": ["\n}"]}
{"name": "mbpp_442_positive_count", "language": "swift", "prompt": "\n/// Write a function to find the ration of positive numbers in an array of integers.\nfunc positive_count(nums: [Int]) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_442_positive_count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(positive_count(nums: [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.54)\nassert(positive_count(nums: [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 0.69)\nassert(positive_count(nums: [2, 4, -6, -9, 11, -12, 14, -5, 17]) == 0.56)", "stop_tokens": ["\n}"]}
{"name": "mbpp_443_largest_neg", "language": "swift", "prompt": "\n/// Write a python function to find the largest negative number from the given list.\nfunc largest_neg(list1: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_443_largest_neg.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(largest_neg(list1: [1, 2, 3, -4, -6]) == -6)\nassert(largest_neg(list1: [1, 2, 3, -8, -9]) == -9)\nassert(largest_neg(list1: [1, 2, 3, 4, -1]) == -1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_444_trim_tuple", "language": "swift", "prompt": "\n/// Write a function to trim each list by k in the given lists.\nfunc trim_tuple(test_list: [[Int]], K: Int) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_444_trim_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(trim_tuple(test_list: [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], K: 2) == [[2], [9], [2], [2]])\nassert(trim_tuple(test_list: [[5, 3, 2, 1, 4], [3, 4, 9, 2, 1], [9, 1, 2, 3, 5], [4, 8, 2, 1, 7]], K: 1) == [[3, 2, 1], [4, 9, 2], [1, 2, 3], [8, 2, 1]])\nassert(trim_tuple(test_list: [[7, 8, 4, 9], [11, 8, 12, 4], [4, 1, 7, 8], [3, 6, 9, 7]], K: 1) == [[8, 4], [8, 12], [1, 7], [6, 9]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_445_index_multiplication", "language": "swift", "prompt": "\n/// Write a function to perform index wise multiplication of list elements in the given two lists.\nfunc index_multiplication(test_tup1: [[Int]], test_tup2: [[Int]]) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_445_index_multiplication.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(index_multiplication(test_tup1: [[1, 3], [4, 5], [2, 9], [1, 10]], test_tup2: [[6, 7], [3, 9], [1, 1], [7, 3]]) == [[6, 21], [12, 45], [2, 9], [7, 30]])\nassert(index_multiplication(test_tup1: [[2, 4], [5, 6], [3, 10], [2, 11]], test_tup2: [[7, 8], [4, 10], [2, 2], [8, 4]]) == [[14, 32], [20, 60], [6, 20], [16, 44]])\nassert(index_multiplication(test_tup1: [[3, 5], [6, 7], [4, 11], [3, 12]], test_tup2: [[8, 9], [5, 11], [3, 3], [9, 5]]) == [[24, 45], [30, 77], [12, 33], [27, 60]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_446_count_Occurrence", "language": "swift", "prompt": "\n/// Write a python function to count the occurence of all elements of list in a tuple.\nfunc count_Occurrence(tup: AnyHashable, lst: [AnyHashable]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_446_count_Occurrence.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_Occurrence(tup: (\"a\", \"a\", \"c\", \"b\", \"d\"), lst: [\"a\", \"b\"]) == 3)\nassert(count_Occurrence(tup: (1, 2, 3, 1, 4, 6, 7, 1, 4), lst: [1, 4, 7]) == 6)\nassert(count_Occurrence(tup: (1, 2, 3, 4, 5, 6), lst: [1, 2]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_447_cube_nums", "language": "swift", "prompt": "\n/// Write a function to find cubes of individual elements in a list.\nfunc cube_nums(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_447_cube_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cube_nums(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000])\nassert(cube_nums(nums: [10, 20, 30]) == [1000, 8000, 27000])\nassert(cube_nums(nums: [12, 15]) == [1728, 3375])", "stop_tokens": ["\n}"]}
{"name": "mbpp_448_cal_sum", "language": "swift", "prompt": "\n/// Write a function to calculate the sum of perrin numbers.\nfunc cal_sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_448_cal_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cal_sum(n: 9) == 49)\nassert(cal_sum(n: 10) == 66)\nassert(cal_sum(n: 11) == 88)", "stop_tokens": ["\n}"]}
{"name": "mbpp_450_extract_string", "language": "swift", "prompt": "\n/// Write a function to extract specified size of strings from a given list of string values.\nfunc extract_string(str: [String], l: Int) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_450_extract_string.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_string(str: [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"], l: 8) == [\"practice\", \"solution\"])\nassert(extract_string(str: [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"], l: 6) == [\"Python\"])\nassert(extract_string(str: [\"Python\", \"list\", \"exercises\", \"practice\", \"solution\"], l: 9) == [\"exercises\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_451_remove_whitespaces", "language": "swift", "prompt": "\n/// Write a function to remove all whitespaces from the given string.\nfunc remove_whitespaces(text1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_451_remove_whitespaces.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_whitespaces(text1: \" Google    Flutter \") == \"GoogleFlutter\")\nassert(remove_whitespaces(text1: \" Google    Dart \") == \"GoogleDart\")\nassert(remove_whitespaces(text1: \" iOS    Swift \") == \"iOSSwift\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_452_loss_amount", "language": "swift", "prompt": "\n/// Write a function that gives loss amount on a sale if the given amount has loss else return 0.\nfunc loss_amount(actual_cost: Int, sale_amount: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_452_loss_amount.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(loss_amount(actual_cost: 1500, sale_amount: 1200) == 0)\nassert(loss_amount(actual_cost: 100, sale_amount: 200) == 100)\nassert(loss_amount(actual_cost: 2000, sale_amount: 5000) == 3000)", "stop_tokens": ["\n}"]}
{"name": "mbpp_453_sumofFactors", "language": "swift", "prompt": "\n/// Write a python function to find the sum of even factors of a number.\nfunc sumofFactors(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_453_sumofFactors.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sumofFactors(n: 18) == 26)\nassert(sumofFactors(n: 30) == 48)\nassert(sumofFactors(n: 6) == 8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_454_text_match_wordz", "language": "swift", "prompt": "\n/// Write a function that matches a word containing 'z'.\nfunc text_match_wordz(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_454_text_match_wordz.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_wordz(text: \"pythonz.\") == true)\nassert(text_match_wordz(text: \"xyz.\") == true)\nassert(text_match_wordz(text: \"  lang  .\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_455_check_monthnumb_number", "language": "swift", "prompt": "\n/// Write a function to check whether the given month number contains 31 days or not.\nfunc check_monthnumb_number(monthnum2: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_455_check_monthnumb_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_monthnumb_number(monthnum2: 5) == true)\nassert(check_monthnumb_number(monthnum2: 2) == false)\nassert(check_monthnumb_number(monthnum2: 6) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_456_reverse_string_list", "language": "swift", "prompt": "\n/// Write a function to reverse each string in a given list of string values.\nfunc reverse_string_list(stringlist: [String]) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_456_reverse_string_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_string_list(stringlist: [\"Red\", \"Green\", \"Blue\", \"White\", \"Black\"]) == [\"deR\", \"neerG\", \"eulB\", \"etihW\", \"kcalB\"])\nassert(reverse_string_list(stringlist: [\"john\", \"amal\", \"joel\", \"george\"]) == [\"nhoj\", \"lama\", \"leoj\", \"egroeg\"])\nassert(reverse_string_list(stringlist: [\"jack\", \"john\", \"mary\"]) == [\"kcaj\", \"nhoj\", \"yram\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_457_Find_Min", "language": "swift", "prompt": "\n/// Write a python function to find the sublist having minimum length.\nfunc Find_Min(lst: [[AnyHashable]]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_457_Find_Min.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Find_Min(lst: [[1], [1, 2], [1, 2, 3]]) == [1])\nassert(Find_Min(lst: [[1, 1], [1, 1, 1], [1, 2, 7, 8]]) == [1, 1])\nassert(Find_Min(lst: [[\"x\"], [\"x\", \"y\"], [\"x\", \"y\", \"z\"]]) == [\"x\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_458_rectangle_area", "language": "swift", "prompt": "\n/// Write a function to find the area of a rectangle.\nfunc rectangle_area(l: Int, b: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_458_rectangle_area.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rectangle_area(l: 10, b: 20) == 200)\nassert(rectangle_area(l: 10, b: 5) == 50)\nassert(rectangle_area(l: 4, b: 2) == 8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_459_remove_uppercase", "language": "swift", "prompt": "\n/// Write a function to remove uppercase substrings from a given string.\nfunc remove_uppercase(str1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_459_remove_uppercase.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_uppercase(str1: \"cAstyoUrFavoRitETVshoWs\") == \"cstyoravoitshos\")\nassert(remove_uppercase(str1: \"wAtchTheinTernEtrAdIo\") == \"wtchheinerntrdo\")\nassert(remove_uppercase(str1: \"VoicESeaRchAndreComMendaTionS\") == \"oiceachndreomendaion\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_460_Extract", "language": "swift", "prompt": "\n/// Write a python function to get the first element of each sublist.\nfunc Extract(lst: [[Int]]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_460_Extract.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Extract(lst: [[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6])\nassert(Extract(lst: [[1, 2, 3], [4, 5]]) == [1, 4])\nassert(Extract(lst: [[9, 8, 1], [1, 2]]) == [9, 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_461_upper_ctr", "language": "swift", "prompt": "\n/// Write a python function to count the upper case characters in a given string.\nfunc upper_ctr(str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_461_upper_ctr.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(upper_ctr(str: \"PYthon\") == 1)\nassert(upper_ctr(str: \"BigData\") == 1)\nassert(upper_ctr(str: \"program\") == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_462_combinations_list", "language": "swift", "prompt": "\nextension [String]: Error {}\n        \n/// Write a function to find all possible combinations of the elements of a given list.\nfunc combinations_list(list1: [String]) -> [Result<[()], [String]>] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_462_combinations_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(combinations_list(list1: [\"orange\", \"red\", \"green\", \"blue\"]) == [.success([] as [()]), .failure([\"orange\"]), .failure([\"red\"]), .failure([\"red\", \"orange\"]), .failure([\"green\"]), .failure([\"green\", \"orange\"]), .failure([\"green\", \"red\"]), .failure([\"green\", \"red\", \"orange\"]), .failure([\"blue\"]), .failure([\"blue\", \"orange\"]), .failure([\"blue\", \"red\"]), .failure([\"blue\", \"red\", \"orange\"]), .failure([\"blue\", \"green\"]), .failure([\"blue\", \"green\", \"orange\"]), .failure([\"blue\", \"green\", \"red\"]), .failure([\"blue\", \"green\", \"red\", \"orange\"])])\nassert(combinations_list(list1: [\"red\", \"green\", \"blue\", \"white\", \"black\", \"orange\"]) == [.success([] as [()]), .failure([\"red\"]), .failure([\"green\"]), .failure([\"green\", \"red\"]), .failure([\"blue\"]), .failure([\"blue\", \"red\"]), .failure([\"blue\", \"green\"]), .failure([\"blue\", \"green\", \"red\"]), .failure([\"white\"]), .failure([\"white\", \"red\"]), .failure([\"white\", \"green\"]), .failure([\"white\", \"green\", \"red\"]), .failure([\"white\", \"blue\"]), .failure([\"white\", \"blue\", \"red\"]), .failure([\"white\", \"blue\", \"green\"]), .failure([\"white\", \"blue\", \"green\", \"red\"]), .failure([\"black\"]), .failure([\"black\", \"red\"]), .failure([\"black\", \"green\"]), .failure([\"black\", \"green\", \"red\"]), .failure([\"black\", \"blue\"]), .failure([\"black\", \"blue\", \"red\"]), .failure([\"black\", \"blue\", \"green\"]), .failure([\"black\", \"blue\", \"green\", \"red\"]), .failure([\"black\", \"white\"]), .failure([\"black\", \"white\", \"red\"]), .failure([\"black\", \"white\", \"green\"]), .failure([\"black\", \"white\", \"green\", \"red\"]), .failure([\"black\", \"white\", \"blue\"]), .failure([\"black\", \"white\", \"blue\", \"red\"]), .failure([\"black\", \"white\", \"blue\", \"green\"]), .failure([\"black\", \"white\", \"blue\", \"green\", \"red\"]), .failure([\"orange\"]), .failure([\"orange\", \"red\"]), .failure([\"orange\", \"green\"]), .failure([\"orange\", \"green\", \"red\"]), .failure([\"orange\", \"blue\"]), .failure([\"orange\", \"blue\", \"red\"]), .failure([\"orange\", \"blue\", \"green\"]), .failure([\"orange\", \"blue\", \"green\", \"red\"]), .failure([\"orange\", \"white\"]), .failure([\"orange\", \"white\", \"red\"]), .failure([\"orange\", \"white\", \"green\"]), .failure([\"orange\", \"white\", \"green\", \"red\"]), .failure([\"orange\", \"white\", \"blue\"]), .failure([\"orange\", \"white\", \"blue\", \"red\"]), .failure([\"orange\", \"white\", \"blue\", \"green\"]), .failure([\"orange\", \"white\", \"blue\", \"green\", \"red\"]), .failure([\"orange\", \"black\"]), .failure([\"orange\", \"black\", \"red\"]), .failure([\"orange\", \"black\", \"green\"]), .failure([\"orange\", \"black\", \"green\", \"red\"]), .failure([\"orange\", \"black\", \"blue\"]), .failure([\"orange\", \"black\", \"blue\", \"red\"]), .failure([\"orange\", \"black\", \"blue\", \"green\"]), .failure([\"orange\", \"black\", \"blue\", \"green\", \"red\"]), .failure([\"orange\", \"black\", \"white\"]), .failure([\"orange\", \"black\", \"white\", \"red\"]), .failure([\"orange\", \"black\", \"white\", \"green\"]), .failure([\"orange\", \"black\", \"white\", \"green\", \"red\"]), .failure([\"orange\", \"black\", \"white\", \"blue\"]), .failure([\"orange\", \"black\", \"white\", \"blue\", \"red\"]), .failure([\"orange\", \"black\", \"white\", \"blue\", \"green\"]), .failure([\"orange\", \"black\", \"white\", \"blue\", \"green\", \"red\"])])\nassert(combinations_list(list1: [\"red\", \"green\", \"black\", \"orange\"]) == [.success([] as [()]), .failure([\"red\"]), .failure([\"green\"]), .failure([\"green\", \"red\"]), .failure([\"black\"]), .failure([\"black\", \"red\"]), .failure([\"black\", \"green\"]), .failure([\"black\", \"green\", \"red\"]), .failure([\"orange\"]), .failure([\"orange\", \"red\"]), .failure([\"orange\", \"green\"]), .failure([\"orange\", \"green\", \"red\"]), .failure([\"orange\", \"black\"]), .failure([\"orange\", \"black\", \"red\"]), .failure([\"orange\", \"black\", \"green\"]), .failure([\"orange\", \"black\", \"green\", \"red\"])])", "stop_tokens": ["\n}"]}
{"name": "mbpp_463_max_subarray_product", "language": "swift", "prompt": "\n/// Write a function to find the maximum product subarray of the given array.\nfunc max_subarray_product(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_463_max_subarray_product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_subarray_product(arr: [1, -2, -3, 0, 7, -8, -2]) == 112)\nassert(max_subarray_product(arr: [6, -3, -10, 0, 2]) == 180)\nassert(max_subarray_product(arr: [-2, -40, 0, -2, -3]) == 80)", "stop_tokens": ["\n}"]}
{"name": "mbpp_464_check_value", "language": "swift", "prompt": "\n/// Write a function to check if all values are same in a dictionary.\nfunc check_value(dict: [String : Int], n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_464_check_value.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_value(dict: [\"Cierra Vega\" : 12, \"Alden Cantrell\" : 12, \"Kierra Gentry\" : 12, \"Pierre Cox\" : 12], n: 10) == false)\nassert(check_value(dict: [\"Cierra Vega\" : 12, \"Alden Cantrell\" : 12, \"Kierra Gentry\" : 12, \"Pierre Cox\" : 12], n: 12) == true)\nassert(check_value(dict: [\"Cierra Vega\" : 12, \"Alden Cantrell\" : 12, \"Kierra Gentry\" : 12, \"Pierre Cox\" : 12], n: 5) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_465_drop_empty", "language": "swift", "prompt": "\n/// Write a function to drop empty items from a given dictionary.\nfunc drop_empty(dict1: [String : String?]) -> [String : String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_465_drop_empty.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(drop_empty(dict1: [\"c1\" : \"Red\", \"c2\" : \"Green\", \"c3\" : nil]) == [\"c1\" : \"Red\", \"c2\" : \"Green\"])\nassert(drop_empty(dict1: [\"c1\" : \"Red\", \"c2\" : nil, \"c3\" : nil]) == [\"c1\" : \"Red\"])\nassert(drop_empty(dict1: [\"c1\" : nil, \"c2\" : \"Green\", \"c3\" : nil]) == [\"c2\" : \"Green\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_468_max_product", "language": "swift", "prompt": "\n/// Write a function to find the maximum product formed by multiplying numbers of an increasing subsequence of that array.\nfunc max_product(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_468_max_product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_product(arr: [3, 100, 4, 5, 150, 6]) == 3000)\nassert(max_product(arr: [4, 42, 55, 68, 80]) == 50265600)\nassert(max_product(arr: [10, 22, 9, 33, 21, 50, 41, 60]) == 2460)", "stop_tokens": ["\n}"]}
{"name": "mbpp_470_add_pairwise", "language": "swift", "prompt": "\n/// Write a function to find the pairwise addition of the neighboring elements of the given tuple.\nfunc add_pairwise(test_tup: (Int, Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_470_add_pairwise.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_pairwise(test_tup: (1, 5, 7, 8, 10)) == (6, 12, 15, 18))\nassert(add_pairwise(test_tup: (2, 6, 8, 9, 11)) == (8, 14, 17, 20))\nassert(add_pairwise(test_tup: (3, 7, 9, 10, 12)) == (10, 16, 19, 22))", "stop_tokens": ["\n}"]}
{"name": "mbpp_471_find_remainder", "language": "swift", "prompt": "\n/// Write a python function to find the product of the array multiplication modulo n.\nfunc find_remainder(arr: [Int], n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_471_find_remainder.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_remainder(arr: [100, 10, 5, 25, 35, 14], n: 11) == 9)\nassert(find_remainder(arr: [1, 1, 1], n: 1) == 0)\nassert(find_remainder(arr: [1, 2, 1], n: 2) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_472_check_Consecutive", "language": "swift", "prompt": "\n/// Write a python function to check whether the given list contains consecutive numbers or not.\nfunc check_Consecutive(l: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_472_check_Consecutive.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_Consecutive(l: [1, 2, 3, 4, 5]) == true)\nassert(check_Consecutive(l: [1, 2, 3, 5, 6]) == false)\nassert(check_Consecutive(l: [1, 2, 1]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_474_replace_char", "language": "swift", "prompt": "\n/// Write a function to replace characters in a string.\nfunc replace_char(str1: String, ch: String, newch: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_474_replace_char.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_char(str1: \"polygon\", ch: \"y\", newch: \"l\") == \"pollgon\")\nassert(replace_char(str1: \"character\", ch: \"c\", newch: \"a\") == \"aharaater\")\nassert(replace_char(str1: \"python\", ch: \"l\", newch: \"a\") == \"python\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_475_sort_counter", "language": "swift", "prompt": "\n/// Write a function to sort a dictionary by value.\nfunc sort_counter(dict1: [String : Int]) -> [(String, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_475_sort_counter.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_counter(dict1: [\"Math\" : 81, \"Physics\" : 83, \"Chemistry\" : 87]) == [(\"Chemistry\", 87), (\"Physics\", 83), (\"Math\", 81)])\nassert(sort_counter(dict1: [\"Math\" : 400, \"Physics\" : 300, \"Chemistry\" : 250]) == [(\"Math\", 400), (\"Physics\", 300), (\"Chemistry\", 250)])\nassert(sort_counter(dict1: [\"Math\" : 900, \"Physics\" : 1000, \"Chemistry\" : 1250]) == [(\"Chemistry\", 1250), (\"Physics\", 1000), (\"Math\", 900)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_476_big_sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of the largest and smallest value in a given array.\nfunc big_sum(nums: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_476_big_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(big_sum(nums: [1, 2, 3]) == 4)\nassert(big_sum(nums: [-1, 2, 3, 4]) == 3)\nassert(big_sum(nums: [2, 3, 6]) == 8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_477_is_lower", "language": "swift", "prompt": "\n/// Write a python function to convert the given string to lower case.\nfunc is_lower(string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_477_is_lower.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_lower(string: \"InValid\") == \"invalid\")\nassert(is_lower(string: \"TruE\") == \"true\")\nassert(is_lower(string: \"SenTenCE\") == \"sentence\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_478_remove_lowercase", "language": "swift", "prompt": "\n/// Write a function to remove lowercase substrings from a given string.\nfunc remove_lowercase(str1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_478_remove_lowercase.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_lowercase(str1: \"PYTHon\") == \"PYTH\")\nassert(remove_lowercase(str1: \"FInD\") == \"FID\")\nassert(remove_lowercase(str1: \"STRinG\") == \"STRG\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_479_first_Digit", "language": "swift", "prompt": "\n/// Write a python function to find the first digit of a given number.\nfunc first_Digit(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_479_first_Digit.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(first_Digit(n: 123) == 1)\nassert(first_Digit(n: 456) == 4)\nassert(first_Digit(n: 12) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_4_heap_queue_largest", "language": "swift", "prompt": "\n/// Write a function to find the n largest integers from a given list of numbers, returned in descending order.\nfunc heap_queue_largest(nums: [Int], n: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_4_heap_queue_largest.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(heap_queue_largest(nums: [25, 35, 22, 85, 14, 65, 75, 22, 58], n: 3) == [85, 75, 65])\nassert(heap_queue_largest(nums: [25, 35, 22, 85, 14, 65, 75, 22, 58], n: 2) == [85, 75])\nassert(heap_queue_largest(nums: [25, 35, 22, 85, 14, 65, 75, 22, 58], n: 5) == [85, 75, 65, 58, 35])", "stop_tokens": ["\n}"]}
{"name": "mbpp_554_Split", "language": "swift", "prompt": "\n/// Write a python function which takes a list of integers and only returns the odd ones.\nfunc Split(list: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_554_Split.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Split(list: [1, 2, 3, 4, 5, 6]) == [1, 3, 5])\nassert(Split(list: [10, 11, 12, 13]) == [11, 13])\nassert(Split(list: [7, 8, 9, 1]) == [7, 9, 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_555_difference", "language": "swift", "prompt": "\n/// Write a python function to find the difference between the sum of cubes of the first n natural numbers and the sum of the first n natural numbers.\nfunc difference(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_555_difference.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(difference(n: 3) == 30)\nassert(difference(n: 5) == 210)\nassert(difference(n: 2) == 6)", "stop_tokens": ["\n}"]}
{"name": "mbpp_556_find_Odd_Pair", "language": "swift", "prompt": "\n/// Write a python function to count the number of pairs whose xor value is odd.\nfunc find_Odd_Pair(A: [Int], N: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_556_find_Odd_Pair.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Odd_Pair(A: [5, 4, 7, 2, 1], N: 5) == 6)\nassert(find_Odd_Pair(A: [7, 2, 8, 1, 0, 5, 11], N: 7) == 12)\nassert(find_Odd_Pair(A: [1, 2, 3], N: 3) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_557_toggle_string", "language": "swift", "prompt": "\n/// Write a function to toggle the case of all characters in a string.\nfunc toggle_string(string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_557_toggle_string.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(toggle_string(string: \"Python\") == \"pYTHON\")\nassert(toggle_string(string: \"Pangram\") == \"pANGRAM\")\nassert(toggle_string(string: \"LIttLE\") == \"liTTle\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_558_digit_distance_nums", "language": "swift", "prompt": "\n/// Write a python function to find the sum of the per-digit difference between two integers.\nfunc digit_distance_nums(n1: Int, n2: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_558_digit_distance_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(digit_distance_nums(n1: 1, n2: 2) == 1)\nassert(digit_distance_nums(n1: 23, n2: 56) == 6)\nassert(digit_distance_nums(n1: 123, n2: 256) == 7)", "stop_tokens": ["\n}"]}
{"name": "mbpp_559_max_sub_array_sum", "language": "swift", "prompt": "\n/// Write a function to find the sum of the largest contiguous sublist in the given list.\nfunc max_sub_array_sum(a: [Int], size: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_559_max_sub_array_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_sub_array_sum(a: [-2, -3, 4, -1, -2, 1, 5, -3], size: 8) == 7)\nassert(max_sub_array_sum(a: [-3, -4, 5, -2, -3, 2, 6, -4], size: 8) == 8)\nassert(max_sub_array_sum(a: [-4, -5, 6, -3, -4, 3, 7, -5], size: 8) == 10)", "stop_tokens": ["\n}"]}
{"name": "mbpp_560_union_elements", "language": "swift", "prompt": "\n/// Write a function to find the union of the elements of two given lists and output them in sorted order.\nfunc union_elements(test_tup1: [Int], test_tup2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_560_union_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(union_elements(test_tup1: [3, 4, 5, 6], test_tup2: [5, 7, 4, 10]) == [3, 4, 5, 6, 7, 10])\nassert(union_elements(test_tup1: [1, 2, 3, 4], test_tup2: [3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6])\nassert(union_elements(test_tup1: [11, 12, 13, 14], test_tup2: [13, 15, 16, 17]) == [11, 12, 13, 14, 15, 16, 17])", "stop_tokens": ["\n}"]}
{"name": "mbpp_562_Find_Max_Length", "language": "swift", "prompt": "\n/// Write a python function to find the length of the longest sublists.\nfunc Find_Max_Length(lst: [[Int]]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_562_Find_Max_Length.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Find_Max_Length(lst: [[1], [1, 4], [5, 6, 7, 8]]) == 4)\nassert(Find_Max_Length(lst: [[0, 1], [2, 2], [3, 2, 1]]) == 3)\nassert(Find_Max_Length(lst: [[7], [22, 23], [13, 14, 15], [10, 20, 30, 40, 50]]) == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_563_extract_values", "language": "swift", "prompt": "\n/// Write a function to extract values between quotation marks from a string.\nfunc extract_values(text: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_563_extract_values.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_values(text: \"\\\"Python\\\", \\\"PHP\\\", \\\"Java\\\"\") == [\"Python\", \"PHP\", \"Java\"])\nassert(extract_values(text: \"\\\"python\\\",\\\"program\\\",\\\"language\\\"\") == [\"python\", \"program\", \"language\"])\nassert(extract_values(text: \"\\\"red\\\",\\\"blue\\\",\\\"green\\\",\\\"yellow\\\"\") == [\"red\", \"blue\", \"green\", \"yellow\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_564_count_Pairs", "language": "swift", "prompt": "\n/// Write a python function which takes a list of integers and counts the number of possible unordered pairs where both elements are unequal.\nfunc count_Pairs(arr: [Int], n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_564_count_Pairs.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_Pairs(arr: [1, 2, 1], n: 3) == 2)\nassert(count_Pairs(arr: [1, 1, 1, 1], n: 4) == 0)\nassert(count_Pairs(arr: [1, 2, 3, 4, 5], n: 5) == 10)", "stop_tokens": ["\n}"]}
{"name": "mbpp_565_split", "language": "swift", "prompt": "\n/// Write a python function to split a string into characters.\nfunc split(word: String) -> [String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_565_split.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split(word: \"python\") == [\"p\", \"y\", \"t\", \"h\", \"o\", \"n\"])\nassert(split(word: \"Name\") == [\"N\", \"a\", \"m\", \"e\"])\nassert(split(word: \"program\") == [\"p\", \"r\", \"o\", \"g\", \"r\", \"a\", \"m\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_566_sum_digits", "language": "swift", "prompt": "\n/// Write a function to get the sum of the digits of a non-negative integer.\nfunc sum_digits(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_566_sum_digits.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_digits(n: 345) == 12)\nassert(sum_digits(n: 12) == 3)\nassert(sum_digits(n: 97) == 16)", "stop_tokens": ["\n}"]}
{"name": "mbpp_567_issort_list", "language": "swift", "prompt": "\n/// Write a function to check whether a specified list is sorted or not.\nfunc issort_list(list1: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_567_issort_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(issort_list(list1: [1, 2, 4, 6, 8, 10, 12, 14, 16, 17]) == true)\nassert(issort_list(list1: [1, 2, 4, 6, 8, 10, 12, 14, 20, 17]) == false)\nassert(issort_list(list1: [1, 2, 4, 6, 8, 10, 15, 14, 20]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_568_empty_list", "language": "swift", "prompt": "\n/// Write a function to create a list of N empty dictionaries.\nfunc empty_list(length: Int) -> [[() : ()]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_568_empty_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(empty_list(length: 5) == [[:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()]])\nassert(empty_list(length: 6) == [[:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()]])\nassert(empty_list(length: 7) == [[:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()], [:] as [() : ()]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_569_sort_sublists", "language": "swift", "prompt": "\n/// Write a function to sort each sublist of strings in a given list of lists.\nfunc sort_sublists(list1: [[String]]) -> [[String]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_569_sort_sublists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_sublists(list1: [[\"green\", \"orange\"], [\"black\", \"white\"], [\"white\", \"black\", \"orange\"]]) == [[\"green\", \"orange\"], [\"black\", \"white\"], [\"black\", \"orange\", \"white\"]])\nassert(sort_sublists(list1: [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]]) == [[\"green\", \"orange\"], [\"black\"], [\"green\", \"orange\"], [\"white\"]])\nassert(sort_sublists(list1: [[\"a\", \"b\"], [\"d\", \"c\"], [\"g\", \"h\"], [\"f\", \"e\"]]) == [[\"a\", \"b\"], [\"c\", \"d\"], [\"g\", \"h\"], [\"e\", \"f\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_56_checks", "language": "swift", "prompt": "\n/// Write a python function to check if a given number is one less than twice its reverse.\nfunc checks(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_56_checks.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(checks(n: 70) == false)\nassert(checks(n: 23) == false)\nassert(checks(n: 73) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_572_two_unique_nums", "language": "swift", "prompt": "\n/// Write a python function to remove duplicate numbers from a given number of lists.\nfunc two_unique_nums(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_572_two_unique_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(two_unique_nums(nums: [1, 2, 3, 2, 3, 4, 5]) == [1, 4, 5])\nassert(two_unique_nums(nums: [1, 2, 3, 2, 4, 5]) == [1, 3, 4, 5])\nassert(two_unique_nums(nums: [1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5])", "stop_tokens": ["\n}"]}
{"name": "mbpp_573_unique_product", "language": "swift", "prompt": "\n/// Write a python function to calculate the product of the unique numbers in a given list.\nfunc unique_product(list_data: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_573_unique_product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_product(list_data: [10, 20, 30, 40, 20, 50, 60, 40]) == 720000000)\nassert(unique_product(list_data: [1, 2, 3, 1]) == 6)\nassert(unique_product(list_data: [7, 8, 9, 0, 1, 1]) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_574_surfacearea_cylinder", "language": "swift", "prompt": "\n/// Write a function to find the surface area of a cylinder.\nfunc surfacearea_cylinder(r: Int, h: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_574_surfacearea_cylinder.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(surfacearea_cylinder(r: 10, h: 5) == 942.45)\nassert(surfacearea_cylinder(r: 4, h: 5) == 226.18800000000002)\nassert(surfacearea_cylinder(r: 4, h: 10) == 351.848)", "stop_tokens": ["\n}"]}
{"name": "mbpp_576_is_Sub_Array", "language": "swift", "prompt": "\n/// Write a python function to check whether a list is sublist of another or not.\nfunc is_Sub_Array(A: [Int], B: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_576_is_Sub_Array.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_Sub_Array(A: [1, 4, 3, 5], B: [1, 2]) == false)\nassert(is_Sub_Array(A: [1, 2, 1], B: [1, 2, 1]) == true)\nassert(is_Sub_Array(A: [1, 0, 2, 2], B: [2, 2, 0]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_577_last_Digit_Factorial", "language": "swift", "prompt": "\n/// Write a python function to find the last digit in factorial of a given number.\nfunc last_Digit_Factorial(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_577_last_Digit_Factorial.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(last_Digit_Factorial(n: 4) == 4)\nassert(last_Digit_Factorial(n: 21) == 0)\nassert(last_Digit_Factorial(n: 30) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_578_interleave_lists", "language": "swift", "prompt": "\n/// Write a function to interleave 3 lists of the same length into a single flat list.\nfunc interleave_lists(list1: [Int], list2: [Int], list3: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_578_interleave_lists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(interleave_lists(list1: [1, 2, 3, 4, 5, 6, 7], list2: [10, 20, 30, 40, 50, 60, 70], list3: [100, 200, 300, 400, 500, 600, 700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700])\nassert(interleave_lists(list1: [10, 20], list2: [15, 2], list3: [5, 10]) == [10, 15, 5, 20, 2, 10])\nassert(interleave_lists(list1: [11, 44], list2: [10, 15], list3: [20, 5]) == [11, 10, 20, 44, 15, 5])", "stop_tokens": ["\n}"]}
{"name": "mbpp_579_find_dissimilar", "language": "swift", "prompt": "\n/// Write a function to find the dissimilar elements in the given two tuples.\nfunc find_dissimilar(test_tup1: (Int, Int, Int, Int), test_tup2: (Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_579_find_dissimilar.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_dissimilar(test_tup1: (3, 4, 5, 6), test_tup2: (5, 7, 4, 10)) == (3, 6, 7, 10))\nassert(find_dissimilar(test_tup1: (1, 2, 3, 4), test_tup2: (7, 2, 3, 9)) == (1, 4, 7, 9))\nassert(find_dissimilar(test_tup1: (21, 11, 25, 26), test_tup2: (26, 34, 21, 36)) == (34, 36, 11, 25))", "stop_tokens": ["\n}"]}
{"name": "mbpp_57_find_Max_Num", "language": "swift", "prompt": "\n/// Write a python function to find the largest number that can be formed with the given list of digits.\nfunc find_Max_Num(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_57_find_Max_Num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Max_Num(arr: [1, 2, 3]) == 321)\nassert(find_Max_Num(arr: [4, 5, 6, 1]) == 6541)\nassert(find_Max_Num(arr: [1, 2, 3, 9]) == 9321)", "stop_tokens": ["\n}"]}
{"name": "mbpp_580_extract_even", "language": "swift", "prompt": "\n/// Write a function to remove uneven elements in the nested mixed tuple.\nfunc extract_even(test_tuple: (Int, Int, (Int, Int, (Int, Int)), Int, Int)) -> AnyHashable {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_580_extract_even.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_even(test_tuple: (4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8))\nassert(extract_even(test_tuple: (5, 6, (8, 7, (4, 8)), 7, 9)) == (6, (8, (4, 8))))\nassert(extract_even(test_tuple: (5, 6, (9, 8, (4, 6)), 8, 10)) == (6, (8, (4, 6)), 8, 10))", "stop_tokens": ["\n}"]}
{"name": "mbpp_581_surface_Area", "language": "swift", "prompt": "\n/// Write a python function to find the surface area of a square pyramid with a given base edge and height.\nfunc surface_Area(b: Int, s: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_581_surface_Area.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(surface_Area(b: 3, s: 4) == 33)\nassert(surface_Area(b: 4, s: 5) == 56)\nassert(surface_Area(b: 1, s: 2) == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_583_catalan_number", "language": "swift", "prompt": "\n/// Write a function which returns nth catalan number.\nfunc catalan_number(num: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_583_catalan_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(catalan_number(num: 10) == 16796)\nassert(catalan_number(num: 9) == 4862)\nassert(catalan_number(num: 7) == 429)", "stop_tokens": ["\n}"]}
{"name": "mbpp_584_find_adverbs", "language": "swift", "prompt": "\n/// Write a function to find the first adverb ending with ly and its positions in a given string.\nfunc find_adverbs(text: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_584_find_adverbs.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_adverbs(text: \"Clearly, he has no excuse for such behavior.\") == \"0-7: Clearly\")\nassert(find_adverbs(text: \"Please handle the situation carefuly\") == \"28-36: carefuly\")\nassert(find_adverbs(text: \"Complete the task quickly\") == \"18-25: quickly\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_585_expensive_items", "language": "swift", "prompt": "\nextension Double: Error {}\n        \n/// Write a function to find the n most expensive items in a given dataset.\nfunc expensive_items(items: [[String : Result<String, Double>]], n: Int) -> [[String : Result<String, Double>]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_585_expensive_items.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(expensive_items(items: [[\"name\" : .success(\"Item-1\"), \"price\" : .failure(101.1)], [\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)]], n: 1) == [[\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)]])\nassert(expensive_items(items: [[\"name\" : .success(\"Item-1\"), \"price\" : .failure(101.1)], [\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)], [\"name\" : .success(\"Item-3\"), \"price\" : .failure(45.09)]], n: 2) == [[\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)], [\"name\" : .success(\"Item-1\"), \"price\" : .failure(101.1)]])\nassert(expensive_items(items: [[\"name\" : .success(\"Item-1\"), \"price\" : .failure(101.1)], [\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)], [\"name\" : .success(\"Item-3\"), \"price\" : .failure(45.09)], [\"name\" : .success(\"Item-4\"), \"price\" : .failure(22.75)]], n: 1) == [[\"name\" : .success(\"Item-2\"), \"price\" : .failure(555.22)]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_586_split_Arr", "language": "swift", "prompt": "\n/// Write a python function to split a list at the nth eelment and add the first part to the end.\nfunc split_Arr(l: [Int], n: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_586_split_Arr.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(split_Arr(l: [12, 10, 5, 6, 52, 36], n: 2) == [5, 6, 52, 36, 12, 10])\nassert(split_Arr(l: [1, 2, 3, 4], n: 1) == [2, 3, 4, 1])\nassert(split_Arr(l: [0, 1, 2, 3, 4, 5, 6, 7], n: 3) == [3, 4, 5, 6, 7, 0, 1, 2])", "stop_tokens": ["\n}"]}
{"name": "mbpp_587_list_tuple", "language": "swift", "prompt": "\n/// Write a function to convert a list to a tuple.\nfunc list_tuple(listx: [Int]) -> AnyHashable {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_587_list_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(list_tuple(listx: [5, 10, 7, 4, 15, 3]) == (5, 10, 7, 4, 15, 3))\nassert(list_tuple(listx: [2, 4, 5, 6, 2, 3, 4, 4, 7]) == (2, 4, 5, 6, 2, 3, 4, 4, 7))\nassert(list_tuple(listx: [58, 44, 56]) == (58, 44, 56))", "stop_tokens": ["\n}"]}
{"name": "mbpp_588_big_diff", "language": "swift", "prompt": "\n/// Write a python function to find the difference between largest and smallest value in a given list.\nfunc big_diff(nums: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_588_big_diff.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(big_diff(nums: [1, 2, 3, 4]) == 3)\nassert(big_diff(nums: [4, 5, 12]) == 8)\nassert(big_diff(nums: [9, 2, 3]) == 7)", "stop_tokens": ["\n}"]}
{"name": "mbpp_589_perfect_squares", "language": "swift", "prompt": "\n/// Write a function to find perfect squares between two given numbers.\nfunc perfect_squares(a: Int, b: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_589_perfect_squares.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(perfect_squares(a: 1, b: 30) == [1, 4, 9, 16, 25])\nassert(perfect_squares(a: 50, b: 100) == [64, 81, 100])\nassert(perfect_squares(a: 100, b: 200) == [100, 121, 144, 169, 196])", "stop_tokens": ["\n}"]}
{"name": "mbpp_58_opposite_Signs", "language": "swift", "prompt": "\n/// Write a python function to check whether the given two integers have opposite sign or not.\nfunc opposite_Signs(x: Int, y: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_58_opposite_Signs.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(opposite_Signs(x: 1, y: -2) == true)\nassert(opposite_Signs(x: 3, y: 2) == false)\nassert(opposite_Signs(x: -10, y: -10) == false)\nassert(opposite_Signs(x: -2, y: 2) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_591_swap_List", "language": "swift", "prompt": "\n/// Write a python function to interchange the first and last elements in a list.\nfunc swap_List(newList: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_591_swap_List.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(swap_List(newList: [12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12])\nassert(swap_List(newList: [1, 2, 3]) == [3, 2, 1])\nassert(swap_List(newList: [4, 5, 6]) == [6, 5, 4])", "stop_tokens": ["\n}"]}
{"name": "mbpp_592_sum_Of_product", "language": "swift", "prompt": "\n/// Write a python function to find the sum of the product of consecutive binomial co-efficients.\nfunc sum_Of_product(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_592_sum_Of_product.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_Of_product(n: 3) == 15)\nassert(sum_Of_product(n: 4) == 56)\nassert(sum_Of_product(n: 1) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_593_removezero_ip", "language": "swift", "prompt": "\n/// Write a function to remove leading zeroes from an ip address.\nfunc removezero_ip(ip: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_593_removezero_ip.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(removezero_ip(ip: \"216.08.094.196\") == \"216.8.94.196\")\nassert(removezero_ip(ip: \"12.01.024\") == \"12.1.24\")\nassert(removezero_ip(ip: \"216.08.094.0196\") == \"216.8.94.196\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_594_diff_even_odd", "language": "swift", "prompt": "\n/// Write a function to find the difference of the first even and first odd number of a given list.\nfunc diff_even_odd(list1: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_594_diff_even_odd.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(diff_even_odd(list1: [1, 3, 5, 7, 4, 1, 6, 8]) == 3)\nassert(diff_even_odd(list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 1)\nassert(diff_even_odd(list1: [1, 5, 7, 9, 10]) == 9)", "stop_tokens": ["\n}"]}
{"name": "mbpp_595_min_Swaps", "language": "swift", "prompt": "\n/// Write a python function to count minimum number of swaps required to convert one binary number represented as a string to another.\nfunc min_Swaps(str1: String, str2: String) -> AnyHashable {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_595_min_Swaps.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_Swaps(str1: \"1101\", str2: \"1110\") == 1)\nassert(min_Swaps(str1: \"111\", str2: \"000\") == \"Not Possible\")\nassert(min_Swaps(str1: \"111\", str2: \"110\") == \"Not Possible\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_597_find_kth", "language": "swift", "prompt": "\n/// Write a function to find kth element from the given two sorted arrays.\nfunc find_kth(arr1: [Int], arr2: [Int], k: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_597_find_kth.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_kth(arr1: [2, 3, 6, 7, 9], arr2: [1, 4, 8, 10], k: 5) == 6)\nassert(find_kth(arr1: [100, 112, 256, 349, 770], arr2: [72, 86, 113, 119, 265, 445, 892], k: 7) == 256)\nassert(find_kth(arr1: [3, 4, 7, 8, 10], arr2: [2, 5, 9, 11], k: 6) == 8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_598_armstrong_number", "language": "swift", "prompt": "\n/// Write a function to check whether the given number is armstrong or not.\nfunc armstrong_number(number: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_598_armstrong_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(armstrong_number(number: 153) == true)\nassert(armstrong_number(number: 259) == false)\nassert(armstrong_number(number: 4458) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_599_sum_average", "language": "swift", "prompt": "\n/// Write a function to find sum and average of first n natural numbers.\nfunc sum_average(number: Int) -> (Int, Double) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_599_sum_average.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_average(number: 10) == (55, 5.5))\nassert(sum_average(number: 15) == (120, 8.0))\nassert(sum_average(number: 20) == (210, 10.5))", "stop_tokens": ["\n}"]}
{"name": "mbpp_59_is_octagonal", "language": "swift", "prompt": "\n/// Write a function to find the nth octagonal number.\nfunc is_octagonal(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_59_is_octagonal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_octagonal(n: 5) == 65)\nassert(is_octagonal(n: 10) == 280)\nassert(is_octagonal(n: 15) == 645)", "stop_tokens": ["\n}"]}
{"name": "mbpp_600_is_Even", "language": "swift", "prompt": "\n/// Write a python function to check whether the given number is even or not.\nfunc is_Even(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_600_is_Even.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_Even(n: 1) == false)\nassert(is_Even(n: 2) == true)\nassert(is_Even(n: 3) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_602_first_repeated_char", "language": "swift", "prompt": "\n/// Write a python function to find the first repeated character in a given string.\nfunc first_repeated_char(str1: String) -> String? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_602_first_repeated_char.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(first_repeated_char(str1: \"abcabc\") == \"a\")\nassert(first_repeated_char(str1: \"abc\") == nil)\nassert(first_repeated_char(str1: \"123123\") == \"1\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_603_get_ludic", "language": "swift", "prompt": "\n/// Write a function to get all lucid numbers smaller than or equal to a given integer.\nfunc get_ludic(n: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_603_get_ludic.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_ludic(n: 10) == [1, 2, 3, 5, 7])\nassert(get_ludic(n: 25) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25])\nassert(get_ludic(n: 45) == [1, 2, 3, 5, 7, 11, 13, 17, 23, 25, 29, 37, 41, 43])", "stop_tokens": ["\n}"]}
{"name": "mbpp_604_reverse_words", "language": "swift", "prompt": "\n/// Write a function to reverse words seperated by spaces in a given string.\nfunc reverse_words(s: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_604_reverse_words.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_words(s: \"python program\") == \"program python\")\nassert(reverse_words(s: \"java language\") == \"language java\")\nassert(reverse_words(s: \"indian man\") == \"man indian\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_605_prime_num", "language": "swift", "prompt": "\n/// Write a function to check if the given integer is a prime number.\nfunc prime_num(num: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_605_prime_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(prime_num(num: 13) == true)\nassert(prime_num(num: 7) == true)\nassert(prime_num(num: -1010) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_606_radian_degree", "language": "swift", "prompt": "\n/// Write a function to convert degrees to radians.\nfunc radian_degree(degree: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_606_radian_degree.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(radian_degree(degree: 90) == 1.5707963267948966)\nassert(radian_degree(degree: 60) == 1.0471975511965976)\nassert(radian_degree(degree: 120) == 2.0943951023931953)", "stop_tokens": ["\n}"]}
{"name": "mbpp_607_find_literals", "language": "swift", "prompt": "\n/// Write a function to search a string for a regex pattern. The function should return the matching subtring, a start index and an end index.\nfunc find_literals(text: String, pattern: String) -> (String, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_607_find_literals.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_literals(text: \"The quick brown fox jumps over the lazy dog.\", pattern: \"fox\") == (\"fox\", 16, 19))\nassert(find_literals(text: \"Its been a very crazy procedure right\", pattern: \"crazy\") == (\"crazy\", 16, 21))\nassert(find_literals(text: \"Hardest choices required strongest will\", pattern: \"will\") == (\"will\", 35, 39))", "stop_tokens": ["\n}"]}
{"name": "mbpp_608_bell_Number", "language": "swift", "prompt": "\n/// Write a python function to find nth bell number.\nfunc bell_Number(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_608_bell_Number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(bell_Number(n: 2) == 2)\nassert(bell_Number(n: 3) == 5)\nassert(bell_Number(n: 4) == 15)", "stop_tokens": ["\n}"]}
{"name": "mbpp_610_remove_kth_element", "language": "swift", "prompt": "\n/// Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\nfunc remove_kth_element(list1: [Int], L: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_610_remove_kth_element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_kth_element(list1: [1, 1, 2, 3, 4, 4, 5, 1], L: 3) == [1, 1, 3, 4, 4, 5, 1])\nassert(remove_kth_element(list1: [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4], L: 4) == [0, 0, 1, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])\nassert(remove_kth_element(list1: [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10], L: 5) == [10, 10, 15, 19, 18, 17, 26, 26, 17, 18, 10])", "stop_tokens": ["\n}"]}
{"name": "mbpp_611_max_of_nth", "language": "swift", "prompt": "\n/// Write a function which given a matrix represented as a list of lists returns the max of the n'th column.\nfunc max_of_nth(test_list: [[Int]], N: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_611_max_of_nth.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_of_nth(test_list: [[5, 6, 7], [1, 3, 5], [8, 9, 19]], N: 2) == 19)\nassert(max_of_nth(test_list: [[6, 7, 8], [2, 4, 6], [9, 10, 20]], N: 1) == 10)\nassert(max_of_nth(test_list: [[7, 8, 9], [3, 5, 7], [10, 11, 21]], N: 1) == 11)", "stop_tokens": ["\n}"]}
{"name": "mbpp_612_merge", "language": "swift", "prompt": "\n/// Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\nfunc merge(lst: [[AnyHashable]]) -> [[AnyHashable]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_612_merge.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(merge(lst: [[\"x\", \"y\"], [\"a\", \"b\"], [\"m\", \"n\"]]) == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"]])\nassert(merge(lst: [[1, 2], [3, 4], [5, 6], [7, 8]]) == [[1, 3, 5, 7], [2, 4, 6, 8]])\nassert(merge(lst: [[\"x\", \"y\", \"z\"], [\"a\", \"b\", \"c\"], [\"m\", \"n\", \"o\"]]) == [[\"x\", \"a\", \"m\"], [\"y\", \"b\", \"n\"], [\"z\", \"c\", \"o\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_614_cummulative_sum", "language": "swift", "prompt": "\n/// Write a function to find the cumulative sum of all the values that are present in the given list of lists.\nfunc cummulative_sum(test_list: [[Int]]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_614_cummulative_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(cummulative_sum(test_list: [[1, 3], [5, 6, 7], [2, 6]]) == 30)\nassert(cummulative_sum(test_list: [[2, 4], [6, 7, 8], [3, 7]]) == 37)\nassert(cummulative_sum(test_list: [[3, 5], [7, 8, 9], [4, 8]]) == 44)", "stop_tokens": ["\n}"]}
{"name": "mbpp_615_average_tuple", "language": "swift", "prompt": "\n/// Write a function which takes a lists of lists and returns the average value for each sublist as a list.\nfunc average_tuple(nums: [[Int]]) -> [Double] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_615_average_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(average_tuple(nums: [[10, 10, 10, 12], [30, 45, 56, 45], [81, 80, 39, 32], [1, 2, 3, 4]]) == [30.5, 34.25, 27.0, 23.25])\nassert(average_tuple(nums: [[1, 1, -5], [30, -15, 56], [81, -60, -39], [-10, 2, 3]]) == [25.5, -18.0, 3.75])\nassert(average_tuple(nums: [[100, 100, 100, 120], [300, 450, 560, 450], [810, 800, 390, 320], [10, 20, 30, 40]]) == [305.0, 342.5, 270.0, 232.5])", "stop_tokens": ["\n}"]}
{"name": "mbpp_616_tuple_modulo", "language": "swift", "prompt": "\n/// Write a function which takes two tuples of the same length and performs the element wise modulo.\nfunc tuple_modulo(test_tup1: (Int, Int, Int, Int), test_tup2: (Int, Int, Int, Int)) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_616_tuple_modulo.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tuple_modulo(test_tup1: (10, 4, 5, 6), test_tup2: (5, 6, 7, 5)) == (0, 4, 5, 1))\nassert(tuple_modulo(test_tup1: (11, 5, 6, 7), test_tup2: (6, 7, 8, 6)) == (5, 5, 6, 1))\nassert(tuple_modulo(test_tup1: (12, 6, 7, 8), test_tup2: (7, 8, 9, 7)) == (5, 6, 7, 1))", "stop_tokens": ["\n}"]}
{"name": "mbpp_617_min_Jumps", "language": "swift", "prompt": "\n/// Write a function to check for the number of jumps required of given length to reach a point of form (d, 0) from origin in a 2d plane.\nfunc min_Jumps(steps: (Int, Int), d: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_617_min_Jumps.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_Jumps(steps: (3, 4), d: 11) == 3.5)\nassert(min_Jumps(steps: (3, 4), d: 0) == 0)\nassert(min_Jumps(steps: (11, 14), d: 11) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_618_div_list", "language": "swift", "prompt": "\n/// Write a function to divide two lists element wise.\nfunc div_list(nums1: [Int], nums2: [Int]) -> [Double] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_618_div_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(div_list(nums1: [4, 5, 6], nums2: [1, 2, 3]) == [4.0, 2.5, 2.0])\nassert(div_list(nums1: [3, 2], nums2: [1, 4]) == [3.0, 0.5])\nassert(div_list(nums1: [90, 120], nums2: [50, 70]) == [1.8, 1.7142857142857142])", "stop_tokens": ["\n}"]}
{"name": "mbpp_619_move_num", "language": "swift", "prompt": "\n/// Write a function to move all the numbers to the end of the given string.\nfunc move_num(test_str: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_619_move_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_num(test_str: \"I1love143you55three3000thousand\") == \"Iloveyouthreethousand1143553000\")\nassert(move_num(test_str: \"Avengers124Assemble\") == \"AvengersAssemble124\")\nassert(move_num(test_str: \"Its11our12path13to14see15things16do17things\") == \"Itsourpathtoseethingsdothings11121314151617\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_61_count_Substrings", "language": "swift", "prompt": "\n/// Write a python function to count the number of substrings with the sum of digits equal to their length.\nfunc count_Substrings(s: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_61_count_Substrings.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_Substrings(s: \"112112\") == 6)\nassert(count_Substrings(s: \"111\") == 6)\nassert(count_Substrings(s: \"1101112\") == 12)", "stop_tokens": ["\n}"]}
{"name": "mbpp_622_get_median", "language": "swift", "prompt": "\n/// Write a function to find the median of two sorted lists of same size.\nfunc get_median(arr1: [Int], arr2: [Int], n: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_622_get_median.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_median(arr1: [1, 12, 15, 26, 38], arr2: [2, 13, 17, 30, 45], n: 5) == 16.0)\nassert(get_median(arr1: [2, 4, 8, 9], arr2: [7, 13, 19, 28], n: 4) == 8.5)\nassert(get_median(arr1: [3, 6, 14, 23, 36, 42], arr2: [2, 18, 27, 39, 49, 55], n: 6) == 25.0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_623_nth_nums", "language": "swift", "prompt": "\n/// Write a function to compute the n-th power of each number in a list.\nfunc nth_nums(nums: [Int], n: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_623_nth_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(nth_nums(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], n: 2) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100])\nassert(nth_nums(nums: [10, 20, 30], n: 3) == [1000, 8000, 27000])\nassert(nth_nums(nums: [12, 15], n: 5) == [248832, 759375])", "stop_tokens": ["\n}"]}
{"name": "mbpp_624_is_upper", "language": "swift", "prompt": "\n/// Write a python function to convert a given string to uppercase.\nfunc is_upper(string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_624_is_upper.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_upper(string: \"person\") == \"PERSON\")\nassert(is_upper(string: \"final\") == \"FINAL\")\nassert(is_upper(string: \"Valid\") == \"VALID\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_625_swap_List", "language": "swift", "prompt": "\n/// Write a python function to interchange the first and last element in a given list.\nfunc swap_List(newList: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_625_swap_List.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(swap_List(newList: [1, 2, 3]) == [3, 2, 1])\nassert(swap_List(newList: [1, 2, 3, 4, 4]) == [4, 2, 3, 4, 1])\nassert(swap_List(newList: [4, 5, 6]) == [6, 5, 4])", "stop_tokens": ["\n}"]}
{"name": "mbpp_626_triangle_area", "language": "swift", "prompt": "\n/// Write a python function to find the area of the largest triangle that can be inscribed in a semicircle with a given radius.\nfunc triangle_area(r: Int) -> Int? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_626_triangle_area.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(triangle_area(r: -1) == nil)\nassert(triangle_area(r: 0) == 0)\nassert(triangle_area(r: 2) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_627_find_First_Missing", "language": "swift", "prompt": "\n/// Write a python function to find the smallest missing number from a sorted list of natural numbers.\nfunc find_First_Missing(array: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_627_find_First_Missing.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_First_Missing(array: [0, 1, 2, 3]) == 4)\nassert(find_First_Missing(array: [0, 1, 2, 6, 9]) == 3)\nassert(find_First_Missing(array: [2, 3, 5, 8, 9]) == 0)", "stop_tokens": ["\n}"]}
{"name": "mbpp_628_replace_spaces", "language": "swift", "prompt": "\n/// Write a function to replace all spaces in the given string with '%20'.\nfunc replace_spaces(string: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_628_replace_spaces.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_spaces(string: \"My Name is Dawood\") == \"My%20Name%20is%20Dawood\")\nassert(replace_spaces(string: \"I am a Programmer\") == \"I%20am%20a%20Programmer\")\nassert(replace_spaces(string: \"I love Coding\") == \"I%20love%20Coding\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_629_Split", "language": "swift", "prompt": "\n/// Write a python function to find even numbers from a list of numbers.\nfunc Split(list: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_629_Split.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Split(list: [1, 2, 3, 4, 5]) == [2, 4])\nassert(Split(list: [4, 5, 6, 7, 8, 0, 1]) == [4, 6, 8, 0])\nassert(Split(list: [8, 12, 15, 19]) == [8, 12])", "stop_tokens": ["\n}"]}
{"name": "mbpp_62_smallest_num", "language": "swift", "prompt": "\n/// Write a python function to find smallest number in a list.\nfunc smallest_num(xs: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_62_smallest_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(smallest_num(xs: [10, 20, 1, 45, 99]) == 1)\nassert(smallest_num(xs: [1, 2, 3]) == 1)\nassert(smallest_num(xs: [45, 46, 50, 60]) == 45)", "stop_tokens": ["\n}"]}
{"name": "mbpp_630_get_coordinates", "language": "swift", "prompt": "\n/// Write a function to extract all the adjacent coordinates of the given coordinate tuple.\nfunc get_coordinates(test_tup: (Int, Int)) -> [[Int]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_630_get_coordinates.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_coordinates(test_tup: (3, 4)) == [[2, 3], [2, 4], [2, 5], [3, 3], [3, 4], [3, 5], [4, 3], [4, 4], [4, 5]])\nassert(get_coordinates(test_tup: (4, 5)) == [[3, 4], [3, 5], [3, 6], [4, 4], [4, 5], [4, 6], [5, 4], [5, 5], [5, 6]])\nassert(get_coordinates(test_tup: (5, 6)) == [[4, 5], [4, 6], [4, 7], [5, 5], [5, 6], [5, 7], [6, 5], [6, 6], [6, 7]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_631_replace_spaces", "language": "swift", "prompt": "\n/// Write a function to replace whitespaces with an underscore and vice versa in a given string.\nfunc replace_spaces(text: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_631_replace_spaces.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_spaces(text: \"Jumanji The Jungle\") == \"Jumanji_The_Jungle\")\nassert(replace_spaces(text: \"The_Avengers\") == \"The Avengers\")\nassert(replace_spaces(text: \"Fast and Furious\") == \"Fast_and_Furious\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_632_move_zero", "language": "swift", "prompt": "\n/// Write a python function to move all zeroes to the end of the given list.\nfunc move_zero(num_list: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_632_move_zero.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(move_zero(num_list: [1, 0, 2, 0, 3, 4]) == [1, 2, 3, 4, 0, 0])\nassert(move_zero(num_list: [2, 3, 2, 0, 0, 4, 0, 5, 0]) == [2, 3, 2, 4, 5, 0, 0, 0, 0])\nassert(move_zero(num_list: [0, 1, 0, 1, 1]) == [1, 1, 1, 0, 0])", "stop_tokens": ["\n}"]}
{"name": "mbpp_633_pair_xor_Sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of xor of all pairs of numbers in the given list.\nfunc pair_xor_Sum(arr: [Int], n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_633_pair_xor_Sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pair_xor_Sum(arr: [5, 9, 7, 6], n: 4) == 47)\nassert(pair_xor_Sum(arr: [7, 3, 5], n: 3) == 12)\nassert(pair_xor_Sum(arr: [7, 3], n: 2) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_635_heap_sort", "language": "swift", "prompt": "\n/// Write a function to sort the given list.\nfunc heap_sort(iterable: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_635_heap_sort.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(heap_sort(iterable: [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nassert(heap_sort(iterable: [25, 35, 22, 85, 14, 65, 75, 25, 58]) == [14, 22, 25, 25, 35, 58, 65, 75, 85])\nassert(heap_sort(iterable: [7, 1, 9, 5]) == [1, 5, 7, 9])", "stop_tokens": ["\n}"]}
{"name": "mbpp_637_noprofit_noloss", "language": "swift", "prompt": "\n/// Write a function to check whether the given amount has no profit and no loss\nfunc noprofit_noloss(actual_cost: Int, sale_amount: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_637_noprofit_noloss.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(noprofit_noloss(actual_cost: 1500, sale_amount: 1200) == false)\nassert(noprofit_noloss(actual_cost: 100, sale_amount: 100) == true)\nassert(noprofit_noloss(actual_cost: 2000, sale_amount: 5000) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_638_wind_chill", "language": "swift", "prompt": "\n/// Write a function to calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\nfunc wind_chill(v: Int, t: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_638_wind_chill.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(wind_chill(v: 120, t: 35) == 40)\nassert(wind_chill(v: 40, t: 20) == 19)\nassert(wind_chill(v: 10, t: 8) == 6)", "stop_tokens": ["\n}"]}
{"name": "mbpp_639_sample_nam", "language": "swift", "prompt": "\n/// Write a function to sum the length of the names of a given list of names after removing the names that start with a lowercase letter.\nfunc sample_nam(sample_names: [String]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_639_sample_nam.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sample_nam(sample_names: [\"sally\", \"Dylan\", \"rebecca\", \"Diana\", \"Joanne\", \"keith\"]) == 16)\nassert(sample_nam(sample_names: [\"php\", \"res\", \"Python\", \"abcd\", \"Java\", \"aaa\"]) == 10)\nassert(sample_nam(sample_names: [\"abcd\", \"Python\", \"abba\", \"aba\"]) == 6)", "stop_tokens": ["\n}"]}
{"name": "mbpp_63_max_difference", "language": "swift", "prompt": "\n/// Write a function to find the maximum difference between available pairs in the given tuple list.\nfunc max_difference(test_list: [(Int, Int)]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_63_max_difference.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_difference(test_list: [(3, 5), (1, 7), (10, 3), (1, 2)]) == 7)\nassert(max_difference(test_list: [(4, 6), (2, 17), (9, 13), (11, 12)]) == 15)\nassert(max_difference(test_list: [(12, 35), (21, 27), (13, 23), (41, 22)]) == 23)", "stop_tokens": ["\n}"]}
{"name": "mbpp_640_remove_parenthesis", "language": "swift", "prompt": "\n/// Write a function to remove the parenthesis and what is inbetween them from a string.\nfunc remove_parenthesis(items: [String]) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_640_remove_parenthesis.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_parenthesis(items: [\"python (chrome)\"]) == \"python\")\nassert(remove_parenthesis(items: [\"string(.abc)\"]) == \"string\")\nassert(remove_parenthesis(items: [\"alpha(num)\"]) == \"alpha\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_641_is_nonagonal", "language": "swift", "prompt": "\n/// Write a function to find the nth nonagonal number.\nfunc is_nonagonal(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_641_is_nonagonal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_nonagonal(n: 10) == 325)\nassert(is_nonagonal(n: 15) == 750)\nassert(is_nonagonal(n: 18) == 1089)", "stop_tokens": ["\n}"]}
{"name": "mbpp_643_text_match_wordz_middle", "language": "swift", "prompt": "\n/// Write a function that checks if a strings contains 'z', except at the start and end of the word.\nfunc text_match_wordz_middle(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_643_text_match_wordz_middle.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_wordz_middle(text: \"pythonzabc.\") == true)\nassert(text_match_wordz_middle(text: \"zxyabc.\") == false)\nassert(text_match_wordz_middle(text: \"  lang  .\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_644_reverse_Array_Upto_K", "language": "swift", "prompt": "\n/// Write a python function to reverse an array upto a given position.\nfunc reverse_Array_Upto_K(input: [Int], k: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_644_reverse_Array_Upto_K.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(reverse_Array_Upto_K(input: [1, 2, 3, 4, 5, 6], k: 4) == [4, 3, 2, 1, 5, 6])\nassert(reverse_Array_Upto_K(input: [4, 5, 6, 7], k: 2) == [5, 4, 6, 7])\nassert(reverse_Array_Upto_K(input: [9, 8, 7, 6, 5], k: 3) == [7, 8, 9, 6, 5])", "stop_tokens": ["\n}"]}
{"name": "mbpp_64_subject_marks", "language": "swift", "prompt": "\n/// Write a function to sort a list of tuples using the second value of each tuple.\nfunc subject_marks(subjectmarks: [(String, Int)]) -> [(String, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_64_subject_marks.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(subject_marks(subjectmarks: [(\"English\", 88), (\"Science\", 90), (\"Maths\", 97), (\"Social sciences\", 82)]) == [(\"Social sciences\", 82), (\"English\", 88), (\"Science\", 90), (\"Maths\", 97)])\nassert(subject_marks(subjectmarks: [(\"Telugu\", 49), (\"Hindhi\", 54), (\"Social\", 33)]) == [(\"Social\", 33), (\"Telugu\", 49), (\"Hindhi\", 54)])\nassert(subject_marks(subjectmarks: [(\"Physics\", 96), (\"Chemistry\", 97), (\"Biology\", 45)]) == [(\"Biology\", 45), (\"Physics\", 96), (\"Chemistry\", 97)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_65_recursive_list_sum", "language": "swift", "prompt": "\nextension [Int]: Error {}\n        \n/// Write a function to flatten a list and sum all of its elements.\nfunc recursive_list_sum(data_list: [Result<Int, [Int]>]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_65_recursive_list_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(recursive_list_sum(data_list: [.success(1), .success(2), .failure([3, 4]), .failure([5, 6])]) == 21)\nassert(recursive_list_sum(data_list: [.success(7), .success(10), .failure([15, 14]), .failure([19, 41])]) == 106)\nassert(recursive_list_sum(data_list: [.success(10), .success(20), .failure([30, 40]), .failure([50, 60])]) == 210)", "stop_tokens": ["\n}"]}
{"name": "mbpp_66_pos_count", "language": "swift", "prompt": "\n/// Write a python function to count the number of positive numbers in a list.\nfunc pos_count(list: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_66_pos_count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pos_count(list: [1, -2, 3, -4]) == 2)\nassert(pos_count(list: [3, 4, 5, -1]) == 3)\nassert(pos_count(list: [1, 2, 3, 4]) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_67_bell_number", "language": "swift", "prompt": "\n/// Write a function to find the number of ways to partition a set of Bell numbers.\nfunc bell_number(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_67_bell_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(bell_number(n: 2) == 2)\nassert(bell_number(n: 10) == 115975)\nassert(bell_number(n: 56) == 6775685320645824322581483068371419745979053216268760300)", "stop_tokens": ["\n}"]}
{"name": "mbpp_68_is_Monotonic", "language": "swift", "prompt": "\n/// Write a python function to check whether the given array is monotonic or not.\nfunc is_Monotonic(A: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_68_is_Monotonic.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_Monotonic(A: [6, 5, 4, 4]) == true)\nassert(is_Monotonic(A: [1, 2, 2, 3]) == true)\nassert(is_Monotonic(A: [1, 3, 2]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_69_is_sublist", "language": "swift", "prompt": "\n/// Write a function to check whether a list contains the given sublist or not.\nfunc is_sublist(l: [Int], s: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_69_is_sublist.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_sublist(l: [2, 4, 3, 5, 7], s: [3, 7]) == false)\nassert(is_sublist(l: [2, 4, 3, 5, 7], s: [4, 3]) == true)\nassert(is_sublist(l: [2, 4, 3, 5, 7], s: [1, 6]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_6_differ_At_One_Bit_Pos", "language": "swift", "prompt": "\n/// Write a python function to check whether the two numbers differ at one bit position only or not.\nfunc differ_At_One_Bit_Pos(a: Int, b: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_6_differ_At_One_Bit_Pos.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(differ_At_One_Bit_Pos(a: 13, b: 9) == true)\nassert(differ_At_One_Bit_Pos(a: 15, b: 8) == false)\nassert(differ_At_One_Bit_Pos(a: 2, b: 4) == false)\nassert(differ_At_One_Bit_Pos(a: 2, b: 3) == true)\nassert(differ_At_One_Bit_Pos(a: 5, b: 1) == true)\nassert(differ_At_One_Bit_Pos(a: 1, b: 5) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_70_get_equal", "language": "swift", "prompt": "\n/// Write a function to find whether all the given lists have equal length or not.\nfunc get_equal(Input: [[Int]]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_70_get_equal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_equal(Input: [[11, 22, 33], [44, 55, 66]]) == true)\nassert(get_equal(Input: [[1, 2, 3], [4, 5, 6, 7]]) == false)\nassert(get_equal(Input: [[1, 2], [3, 4]]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_71_comb_sort", "language": "swift", "prompt": "\n/// Write a function to sort a list of elements.\nfunc comb_sort(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_71_comb_sort.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(comb_sort(nums: [5, 15, 37, 25, 79]) == [5, 15, 25, 37, 79])\nassert(comb_sort(nums: [41, 32, 15, 19, 22]) == [15, 19, 22, 32, 41])\nassert(comb_sort(nums: [99, 15, 13, 47]) == [13, 15, 47, 99])", "stop_tokens": ["\n}"]}
{"name": "mbpp_720_add_dict_to_tuple", "language": "swift", "prompt": "\n/// Write a function to add a dictionary to the tuple. The output should be a tuple.\nfunc add_dict_to_tuple(test_tup: (Int, Int, Int), test_dict: [String : Int]) -> (Int, Int, Int, [String : Int]) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_720_add_dict_to_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_dict_to_tuple(test_tup: (4, 5, 6), test_dict: [\"MSAM\" : 1, \"is\" : 2, \"best\" : 3]) == (4, 5, 6, [\"MSAM\" : 1, \"is\" : 2, \"best\" : 3]))\nassert(add_dict_to_tuple(test_tup: (1, 2, 3), test_dict: [\"UTS\" : 2, \"is\" : 3, \"Worst\" : 4]) == (1, 2, 3, [\"UTS\" : 2, \"is\" : 3, \"Worst\" : 4]))\nassert(add_dict_to_tuple(test_tup: (8, 9, 10), test_dict: [\"POS\" : 3, \"is\" : 4, \"Okay\" : 5]) == (8, 9, 10, [\"POS\" : 3, \"is\" : 4, \"Okay\" : 5]))", "stop_tokens": ["\n}"]}
{"name": "mbpp_721_maxAverageOfPath", "language": "swift", "prompt": "\n/// Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\nfunc maxAverageOfPath(cost: [[Int]]) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(maxAverageOfPath(cost: [[1, 2, 3], [6, 5, 4], [7, 3, 9]]) == 5.2)\nassert(maxAverageOfPath(cost: [[2, 3, 4], [7, 6, 5], [8, 4, 10]]) == 6.2)\nassert(maxAverageOfPath(cost: [[3, 4, 5], [8, 7, 6], [9, 5, 11]]) == 7.2)\nassert(maxAverageOfPath(cost: [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 5.8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_722_filter_data", "language": "swift", "prompt": "\n/// The input is given as - a dictionary with a student name as a key and a tuple of float (student_height, student_weight) as a value, - minimal height, - minimal weight. Write a function to filter students that have height and weight above the minimum.\nfunc filter_data(students: [String : (Double, Int)], h: Double, w: Int) -> [String : (Double, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_722_filter_data.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(filter_data(students: [\"Cierra Vega\" : (6.2, 70), \"Alden Cantrell\" : (5.9, 65), \"Kierra Gentry\" : (6.0, 68), \"Pierre Cox\" : (5.8, 66)], h: 6.0, w: 70) == [\"Cierra Vega\" : (6.2, 70)])\nassert(filter_data(students: [\"Cierra Vega\" : (6.2, 70), \"Alden Cantrell\" : (5.9, 65), \"Kierra Gentry\" : (6.0, 68), \"Pierre Cox\" : (5.8, 66)], h: 5.9, w: 67) == [\"Cierra Vega\" : (6.2, 70), \"Kierra Gentry\" : (6.0, 68)])\nassert(filter_data(students: [\"Cierra Vega\" : (6.2, 70), \"Alden Cantrell\" : (5.9, 65), \"Kierra Gentry\" : (6.0, 68), \"Pierre Cox\" : (5.8, 66)], h: 5.7, w: 64) == [\"Cierra Vega\" : (6.2, 70), \"Alden Cantrell\" : (5.9, 65), \"Kierra Gentry\" : (6.0, 68), \"Pierre Cox\" : (5.8, 66)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_723_count_same_pair", "language": "swift", "prompt": "\n/// The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\nfunc count_same_pair(nums1: [Int], nums2: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_723_count_same_pair.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_same_pair(nums1: [1, 2, 3, 4, 5, 6, 7, 8], nums2: [2, 2, 3, 1, 2, 6, 7, 9]) == 4)\nassert(count_same_pair(nums1: [0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8], nums2: [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 11)\nassert(count_same_pair(nums1: [2, 4, -6, -9, 11, -12, 14, -5, 17], nums2: [2, 1, 2, -1, -5, 6, 4, -3, -2, 3, 4, 6, 8]) == 1)\nassert(count_same_pair(nums1: [0, 1, 1, 2], nums2: [0, 1, 2, 2]) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_724_power_base_sum", "language": "swift", "prompt": "\n/// Write a function that takes base and power as arguments and calculate the sum of all digits of the base to the specified power.\nfunc power_base_sum(base: Int, power: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_724_power_base_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(power_base_sum(base: 2, power: 100) == 115)\nassert(power_base_sum(base: 8, power: 10) == 37)\nassert(power_base_sum(base: 8, power: 15) == 62)\nassert(power_base_sum(base: 3, power: 3) == 9)", "stop_tokens": ["\n}"]}
{"name": "mbpp_725_extract_quotation", "language": "swift", "prompt": "\n/// Write a function to extract values between quotation marks \" \" of the given string.\nfunc extract_quotation(text1: String) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_725_extract_quotation.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_quotation(text1: \"Cortex \\\"A53\\\" Based \\\"multi\\\" tasking \\\"Processor\\\"\") == [\"A53\", \"multi\", \"Processor\"])\nassert(extract_quotation(text1: \"Cast your \\\"favorite\\\" entertainment \\\"apps\\\"\") == [\"favorite\", \"apps\"])\nassert(extract_quotation(text1: \"Watch content \\\"4k Ultra HD\\\" resolution with \\\"HDR 10\\\" Support\") == [\"4k Ultra HD\", \"HDR 10\"])\nassert(extract_quotation(text1: \"Watch content '4k Ultra HD' resolution with 'HDR 10' Support\") == [] as [AnyHashable])", "stop_tokens": ["\n}"]}
{"name": "mbpp_726_multiply_elements", "language": "swift", "prompt": "\n/// Write a function that takes as input a list of numbers (t_1,...,t_{N+1}) and returns a list of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\nfunc multiply_elements(test_tup: [Int]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_726_multiply_elements.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(multiply_elements(test_tup: [1, 5, 7, 8, 10]) == [5, 35, 56, 80])\nassert(multiply_elements(test_tup: [2, 4, 5, 6, 7]) == [8, 20, 30, 42])\nassert(multiply_elements(test_tup: [12, 13, 14, 9, 15]) == [156, 182, 126, 135])\nassert(multiply_elements(test_tup: [12]) == [] as [AnyHashable])", "stop_tokens": ["\n}"]}
{"name": "mbpp_728_sum_list", "language": "swift", "prompt": "\n/// Write a function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\nfunc sum_list(lst1: [Int], lst2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_728_sum_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_list(lst1: [10, 20, 30], lst2: [15, 25, 35]) == [25, 45, 65])\nassert(sum_list(lst1: [1, 2, 3], lst2: [5, 6, 7]) == [6, 8, 10])\nassert(sum_list(lst1: [15, 20, 30], lst2: [15, 45, 75]) == [30, 65, 105])", "stop_tokens": ["\n}"]}
{"name": "mbpp_72_dif_Square", "language": "swift", "prompt": "\n/// Write a python function to check whether the given number can be represented as the difference of two squares or not.\nfunc dif_Square(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_72_dif_Square.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(dif_Square(n: 5) == true)\nassert(dif_Square(n: 10) == false)\nassert(dif_Square(n: 15) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_730_consecutive_duplicates", "language": "swift", "prompt": "\n/// Write a function to remove consecutive duplicates of a given list.\nfunc consecutive_duplicates(nums: [AnyHashable]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_730_consecutive_duplicates.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(consecutive_duplicates(nums: [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 4])\nassert(consecutive_duplicates(nums: [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [10, 15, 19, 18, 17, 26, 17, 18, 10])\nassert(consecutive_duplicates(nums: [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(consecutive_duplicates(nums: [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\", \"a\", \"a\"]) == [\"a\", \"b\", \"c\", \"d\", \"a\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_731_lateralsurface_cone", "language": "swift", "prompt": "\n/// Write a function to find the lateral surface area of a cone given radius r and the height h.\nfunc lateralsurface_cone(r: Int, h: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_731_lateralsurface_cone.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(lateralsurface_cone(r: 5, h: 12) == 204.20352248333654)\nassert(lateralsurface_cone(r: 10, h: 15) == 566.3586699569488)\nassert(lateralsurface_cone(r: 19, h: 17) == 1521.8090132193388)", "stop_tokens": ["\n}"]}
{"name": "mbpp_732_replace_specialchar", "language": "swift", "prompt": "\n/// Write a function to replace all occurrences of spaces, commas, or dots with a colon.\nfunc replace_specialchar(text: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_732_replace_specialchar.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(replace_specialchar(text: \"Python language, Programming language.\") == \"Python:language::Programming:language:\")\nassert(replace_specialchar(text: \"a b c,d e f\") == \"a:b:c:d:e:f\")\nassert(replace_specialchar(text: \"ram reshma,ram rahim\") == \"ram:reshma:ram:rahim\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_733_find_first_occurrence", "language": "swift", "prompt": "\n/// Write a function to find the index of the first occurrence of a given number in a sorted array.\nfunc find_first_occurrence(A: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_733_find_first_occurrence.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_first_occurrence(A: [2, 5, 5, 5, 6, 6, 8, 9, 9, 9], x: 5) == 1)\nassert(find_first_occurrence(A: [2, 3, 5, 5, 6, 6, 8, 9, 9, 9], x: 5) == 2)\nassert(find_first_occurrence(A: [2, 4, 1, 5, 6, 6, 8, 9, 9, 9], x: 6) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_734_sum_Of_Subarray_Prod", "language": "swift", "prompt": "\n/// Write a python function to find sum of products of all possible sublists of a given list. https://www.geeksforgeeks.org/sum-of-products-of-all-possible-subarrays/\nfunc sum_Of_Subarray_Prod(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_734_sum_Of_Subarray_Prod.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_Of_Subarray_Prod(arr: [1, 2, 3]) == 20)\nassert(sum_Of_Subarray_Prod(arr: [1, 2]) == 5)\nassert(sum_Of_Subarray_Prod(arr: [1, 2, 3, 4]) == 84)", "stop_tokens": ["\n}"]}
{"name": "mbpp_735_toggle_middle_bits", "language": "swift", "prompt": "\n/// Write a python function to toggle bits of the number except the first and the last bit. https://www.geeksforgeeks.org/toggle-bits-number-expect-first-last-bits/\nfunc toggle_middle_bits(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_735_toggle_middle_bits.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(toggle_middle_bits(n: 9) == 15)\nassert(toggle_middle_bits(n: 10) == 12)\nassert(toggle_middle_bits(n: 11) == 13)\nassert(toggle_middle_bits(n: 65) == 127)\nassert(toggle_middle_bits(n: 77) == 115)", "stop_tokens": ["\n}"]}
{"name": "mbpp_736_left_insertion", "language": "swift", "prompt": "\n/// Write a function to locate the left insertion point for a specified value in sorted order. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-data-structure-exercise-24.php\nfunc left_insertion(a: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_736_left_insertion.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(left_insertion(a: [1, 2, 4, 5], x: 6) == 4)\nassert(left_insertion(a: [1, 2, 4, 5], x: 3) == 2)\nassert(left_insertion(a: [1, 2, 4, 5], x: 7) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_737_check_str", "language": "swift", "prompt": "\n/// Write a function to check whether the given string is starting with a vowel or not using regex.\nfunc check_str(string: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_737_check_str.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_str(string: \"annie\") == true)\nassert(check_str(string: \"dawood\") == false)\nassert(check_str(string: \"Else\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_738_geometric_sum", "language": "swift", "prompt": "\n/// Write a function to calculate the geometric sum of n-1. https://www.w3resource.com/python-exercises/data-structures-and-algorithms/python-recursion-exercise-9.php\nfunc geometric_sum(n: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_738_geometric_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(geometric_sum(n: 7) == 1.9921875)\nassert(geometric_sum(n: 4) == 1.9375)\nassert(geometric_sum(n: 8) == 1.99609375)", "stop_tokens": ["\n}"]}
{"name": "mbpp_739_find_Index", "language": "swift", "prompt": "\n/// Write a python function to find the index of smallest triangular number with n digits. https://www.geeksforgeeks.org/index-of-smallest-triangular-number-with-n-digits/\nfunc find_Index(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_739_find_Index.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Index(n: 2) == 4)\nassert(find_Index(n: 3) == 14)\nassert(find_Index(n: 4) == 45)", "stop_tokens": ["\n}"]}
{"name": "mbpp_740_tuple_to_dict", "language": "swift", "prompt": "\n/// Write a function to convert the given tuple to a key-value dictionary using adjacent elements. https://www.geeksforgeeks.org/python-convert-tuple-to-adjacent-pair-dictionary/\nfunc tuple_to_dict(test_tup: (Int, Int, Int, Int, Int, Int)) -> [Int : Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_740_tuple_to_dict.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tuple_to_dict(test_tup: (1, 5, 7, 10, 13, 5)) == [1 : 5, 7 : 10, 13 : 5])\nassert(tuple_to_dict(test_tup: (1, 2, 3, 4, 5, 6)) == [1 : 2, 3 : 4, 5 : 6])\nassert(tuple_to_dict(test_tup: (7, 8, 9, 10, 11, 12)) == [7 : 8, 9 : 10, 11 : 12])", "stop_tokens": ["\n}"]}
{"name": "mbpp_741_all_Characters_Same", "language": "swift", "prompt": "\n/// Write a python function to check whether all the characters are same or not.\nfunc all_Characters_Same(s: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_741_all_Characters_Same.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(all_Characters_Same(s: \"python\") == false)\nassert(all_Characters_Same(s: \"aaa\") == true)\nassert(all_Characters_Same(s: \"data\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_742_area_tetrahedron", "language": "swift", "prompt": "\n/// Write a function to caluclate the area of a tetrahedron.\nfunc area_tetrahedron(side: Int) -> Double {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_742_area_tetrahedron.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(area_tetrahedron(side: 3) == 15.588457268119894)\nassert(area_tetrahedron(side: 20) == 692.8203230275509)\nassert(area_tetrahedron(side: 10) == 173.20508075688772)", "stop_tokens": ["\n}"]}
{"name": "mbpp_743_rotate_right", "language": "swift", "prompt": "\n/// Write a function to rotate a given list by specified number of items to the right direction. https://www.geeksforgeeks.org/python-program-right-rotate-list-n/\nfunc rotate_right(list: [Int], m: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_743_rotate_right.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rotate_right(list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m: 3) == [8, 9, 10, 1, 2, 3, 4, 5, 6, 7])\nassert(rotate_right(list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m: 2) == [9, 10, 1, 2, 3, 4, 5, 6, 7, 8])\nassert(rotate_right(list: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], m: 5) == [6, 7, 8, 9, 10, 1, 2, 3, 4, 5])", "stop_tokens": ["\n}"]}
{"name": "mbpp_744_check_none", "language": "swift", "prompt": "\n/// Write a function to check if the given tuple has any none value or not.\nfunc check_none(test_tup: AnyHashable) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_744_check_none.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_none(test_tup: (7, 8, 9, 11, 14)) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_745_divisible_by_digits", "language": "swift", "prompt": "\n/// Write a function to find numbers within a given range from startnum ti endnum where every number is divisible by every digit it contains. https://www.w3resource.com/python-exercises/lambda/python-lambda-exercise-24.php\nfunc divisible_by_digits(startnum: Int, endnum: Int) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_745_divisible_by_digits.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(divisible_by_digits(startnum: 1, endnum: 22) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22])\nassert(divisible_by_digits(startnum: 1, endnum: 15) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15])\nassert(divisible_by_digits(startnum: 20, endnum: 25) == [22, 24])", "stop_tokens": ["\n}"]}
{"name": "mbpp_746_sector_area", "language": "swift", "prompt": "\n/// Write a function to find area of a sector. The function takes the radius and angle as inputs. Function should return None if the angle is larger than 360 degrees.\nfunc sector_area(r: Int, a: Int) -> Double? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_746_sector_area.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sector_area(r: 4, a: 45) == 6.283185307179586)\nassert(sector_area(r: 9, a: 45) == 31.808625617596654)\nassert(sector_area(r: 9, a: 361) == nil)", "stop_tokens": ["\n}"]}
{"name": "mbpp_747_lcs_of_three", "language": "swift", "prompt": "\n/// Write a function to find the longest common subsequence for the given three string sequence. https://www.geeksforgeeks.org/lcs-longest-common-subsequence-three-strings/\nfunc lcs_of_three(X: String, Y: String, Z: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_747_lcs_of_three.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(lcs_of_three(X: \"AGGT12\", Y: \"12TXAYB\", Z: \"12XBA\") == 2)\nassert(lcs_of_three(X: \"Reels\", Y: \"Reelsfor\", Z: \"ReelsforReels\") == 5)\nassert(lcs_of_three(X: \"abcd1e2\", Y: \"bc12ea\", Z: \"bd1ea\") == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_748_capital_words_spaces", "language": "swift", "prompt": "\n/// Write a function to put spaces between words starting with capital letters in a given string.\nfunc capital_words_spaces(str1: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_748_capital_words_spaces.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(capital_words_spaces(str1: \"Python\") == \"Python\")\nassert(capital_words_spaces(str1: \"PythonProgrammingExamples\") == \"Python Programming Examples\")\nassert(capital_words_spaces(str1: \"GetReadyToBeCodingFreak\") == \"Get Ready To Be Coding Freak\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_749_sort_numeric_strings", "language": "swift", "prompt": "\n/// Write a function to sort a given list of strings of numbers numerically. https://www.geeksforgeeks.org/python-sort-numeric-strings-in-a-list/\nfunc sort_numeric_strings(nums_str: [String]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_749_sort_numeric_strings.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sort_numeric_strings(nums_str: [\"4\", \"12\", \"45\", \"7\", \"0\", \"100\", \"200\", \"-12\", \"-500\"]) == [-500, -12, 0, 4, 7, 12, 45, 100, 200])\nassert(sort_numeric_strings(nums_str: [\"2\", \"3\", \"8\", \"4\", \"7\", \"9\", \"8\", \"2\", \"6\", \"5\", \"1\", \"6\", \"1\", \"2\", \"3\", \"4\", \"6\", \"9\", \"1\", \"2\"]) == [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9])\nassert(sort_numeric_strings(nums_str: [\"1\", \"3\", \"5\", \"7\", \"1\", \"3\", \"13\", \"15\", \"17\", \"5\", \"7 \", \"9\", \"1\", \"11\"]) == [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17])", "stop_tokens": ["\n}"]}
{"name": "mbpp_74_is_samepatterns", "language": "swift", "prompt": "\n/// Write a function to check whether it follows the sequence given in the patterns array.\nfunc is_samepatterns(colors: [String], patterns: [String]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_74_is_samepatterns.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_samepatterns(colors: [\"red\", \"green\", \"green\"], patterns: [\"a\", \"b\", \"b\"]) == true)\nassert(is_samepatterns(colors: [\"red\", \"green\", \"greenn\"], patterns: [\"a\", \"b\", \"b\"]) == false)\nassert(is_samepatterns(colors: [\"red\", \"green\", \"greenn\"], patterns: [\"a\", \"b\"]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_750_add_tuple", "language": "swift", "prompt": "\n/// Write a function to add the given tuple to the given list.\nfunc add_tuple(test_list: [Int], test_tup: (Int, Int)) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_750_add_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(add_tuple(test_list: [5, 6, 7], test_tup: (9, 10)) == [5, 6, 7, 9, 10])\nassert(add_tuple(test_list: [6, 7, 8], test_tup: (10, 11)) == [6, 7, 8, 10, 11])\nassert(add_tuple(test_list: [7, 8, 9], test_tup: (11, 12)) == [7, 8, 9, 11, 12])", "stop_tokens": ["\n}"]}
{"name": "mbpp_751_check_min_heap", "language": "swift", "prompt": "\n/// Write a function to check if the given array represents min heap or not. https://www.geeksforgeeks.org/how-to-check-if-a-given-array-represents-a-binary-heap/\nfunc check_min_heap(arr: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_751_check_min_heap.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_min_heap(arr: [1, 2, 3, 4, 5, 6]) == true)\nassert(check_min_heap(arr: [2, 3, 4, 5, 10, 15]) == true)\nassert(check_min_heap(arr: [2, 10, 4, 5, 3, 15]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_752_jacobsthal_num", "language": "swift", "prompt": "\n/// Write a function to find the nth jacobsthal number. https://www.geeksforgeeks.org/jacobsthal-and-jacobsthal-lucas-numbers/ 0, 1, 1, 3, 5, 11, 21, 43, 85, 171, 341, 683, 1365, 2731, ...\nfunc jacobsthal_num(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_752_jacobsthal_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(jacobsthal_num(n: 5) == 11)\nassert(jacobsthal_num(n: 2) == 1)\nassert(jacobsthal_num(n: 4) == 5)\nassert(jacobsthal_num(n: 13) == 2731)", "stop_tokens": ["\n}"]}
{"name": "mbpp_753_min_k", "language": "swift", "prompt": "\n/// Write a function to find minimum k records from tuple list. https://www.geeksforgeeks.org/python-find-minimum-k-records-from-tuple-list/ - in this case a verbatim copy of test cases\nfunc min_k(test_list: [(String, Int)], K: Int) -> [(String, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_753_min_k.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(min_k(test_list: [(\"Manjeet\", 10), (\"Akshat\", 4), (\"Akash\", 2), (\"Nikhil\", 8)], K: 2) == [(\"Akash\", 2), (\"Akshat\", 4)])\nassert(min_k(test_list: [(\"Sanjeev\", 11), (\"Angat\", 5), (\"Akash\", 3), (\"Nepin\", 9)], K: 3) == [(\"Akash\", 3), (\"Angat\", 5), (\"Nepin\", 9)])\nassert(min_k(test_list: [(\"tanmay\", 14), (\"Amer\", 11), (\"Ayesha\", 9), (\"SKD\", 16)], K: 1) == [(\"Ayesha\", 9)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_754_extract_index_list", "language": "swift", "prompt": "\n/// We say that an element is common for lists l1, l2, l3 if it appears in all three lists under the same index. Write a function to find common elements from three lists. The function should return a list.\nfunc extract_index_list(l1: [Int], l2: [Int], l3: [Int]) -> [AnyHashable] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_754_extract_index_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(extract_index_list(l1: [1, 1, 3, 4, 5, 6, 7], l2: [0, 1, 2, 3, 4, 5, 7], l3: [0, 1, 2, 3, 4, 5, 7]) == [1, 7])\nassert(extract_index_list(l1: [1, 1, 3, 4, 5, 6, 7], l2: [0, 1, 2, 3, 4, 6, 5], l3: [0, 1, 2, 3, 4, 6, 7]) == [1, 6])\nassert(extract_index_list(l1: [1, 1, 3, 4, 6, 5, 6], l2: [0, 1, 2, 3, 4, 5, 7], l3: [0, 1, 2, 3, 4, 5, 7]) == [1, 5])\nassert(extract_index_list(l1: [1, 2, 3, 4, 6, 6, 6], l2: [0, 1, 2, 3, 4, 5, 7], l3: [0, 1, 2, 3, 4, 5, 7]) == [] as [AnyHashable])", "stop_tokens": ["\n}"]}
{"name": "mbpp_755_second_smallest", "language": "swift", "prompt": "\nextension Double: Error {}\n        \n/// Write a function to find the second smallest number in a list.\nfunc second_smallest(numbers: [Result<Int, Double>]) -> Double? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_755_second_smallest.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(second_smallest(numbers: [.success(1), .success(2), .success(-8), .success(-2), .success(0), .success(-2)]) == -2)\nassert(second_smallest(numbers: [.success(1), .success(1), .failure(-0.5), .success(0), .success(2), .success(-2), .success(-2)]) == -0.5)\nassert(second_smallest(numbers: [.success(2), .success(2)]) == nil)\nassert(second_smallest(numbers: [.success(2), .success(2), .success(2)]) == nil)", "stop_tokens": ["\n}"]}
{"name": "mbpp_756_text_match_zero_one", "language": "swift", "prompt": "\n/// Write a function that matches a string that has an 'a' followed by one or more 'b's. https://www.w3resource.com/python-exercises/re/python-re-exercise-3.php\nfunc text_match_zero_one(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_756_text_match_zero_one.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_zero_one(text: \"ac\") == false)\nassert(text_match_zero_one(text: \"dc\") == false)\nassert(text_match_zero_one(text: \"abbbba\") == true)\nassert(text_match_zero_one(text: \"dsabbbba\") == true)\nassert(text_match_zero_one(text: \"asbbbba\") == false)\nassert(text_match_zero_one(text: \"abaaa\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_757_count_reverse_pairs", "language": "swift", "prompt": "\n/// Write a function to count the pairs of reverse strings in the given string list. https://www.geeksforgeeks.org/python-program-to-count-the-pairs-of-reverse-strings/\nfunc count_reverse_pairs(test_list: [String]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_757_count_reverse_pairs.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_reverse_pairs(test_list: [\"julia\", \"best\", \"tseb\", \"for\", \"ailuj\"]) == 2)\nassert(count_reverse_pairs(test_list: [\"geeks\", \"best\", \"for\", \"skeeg\"]) == 1)\nassert(count_reverse_pairs(test_list: [\"makes\", \"best\", \"sekam\", \"for\", \"rof\"]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_759_is_decimal", "language": "swift", "prompt": "\n/// Write a function to check whether a given string is a decimal number with a precision of 2.\nfunc is_decimal(num: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_759_is_decimal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_decimal(num: \"123.11\") == true)\nassert(is_decimal(num: \"e666.86\") == false)\nassert(is_decimal(num: \"3.124587\") == false)\nassert(is_decimal(num: \"1.11\") == true)\nassert(is_decimal(num: \"1.1.11\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_75_find_tuples", "language": "swift", "prompt": "\n/// Write a function to find tuples which have all elements divisible by k from the given list of tuples.\nfunc find_tuples(test_list: [(Int, Int, Int)], K: Int) -> [(Int, Int, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_75_find_tuples.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_tuples(test_list: [(6, 24, 12), (7, 9, 6), (12, 18, 21)], K: 6) == [(6, 24, 12)])\nassert(find_tuples(test_list: [(5, 25, 30), (4, 2, 3), (7, 8, 9)], K: 5) == [(5, 25, 30)])\nassert(find_tuples(test_list: [(7, 9, 16), (8, 16, 4), (19, 17, 18)], K: 4) == [(8, 16, 4)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_760_unique_Element", "language": "swift", "prompt": "\n/// Write a python function to check whether a list of numbers contains only one distinct element or not.\nfunc unique_Element(arr: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_760_unique_Element.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(unique_Element(arr: [1, 1, 1]) == true)\nassert(unique_Element(arr: [1, 2, 1, 2]) == false)\nassert(unique_Element(arr: [1, 2, 3, 4, 5]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_762_check_monthnumber_number", "language": "swift", "prompt": "\n/// Write a function to check whether the given month number contains 30 days or not. Months are given as number from 1 to 12.\nfunc check_monthnumber_number(monthnum3: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_762_check_monthnumber_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_monthnumber_number(monthnum3: 6) == true)\nassert(check_monthnumber_number(monthnum3: 2) == false)\nassert(check_monthnumber_number(monthnum3: 12) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_763_find_min_diff", "language": "swift", "prompt": "\n/// Write a python function to find the minimum difference between any two elements in a given array. https://www.geeksforgeeks.org/find-minimum-difference-pair/\nfunc find_min_diff(arr: [Int], n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_763_find_min_diff.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_min_diff(arr: [1, 5, 3, 19, 18, 25], n: 6) == 1)\nassert(find_min_diff(arr: [4, 3, 2, 6], n: 4) == 1)\nassert(find_min_diff(arr: [30, 5, 20, 9], n: 4) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_764_number_ctr", "language": "swift", "prompt": "\n/// Write a python function to count number of digits in a given string.\nfunc number_ctr(str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_764_number_ctr.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(number_ctr(str: \"program2bedone\") == 1)\nassert(number_ctr(str: \"3wonders\") == 1)\nassert(number_ctr(str: \"123\") == 3)\nassert(number_ctr(str: \"3wond-1ers2\") == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_765_is_polite", "language": "swift", "prompt": "\n/// Write a function to find nth polite number. geeksforgeeks.org/n-th-polite-number/\nfunc is_polite(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_765_is_polite.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_polite(n: 7) == 11)\nassert(is_polite(n: 4) == 7)\nassert(is_polite(n: 9) == 13)", "stop_tokens": ["\n}"]}
{"name": "mbpp_766_pair_wise", "language": "swift", "prompt": "\n/// Write a function to return a list of all pairs of consecutive items in a given list.\nfunc pair_wise(l1: [Int]) -> [(Int, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_766_pair_wise.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pair_wise(l1: [1, 1, 2, 3, 3, 4, 4, 5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)])\nassert(pair_wise(l1: [1, 5, 7, 9, 10]) == [(1, 5), (5, 7), (7, 9), (9, 10)])\nassert(pair_wise(l1: [5, 1, 9, 7, 10]) == [(5, 1), (1, 9), (9, 7), (7, 10)])\nassert(pair_wise(l1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_767_get_pairs_count", "language": "swift", "prompt": "\n/// Write a python function to count the number of pairs whose sum is equal to \u2018sum\u2019. The funtion gets as input a list of numbers and the sum,\nfunc get_pairs_count(arr: [Int], sum: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_767_get_pairs_count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_pairs_count(arr: [1, 1, 1, 1], sum: 2) == 6)\nassert(get_pairs_count(arr: [1, 5, 7, -1, 5], sum: 6) == 3)\nassert(get_pairs_count(arr: [1, -2, 3], sum: 1) == 1)\nassert(get_pairs_count(arr: [-1, -2, 3], sum: -3) == 1)", "stop_tokens": ["\n}"]}
{"name": "mbpp_769_Diff", "language": "swift", "prompt": "\n/// Write a python function to get the difference between two lists.\nfunc Diff(li1: [Int], li2: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_769_Diff.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Diff(li1: [10, 15, 20, 25, 30, 35, 40], li2: [25, 40, 35]) == [10, 20, 30, 15])\nassert(Diff(li1: [1, 2, 3, 4, 5], li2: [6, 7, 1]) == [2, 3, 4, 5, 6, 7])\nassert(Diff(li1: [1, 2, 3], li2: [6, 7, 1]) == [2, 3, 6, 7])", "stop_tokens": ["\n}"]}
{"name": "mbpp_770_odd_num_sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of fourth power of first n odd natural numbers.\nfunc odd_num_sum(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_770_odd_num_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_num_sum(n: 2) == 82)\nassert(odd_num_sum(n: 3) == 707)\nassert(odd_num_sum(n: 4) == 3108)", "stop_tokens": ["\n}"]}
{"name": "mbpp_771_check_expression", "language": "swift", "prompt": "\n/// Write a function to check if the given expression is balanced or not. https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/\nfunc check_expression(exp: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_771_check_expression.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_expression(exp: \"{()}[{}]\") == true)\nassert(check_expression(exp: \"{()}[{]\") == false)\nassert(check_expression(exp: \"{()}[{}][]({})\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_772_remove_length", "language": "swift", "prompt": "\n/// Write a function to remove all the words with k length in the given string.\nfunc remove_length(test_str: String, K: Int) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_772_remove_length.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_length(test_str: \"The person is most value tet\", K: 3) == \"person is most value\")\nassert(remove_length(test_str: \"If you told me about this ok\", K: 4) == \"If you me about ok\")\nassert(remove_length(test_str: \"Forces of darkeness is come into the play\", K: 4) == \"Forces of darkeness is the\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_773_occurance_substring", "language": "swift", "prompt": "\n/// Write a function to find the occurrence and position of the substrings within a string. Return None if there is no match.\nfunc occurance_substring(text: String, pattern: String) -> (String, Int, Int)? {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_773_occurance_substring.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(occurance_substring(text: \"python programming, python language\", pattern: \"python\") == (\"python\", 0, 6))\nassert(occurance_substring(text: \"python programming,programming language\", pattern: \"programming\") == (\"programming\", 7, 18))\nassert(occurance_substring(text: \"python programming,programming language\", pattern: \"language\") == (\"language\", 31, 39))\nassert(occurance_substring(text: \"c++ programming, c++ language\", pattern: \"python\") == nil)", "stop_tokens": ["\n}"]}
{"name": "mbpp_775_odd_position", "language": "swift", "prompt": "\n/// Write a python function to check whether every odd index contains odd numbers of a given list.\nfunc odd_position(nums: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_775_odd_position.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_position(nums: [2, 1, 4, 3, 6, 7, 6, 3]) == true)\nassert(odd_position(nums: [4, 1, 2]) == true)\nassert(odd_position(nums: [1, 2, 3]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_776_count_vowels", "language": "swift", "prompt": "\n/// Write a function to count those characters which have vowels as their neighbors in the given string.\nfunc count_vowels(test_str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_776_count_vowels.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_vowels(test_str: \"bestinstareels\") == 7)\nassert(count_vowels(test_str: \"partofthejourneyistheend\") == 12)\nassert(count_vowels(test_str: \"amazonprime\") == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_777_find_sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of non-repeated elements in a given list.\nfunc find_sum(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_777_find_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_sum(arr: [1, 2, 3, 1, 1, 4, 5, 6]) == 21)\nassert(find_sum(arr: [1, 10, 9, 4, 2, 10, 10, 45, 4]) == 71)\nassert(find_sum(arr: [12, 10, 9, 45, 2, 10, 10, 45, 10]) == 78)", "stop_tokens": ["\n}"]}
{"name": "mbpp_778_pack_consecutive_duplicates", "language": "swift", "prompt": "\n/// Write a function to pack consecutive duplicates of a given list elements into sublists.\nfunc pack_consecutive_duplicates(list1: [AnyHashable]) -> [[AnyHashable]] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_778_pack_consecutive_duplicates.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(pack_consecutive_duplicates(list1: [0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]) == [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]])\nassert(pack_consecutive_duplicates(list1: [10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10]) == [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]])\nassert(pack_consecutive_duplicates(list1: [\"a\", \"a\", \"b\", \"c\", \"d\", \"d\"]) == [[\"a\", \"a\"], [\"b\"], [\"c\"], [\"d\", \"d\"]])", "stop_tokens": ["\n}"]}
{"name": "mbpp_77_is_Diff", "language": "swift", "prompt": "\n/// Write a python function to find whether a number is divisible by 11.\nfunc is_Diff(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_77_is_Diff.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_Diff(n: 12345) == false)\nassert(is_Diff(n: 1212112) == true)\nassert(is_Diff(n: 1212) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_780_find_combinations", "language": "swift", "prompt": "\n/// Write a function to find the combinations of sums with tuples in the given tuple list. https://www.geeksforgeeks.org/python-combinations-of-sum-with-tuples-in-tuple-list/\nfunc find_combinations(test_list: [(Int, Int)]) -> [(Int, Int)] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_780_find_combinations.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_combinations(test_list: [(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)])\nassert(find_combinations(test_list: [(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)])\nassert(find_combinations(test_list: [(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)])", "stop_tokens": ["\n}"]}
{"name": "mbpp_781_count_divisors", "language": "swift", "prompt": "\n/// Write a python function to check whether the count of divisors is even. https://www.w3resource.com/python-exercises/basic/python-basic-1-exercise-24.php\nfunc count_divisors(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_781_count_divisors.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_divisors(n: 10) == true)\nassert(count_divisors(n: 100) == false)\nassert(count_divisors(n: 125) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_782_odd_length_sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of all odd length subarrays. https://www.geeksforgeeks.org/sum-of-all-odd-length-subarrays/\nfunc odd_length_sum(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_782_odd_length_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(odd_length_sum(arr: [1, 2, 4]) == 14)\nassert(odd_length_sum(arr: [1, 2, 1, 2]) == 15)\nassert(odd_length_sum(arr: [1, 7]) == 8)", "stop_tokens": ["\n}"]}
{"name": "mbpp_783_rgb_to_hsv", "language": "swift", "prompt": "\n/// Write a function to convert rgb color to hsv color. https://www.geeksforgeeks.org/program-change-rgb-color-model-hsv-color-model/\nfunc rgb_to_hsv(r: Int, g: Int, b: Int) -> [Double] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_783_rgb_to_hsv.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(rgb_to_hsv(r: 255, g: 255, b: 255) == [0.0, 0.0, 100.0])\nassert(rgb_to_hsv(r: 0, g: 215, b: 0) == [120.0, 100.0, 84.31372549019608])\nassert(rgb_to_hsv(r: 10, g: 215, b: 110) == [149.26829268292684, 95.34883720930233, 84.31372549019608])", "stop_tokens": ["\n}"]}
{"name": "mbpp_784_mul_even_odd", "language": "swift", "prompt": "\n/// Write a function to find the product of first even and odd number of a given list.\nfunc mul_even_odd(list1: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_784_mul_even_odd.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(mul_even_odd(list1: [1, 3, 5, 7, 4, 1, 6, 8]) == 4)\nassert(mul_even_odd(list1: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 2)\nassert(mul_even_odd(list1: [1, 5, 7, 9, 10]) == 10)", "stop_tokens": ["\n}"]}
{"name": "mbpp_785_tuple_str_int", "language": "swift", "prompt": "\n/// Write a function to convert tuple string to integer tuple.\nfunc tuple_str_int(test_str: String) -> (Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_785_tuple_str_int.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tuple_str_int(test_str: \"(7, 8, 9)\") == (7, 8, 9))\nassert(tuple_str_int(test_str: \"(1, 2, 3)\") == (1, 2, 3))\nassert(tuple_str_int(test_str: \"(4, 5, 6)\") == (4, 5, 6))\nassert(tuple_str_int(test_str: \"(7, 81, 19)\") == (7, 81, 19))", "stop_tokens": ["\n}"]}
{"name": "mbpp_786_right_insertion", "language": "swift", "prompt": "\n/// Write a function to locate the right insertion point for a specified value in sorted order.\nfunc right_insertion(a: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_786_right_insertion.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(right_insertion(a: [1, 2, 4, 5], x: 6) == 4)\nassert(right_insertion(a: [1, 2, 4, 5], x: 3) == 2)\nassert(right_insertion(a: [1, 2, 4, 5], x: 7) == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_787_text_match_three", "language": "swift", "prompt": "\n/// Write a function that matches a string that has an a followed by three 'b'.\nfunc text_match_three(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_787_text_match_three.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_match_three(text: \"ac\") == false)\nassert(text_match_three(text: \"dc\") == false)\nassert(text_match_three(text: \"abbbba\") == true)\nassert(text_match_three(text: \"caacabbbba\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_788_new_tuple", "language": "swift", "prompt": "\n/// Write a function to create a new tuple from the given string and list.\nfunc new_tuple(test_list: [String], test_str: String) -> (String, String, String) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_788_new_tuple.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(new_tuple(test_list: [\"WEB\", \"is\"], test_str: \"best\") == (\"WEB\", \"is\", \"best\"))\nassert(new_tuple(test_list: [\"We\", \"are\"], test_str: \"Developers\") == (\"We\", \"are\", \"Developers\"))\nassert(new_tuple(test_list: [\"Part\", \"is\"], test_str: \"Wrong\") == (\"Part\", \"is\", \"Wrong\"))", "stop_tokens": ["\n}"]}
{"name": "mbpp_790_even_position", "language": "swift", "prompt": "\n/// Write a python function to check whether every even index contains even numbers of a given list.\nfunc even_position(nums: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_790_even_position.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(even_position(nums: [3, 2, 1]) == false)\nassert(even_position(nums: [1, 2, 3]) == false)\nassert(even_position(nums: [2, 1, 4]) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_791_remove_nested", "language": "swift", "prompt": "\n/// Write a function to remove tuples from the given tuple.\nfunc remove_nested(test_tup: AnyHashable) -> (Int, Int, Int, Int) {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_791_remove_nested.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_nested(test_tup: (1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10))\nassert(remove_nested(test_tup: (2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11))\nassert(remove_nested(test_tup: (3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12))\nassert(remove_nested(test_tup: (3, 7, 9, (6, 8), (5, 12), 12)) == (3, 7, 9, 12))", "stop_tokens": ["\n}"]}
{"name": "mbpp_792_count_list", "language": "swift", "prompt": "\n/// Write a python function to count the number of lists in a given number of lists.\nfunc count_list(input_list: [[Int]]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_792_count_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_list(input_list: [[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4)\nassert(count_list(input_list: [[1, 2], [2, 3], [4, 5]]) == 3)\nassert(count_list(input_list: [[1, 0], [2, 0]]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_793_last", "language": "swift", "prompt": "\n/// Write a python function to find the last position of an element in a sorted array.\nfunc last(arr: [Int], x: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_793_last.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(last(arr: [1, 2, 3], x: 1) == 0)\nassert(last(arr: [1, 1, 1, 2, 3, 4], x: 1) == 2)\nassert(last(arr: [2, 3, 2, 3, 6, 8, 9], x: 3) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_794_text_starta_endb", "language": "swift", "prompt": "\n/// Write a function that matches a string that has an 'a' followed by anything, ending in 'b'.\nfunc text_starta_endb(text: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_794_text_starta_endb.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(text_starta_endb(text: \"aabbbb\") == true)\nassert(text_starta_endb(text: \"aabAbbbc\") == false)\nassert(text_starta_endb(text: \"accddbbjjj\") == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_796_return_sum", "language": "swift", "prompt": "\n/// Write function to find the sum of all items in the given dictionary.\nfunc return_sum(dict: [String : Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_796_return_sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(return_sum(dict: [\"a\" : 100, \"b\" : 200, \"c\" : 300]) == 600)\nassert(return_sum(dict: [\"a\" : 25, \"b\" : 18, \"c\" : 45]) == 88)\nassert(return_sum(dict: [\"a\" : 36, \"b\" : 39, \"c\" : 49]) == 124)", "stop_tokens": ["\n}"]}
{"name": "mbpp_797_sum_in_range", "language": "swift", "prompt": "\n/// Write a python function to find the sum of all odd natural numbers within the range l and r.\nfunc sum_in_range(l: Int, r: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_797_sum_in_range.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sum_in_range(l: 2, r: 5) == 8)\nassert(sum_in_range(l: 5, r: 7) == 12)\nassert(sum_in_range(l: 7, r: 13) == 40)", "stop_tokens": ["\n}"]}
{"name": "mbpp_798__sum", "language": "swift", "prompt": "\n/// Write a python function to find the sum of an array.\nfunc _sum(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_798__sum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(_sum(arr: [1, 2, 3]) == 6)\nassert(_sum(arr: [15, 12, 13, 10]) == 50)\nassert(_sum(arr: [0, 1, 2]) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_799_left_rotate", "language": "swift", "prompt": "\n/// Write a function to that rotate left bits by d bits a given number. We assume that the number is 32 bit.\nfunc left_rotate(n: Int, d: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_799_left_rotate.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(left_rotate(n: 16, d: 2) == 64)\nassert(left_rotate(n: 10, d: 2) == 40)\nassert(left_rotate(n: 99, d: 3) == 792)\nassert(left_rotate(n: 99, d: 3) == 792)\nassert(left_rotate(n: 1, d: 3) == 8)\nassert(left_rotate(n: 5, d: 3) == 40)\nassert(left_rotate(n: 29, d: 3) == 232)", "stop_tokens": ["\n}"]}
{"name": "mbpp_79_word_len", "language": "swift", "prompt": "\n/// Write a python function to check whether the length of the word is odd or not.\nfunc word_len(s: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_79_word_len.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(word_len(s: \"Hadoop\") == false)\nassert(word_len(s: \"great\") == true)\nassert(word_len(s: \"structure\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_800_remove_all_spaces", "language": "swift", "prompt": "\n/// Write a function to remove all whitespaces from a string.\nfunc remove_all_spaces(text: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_800_remove_all_spaces.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(remove_all_spaces(text: \"python  program\") == \"pythonprogram\")\nassert(remove_all_spaces(text: \"python   programming    language\") == \"pythonprogramminglanguage\")\nassert(remove_all_spaces(text: \"python                     program\") == \"pythonprogram\")\nassert(remove_all_spaces(text: \"   python                     program\") == \"pythonprogram\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_801_test_three_equal", "language": "swift", "prompt": "\n/// Write a python function to count the number of equal numbers from three given integers.\nfunc test_three_equal(x: Int, y: Int, z: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_801_test_three_equal.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(test_three_equal(x: 1, y: 1, z: 1) == 3)\nassert(test_three_equal(x: -1, y: -2, z: -3) == 0)\nassert(test_three_equal(x: 1, y: 2, z: 2) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_802_count_rotation", "language": "swift", "prompt": "\n/// Write a python function to count the number of rotations required to generate a sorted array. https://www.geeksforgeeks.org/count-of-rotations-required-to-generate-a-sorted-array/\nfunc count_rotation(arr: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_802_count_rotation.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(count_rotation(arr: [3, 2, 1]) == 1)\nassert(count_rotation(arr: [4, 5, 1, 2, 3]) == 2)\nassert(count_rotation(arr: [7, 8, 9, 1, 2, 3]) == 3)\nassert(count_rotation(arr: [1, 2, 3]) == 0)\nassert(count_rotation(arr: [1, 3, 2]) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_803_is_perfect_square", "language": "swift", "prompt": "\n/// Write a function to check whether the given number is a perfect square or not. https://www.geeksforgeeks.org/check-if-given-number-is-perfect-square-in-cpp/\nfunc is_perfect_square(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_803_is_perfect_square.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_perfect_square(n: 10) == false)\nassert(is_perfect_square(n: 36) == true)\nassert(is_perfect_square(n: 14) == false)\nassert(is_perfect_square(n: 196) == true)\nassert(is_perfect_square(n: 125) == false)\nassert(is_perfect_square(n: 15625) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_804_is_product_even", "language": "swift", "prompt": "\n/// Write a function to check whether the product of numbers in a list is even or not.\nfunc is_product_even(arr: [Int]) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_804_is_product_even.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_product_even(arr: [1, 2, 3]) == true)\nassert(is_product_even(arr: [1, 2, 1, 4]) == true)\nassert(is_product_even(arr: [1, 1]) == false)", "stop_tokens": ["\n}"]}
{"name": "mbpp_805_max_sum_list", "language": "swift", "prompt": "\n/// Write a function that returns the list in a list of lists whose sum of elements is the highest.\nfunc max_sum_list(lists: [[Int]]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_805_max_sum_list.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_sum_list(lists: [[1, 2, 3], [4, 5, 6], [10, 11, 12], [7, 8, 9]]) == [10, 11, 12])\nassert(max_sum_list(lists: [[3, 2, 1], [6, 5, 4], [12, 11, 10]]) == [12, 11, 10])\nassert(max_sum_list(lists: [[2, 3, 1]]) == [2, 3, 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_806_max_run_uppercase", "language": "swift", "prompt": "\n/// Write a function to find maximum run of uppercase characters in the given string.\nfunc max_run_uppercase(test_str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_806_max_run_uppercase.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(max_run_uppercase(test_str: \"GeMKSForGERksISBESt\") == 5)\nassert(max_run_uppercase(test_str: \"PrECIOusMOVemENTSYT\") == 6)\nassert(max_run_uppercase(test_str: \"GooGLEFluTTER\") == 4)", "stop_tokens": ["\n}"]}
{"name": "mbpp_807_first_odd", "language": "swift", "prompt": "\n/// Write a python function to find the first odd number in a given list of numbers.\nfunc first_odd(nums: [Int]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_807_first_odd.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(first_odd(nums: [1, 3, 5]) == 1)\nassert(first_odd(nums: [2, 4, 1, 3]) == 1)\nassert(first_odd(nums: [8, 9, 1]) == 9)", "stop_tokens": ["\n}"]}
{"name": "mbpp_808_check_K", "language": "swift", "prompt": "\n/// Write a function to check if the given tuples contain the k or not.\nfunc check_K(test_tup: [Int], K: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_808_check_K.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_K(test_tup: [10, 4, 5, 6, 8], K: 6) == true)\nassert(check_K(test_tup: [1, 2, 3, 4, 5, 6], K: 7) == false)\nassert(check_K(test_tup: [7, 8, 9, 44, 11, 12], K: 11) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_809_check_smaller", "language": "swift", "prompt": "\n/// Write a function to check if each element of second tuple is smaller than its corresponding element in the first tuple.\nfunc check_smaller(test_tup1: (Int, Int, Int), test_tup2: (Int, Int, Int)) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_809_check_smaller.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(check_smaller(test_tup1: (1, 2, 3), test_tup2: (2, 3, 4)) == false)\nassert(check_smaller(test_tup1: (4, 5, 6), test_tup2: (3, 4, 5)) == true)\nassert(check_smaller(test_tup1: (11, 12, 13), test_tup2: (10, 11, 12)) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_80_tetrahedral_number", "language": "swift", "prompt": "\n/// Write a function to find the nth tetrahedral number.\nfunc tetrahedral_number(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_80_tetrahedral_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(tetrahedral_number(n: 5) == 35)\nassert(tetrahedral_number(n: 6) == 56)\nassert(tetrahedral_number(n: 7) == 84)", "stop_tokens": ["\n}"]}
{"name": "mbpp_83_get_Char", "language": "swift", "prompt": "\n/// Write a python function to find the character made by adding the ASCII value of all the characters of the given string modulo 26.\nfunc get_Char(strr: String) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_83_get_Char.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(get_Char(strr: \"abc\") == \"f\")\nassert(get_Char(strr: \"gfg\") == \"t\")\nassert(get_Char(strr: \"ab\") == \"c\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_84_sequence", "language": "swift", "prompt": "\n/// Write a function to find the nth number in the newman conway sequence.\nfunc sequence(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_84_sequence.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(sequence(n: 10) == 6)\nassert(sequence(n: 2) == 1)\nassert(sequence(n: 3) == 2)", "stop_tokens": ["\n}"]}
{"name": "mbpp_86_centered_hexagonal_number", "language": "swift", "prompt": "\n/// Write a function to find nth centered hexagonal number.\nfunc centered_hexagonal_number(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_86_centered_hexagonal_number.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(centered_hexagonal_number(n: 10) == 271)\nassert(centered_hexagonal_number(n: 2) == 7)\nassert(centered_hexagonal_number(n: 9) == 217)", "stop_tokens": ["\n}"]}
{"name": "mbpp_87_merge_dictionaries_three", "language": "swift", "prompt": "\n/// Write a function to merge three dictionaries into a single dictionary.\nfunc merge_dictionaries_three(dict1: [String : String], dict2: [String : String], dict3: [String : String]) -> [String : String] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_87_merge_dictionaries_three.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(merge_dictionaries_three(dict1: [\"R\" : \"Red\", \"B\" : \"Black\", \"P\" : \"Pink\"], dict2: [\"G\" : \"Green\", \"W\" : \"White\"], dict3: [\"O\" : \"Orange\", \"W\" : \"White\", \"B\" : \"Black\"]) == [\"B\" : \"Black\", \"R\" : \"Red\", \"P\" : \"Pink\", \"G\" : \"Green\", \"W\" : \"White\", \"O\" : \"Orange\"])\nassert(merge_dictionaries_three(dict1: [\"R\" : \"Red\", \"B\" : \"Black\", \"P\" : \"Pink\"], dict2: [\"G\" : \"Green\", \"W\" : \"White\"], dict3: [\"L\" : \"lavender\", \"B\" : \"Blue\"]) == [\"W\" : \"White\", \"P\" : \"Pink\", \"B\" : \"Black\", \"R\" : \"Red\", \"G\" : \"Green\", \"L\" : \"lavender\"])\nassert(merge_dictionaries_three(dict1: [\"R\" : \"Red\", \"B\" : \"Black\", \"P\" : \"Pink\"], dict2: [\"L\" : \"lavender\", \"B\" : \"Blue\"], dict3: [\"G\" : \"Green\", \"W\" : \"White\"]) == [\"B\" : \"Black\", \"P\" : \"Pink\", \"R\" : \"Red\", \"G\" : \"Green\", \"L\" : \"lavender\", \"W\" : \"White\"])", "stop_tokens": ["\n}"]}
{"name": "mbpp_88_freq_count", "language": "swift", "prompt": "\n/// Write a function to get the frequency of all the elements in a list, returned as a dictionary.\nfunc freq_count(list1: [Int]) -> [Int : Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_88_freq_count.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(freq_count(list1: [10, 10, 10, 10, 20, 20, 20, 20, 40, 40, 50, 50, 30]) == [10 : 4, 20 : 4, 40 : 2, 50 : 2, 30 : 1])\nassert(freq_count(list1: [1, 2, 3, 4, 3, 2, 4, 1, 3, 1, 4]) == [1 : 3, 2 : 2, 3 : 3, 4 : 3])\nassert(freq_count(list1: [5, 6, 7, 4, 9, 10, 4, 5, 6, 7, 9, 5]) == [10 : 1, 5 : 3, 6 : 2, 7 : 2, 4 : 2, 9 : 2])", "stop_tokens": ["\n}"]}
{"name": "mbpp_89_closest_num", "language": "swift", "prompt": "\n/// Write a function to find the closest smaller number than n.\nfunc closest_num(N: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_89_closest_num.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(closest_num(N: 11) == 10)\nassert(closest_num(N: 7) == 6)\nassert(closest_num(N: 12) == 11)", "stop_tokens": ["\n}"]}
{"name": "mbpp_8_square_nums", "language": "swift", "prompt": "\n/// Write a function to find squares of individual elements in a list.\nfunc square_nums(nums: [Int]) -> [Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_8_square_nums.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(square_nums(nums: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == [1, 4, 9, 16, 25, 36, 49, 64, 81, 100])\nassert(square_nums(nums: [10, 20, 30]) == [100, 400, 900])\nassert(square_nums(nums: [12, 15]) == [144, 225])", "stop_tokens": ["\n}"]}
{"name": "mbpp_90_len_log", "language": "swift", "prompt": "\n/// Write a python function to find the length of the longest word.\nfunc len_log(list1: [String]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_90_len_log.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(len_log(list1: [\"python\", \"PHP\", \"bigdata\"]) == 7)\nassert(len_log(list1: [\"a\", \"ab\", \"abc\"]) == 3)\nassert(len_log(list1: [\"small\", \"big\", \"tall\"]) == 5)", "stop_tokens": ["\n}"]}
{"name": "mbpp_91_find_substring", "language": "swift", "prompt": "\n/// Write a function to check if a string is present as a substring in a given list of string values.\nfunc find_substring(str1: [String], sub_str: String) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_91_find_substring.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_substring(str1: [\"red\", \"black\", \"white\", \"green\", \"orange\"], sub_str: \"ack\") == true)\nassert(find_substring(str1: [\"red\", \"black\", \"white\", \"green\", \"orange\"], sub_str: \"abc\") == false)\nassert(find_substring(str1: [\"red\", \"black\", \"white\", \"green\", \"orange\"], sub_str: \"ange\") == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_92_is_undulating", "language": "swift", "prompt": "\n/// Write a function to check whether the given number is undulating or not.\nfunc is_undulating(n: Int) -> Bool {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_92_is_undulating.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(is_undulating(n: 1212121) == true)\nassert(is_undulating(n: 1991) == false)\nassert(is_undulating(n: 121) == true)", "stop_tokens": ["\n}"]}
{"name": "mbpp_93_power", "language": "swift", "prompt": "\n/// Write a function to calculate the value of 'a' to the power 'b'.\nfunc power(a: Int, b: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_93_power.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(power(a: 3, b: 4) == 81)\nassert(power(a: 2, b: 3) == 8)\nassert(power(a: 5, b: 5) == 3125)", "stop_tokens": ["\n}"]}
{"name": "mbpp_94_index_minimum", "language": "swift", "prompt": "\n/// Given a list of tuples, write a function that returns the first value of the tuple with the smallest second value.\nfunc index_minimum(test_list: [(String, Int)]) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_94_index_minimum.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(index_minimum(test_list: [(\"Rash\", 143), (\"Manjeet\", 200), (\"Varsha\", 100)]) == \"Varsha\")\nassert(index_minimum(test_list: [(\"Yash\", 185), (\"Dawood\", 125), (\"Sanya\", 175)]) == \"Dawood\")\nassert(index_minimum(test_list: [(\"Sai\", 345), (\"Salman\", 145), (\"Ayesha\", 96)]) == \"Ayesha\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_95_Find_Min_Length", "language": "swift", "prompt": "\n/// Write a python function to find the length of the smallest list in a list of lists.\nfunc Find_Min_Length(lst: [[Int]]) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_95_Find_Min_Length.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(Find_Min_Length(lst: [[1], [1, 2]]) == 1)\nassert(Find_Min_Length(lst: [[1, 2], [1, 2, 3], [1, 2, 3, 4]]) == 2)\nassert(Find_Min_Length(lst: [[3, 3, 3], [4, 4, 4, 4]]) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_96_divisor", "language": "swift", "prompt": "\n/// Write a python function to find the number of divisors of a given integer.\nfunc divisor(n: Int) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_96_divisor.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(divisor(n: 15) == 4)\nassert(divisor(n: 12) == 6)\nassert(divisor(n: 9) == 3)", "stop_tokens": ["\n}"]}
{"name": "mbpp_97_frequency_lists", "language": "swift", "prompt": "\n/// Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\nfunc frequency_lists(list1: [[Int]]) -> [Int : Int] {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_97_frequency_lists.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(frequency_lists(list1: [[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == [1 : 1, 2 : 3, 3 : 1, 4 : 1, 5 : 2, 6 : 1, 7 : 1, 8 : 1, 9 : 1])\nassert(frequency_lists(list1: [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) == [1 : 1, 2 : 1, 3 : 1, 4 : 1, 5 : 1, 6 : 1, 7 : 1, 8 : 1, 9 : 1, 10 : 1, 11 : 1, 12 : 1])\nassert(frequency_lists(list1: [[20, 30, 40, 17], [18, 16, 14, 13], [10, 20, 30, 40]]) == [20 : 2, 30 : 2, 40 : 2, 17 : 1, 18 : 1, 16 : 1, 14 : 1, 13 : 1, 10 : 1])", "stop_tokens": ["\n}"]}
{"name": "mbpp_99_decimal_to_binary", "language": "swift", "prompt": "\n/// Write a function to convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\nfunc decimal_to_binary(n: Int) -> String {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_99_decimal_to_binary.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(decimal_to_binary(n: 8) == \"1000\")\nassert(decimal_to_binary(n: 18) == \"10010\")\nassert(decimal_to_binary(n: 7) == \"111\")", "stop_tokens": ["\n}"]}
{"name": "mbpp_9_find_Rotations", "language": "swift", "prompt": "\n/// Write a python function to find the minimum number of rotations (greater than 0) required to get the same string.\nfunc find_Rotations(str: String) -> Int {\n", "doctests": "keep", "original": "/home/arjun/repos/nuprl/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_9_find_Rotations.py", "prompt_terminology": "verbatim", "tests": "}\n\n\nfunc ==(left: [(Int, Int)], right: [(Int, Int)]) -> Bool {\n    if left.count != right.count {\n        return false\n    }\n    for (l, r) in zip(left, right) {\n        if l != r {\n            return false\n        }\n    }\n    return true\n}\n            \nassert(find_Rotations(str: \"aaaa\") == 1)\nassert(find_Rotations(str: \"ab\") == 2)\nassert(find_Rotations(str: \"abc\") == 3)", "stop_tokens": ["\n}"]}
